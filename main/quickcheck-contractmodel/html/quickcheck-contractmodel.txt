-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package quickcheck-contractmodel
@version 0.1.4.1

module Test.QuickCheck.ContractModel.Internal.Common
type Era = BabbageEra
type LedgerEra = ShelleyLedgerEra Era
era :: ShelleyBasedEra Era
instance GHC.Classes.Ord (Cardano.Api.Address.AddressInEra era)

module Test.QuickCheck.ContractModel.Internal.Symbolics
data SymIndexF f
SymIndex :: f AssetId -> f (TxOut CtxUTxO Era) -> f TxIn -> SymIndexF f
[_tokens] :: SymIndexF f -> f AssetId
[_utxos] :: SymIndexF f -> f (TxOut CtxUTxO Era)
[_txIns] :: SymIndexF f -> f TxIn
utxos :: forall f_aIHn. Lens' (SymIndexF f_aIHn) (f_aIHn (TxOut CtxUTxO Era))
txIns :: forall f_aIHn. Lens' (SymIndexF f_aIHn) (f_aIHn TxIn)
tokens :: forall f_aIHn. Lens' (SymIndexF f_aIHn) (f_aIHn AssetId)
class HasSymbolicRep t
symIndexL :: HasSymbolicRep t => Lens' (SymIndexF f) (f t)
symPrefix :: HasSymbolicRep t => String
bmapConst :: FunctorB b => (forall a. f a -> c) -> b f -> Container b c
mappendSymIndexF :: forall f. (AllBF Semigroup f SymIndexF, Show (SymIndexF f)) => (forall a. f a -> Set String) -> SymIndexF f -> SymIndexF f -> SymIndexF f

-- | For an assumed variable, what's the mapping of String indices to
--   underlying actual values. This is what is returned by a contract model
--   action when it runs.
type SymIndex = SymIndexF (Map String)
symIndex :: HasSymbolicRep t => String -> t -> SymIndex

-- | For a given action, what are the String indices used to construct
--   symbolic variables when this action ran. NOTE: this purposefully does
--   not include the variable because we might want to fake the variable
--   with `Var 0` in some cases. See comment somewhere for why this is
--   safe...
type SymCreationIndex = SymIndexF (Const (Set String))
toCreationIndex :: SymIndex -> SymCreationIndex
createIndex :: forall t. HasSymbolicRep t => String -> SymCreationIndex
showCreateIndex :: SymCreationIndex -> String

-- | What symbolic variables have been created in a given run of the
--   <tt>Spec</tt> monad?
type SymCollectionIndex = SymIndexF SymSet
newtype SymSet t
SymSet :: Set (Symbolic t) -> SymSet t
[unSymSet] :: SymSet t -> Set (Symbolic t)
symCollect :: HasSymbolicRep t => Symbolic t -> SymCollectionIndex
makeSymCollection :: SymCreationIndex -> Var SymIndex -> SymCollectionIndex
symCollectionSubset :: SymCollectionIndex -> SymCollectionIndex -> Bool
data Symbolic t
Symbolic :: Var SymIndex -> String -> Symbolic t
[symVar] :: Symbolic t -> Var SymIndex
[symVarIdx] :: Symbolic t -> String
type SymbolicSemantics = forall t. HasSymbolicRep t => Symbolic t -> t
getSymbolics :: forall t. HasSymbolicRep t => SymCreationIndex -> Var SymIndex -> Set (Symbolic t)
lookupSymbolic :: HasSymbolicRep t => SymIndex -> Symbolic t -> Maybe t

-- | A symbolic token is a token that is only available at runtime
type SymToken = Symbolic AssetId

-- | A SymTxOut is a `TxOut CtxUTxO Era` that is only available at runtime
type SymTxOut = Symbolic (TxOut CtxUTxO Era)

-- | A SymTxIn is a <a>TxIn</a> that is only available at runtime
type SymTxIn = Symbolic TxIn

-- | A symbolic value is a combination of a real value and a value
--   associating symbolic tokens with an amount
data SymValue
SymValue :: Map SymToken Quantity -> Value -> SymValue
[symValMap] :: SymValue -> Map SymToken Quantity
[actualValPart] :: SymValue -> Value
pPrintValue :: Value -> Doc
pPrintAssetId :: AssetId -> Doc

-- | Check if a symbolic value is zero
symIsZero :: SymValue -> Bool

-- | Check if one symbolic value is less than or equal to another
symLeq :: SymValue -> SymValue -> Bool

-- | Using a semantics function for symbolic tokens, convert a SymValue to
--   a Value
toValue :: (SymToken -> AssetId) -> SymValue -> Value

-- | Invert a sym token mapping to turn a Value into a SymValue, useful for
--   error reporting
toSymVal :: (AssetId -> Maybe SymToken) -> Value -> SymValue
inv :: SymValue -> SymValue
class SymValueLike v
toSymValue :: SymValueLike v => v -> SymValue
class TokenLike t

-- | Get the value of a specific token in a <a>SymValue</a>
symAssetIdValueOf :: TokenLike t => SymValue -> t -> Quantity

-- | Convert a token and an amount to a <a>SymValue</a>
symAssetIdValue :: TokenLike t => t -> Quantity -> SymValue
instance forall k (t :: k). GHC.Classes.Ord (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t)
instance forall k (t :: k). GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t)
instance forall k (t :: k). GHC.Base.Monoid (Test.QuickCheck.ContractModel.Internal.Symbolics.SymSet t)
instance forall k (t :: k). GHC.Base.Semigroup (Test.QuickCheck.ContractModel.Internal.Symbolics.SymSet t)
instance forall k (t :: k). GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Symbolics.SymSet t)
instance GHC.Generics.Generic Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance GHC.Show.Show Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Classes.Eq f Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF f)
instance forall k (t :: k). GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t) => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Symbolics.SymSet t)
instance Test.QuickCheck.ContractModel.Internal.Symbolics.TokenLike Test.QuickCheck.ContractModel.Internal.Symbolics.SymToken
instance Test.QuickCheck.ContractModel.Internal.Symbolics.TokenLike Cardano.Api.Value.AssetId
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Cardano.Api.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance GHC.Base.Monoid Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance GHC.Classes.Eq Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance Text.PrettyPrint.HughesPJClass.Pretty Test.QuickCheck.ContractModel.Internal.Symbolics.SymValue
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.Internal.Symbolics.SymCollectionIndex
instance Test.QuickCheck.ContractModel.Internal.Symbolics.HasSymbolicRep t => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t)
instance forall k (t :: k). Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t)
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.Internal.Symbolics.SymCreationIndex
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndex
instance Test.QuickCheck.ContractModel.Internal.Symbolics.HasSymbolicRep Cardano.Api.Value.AssetId
instance Test.QuickCheck.ContractModel.Internal.Symbolics.HasSymbolicRep (Cardano.Api.TxBody.TxOut Cardano.Api.TxBody.CtxUTxO Test.QuickCheck.ContractModel.Internal.Common.Era)
instance Test.QuickCheck.ContractModel.Internal.Symbolics.HasSymbolicRep Cardano.Api.TxIn.TxIn
instance (Barbies.Internal.ConstraintsB.AllBF GHC.Base.Monoid f Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF, GHC.Base.Semigroup (Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF f)) => GHC.Base.Monoid (Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF f)
instance Barbies.Internal.TraversableB.TraversableB Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF
instance Barbies.Internal.ApplicativeB.ApplicativeB Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF
instance Barbies.Internal.FunctorB.FunctorB Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF
instance Barbies.Internal.ConstraintsB.ConstraintsB Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF
instance GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndexF f)

module Test.QuickCheck.ContractModel.Internal.Spec

-- | The <a>ModelState</a> models the state of the blockchain. It contains,
--   
--   <ul>
--   <li>the contract-specific state (<a>contractState</a>)</li>
--   <li>the current slot (<a>currentSlot</a>)</li>
--   <li>the wallet balances (<tt>balances</tt>)</li>
--   <li>the amount that has been minted (<a>minted</a>)</li>
--   </ul>
data ModelState state
ModelState :: SlotNo -> Map (AddressInEra Era) SymValue -> SymValue -> SymCollectionIndex -> [(String, Bool)] -> Bool -> state -> ModelState state
[_currentSlot] :: ModelState state -> SlotNo
[_balanceChanges] :: ModelState state -> Map (AddressInEra Era) SymValue
[_minted] :: ModelState state -> SymValue
[_symbolics] :: ModelState state -> SymCollectionIndex
[_assertions] :: ModelState state -> [(String, Bool)]
[_assertionsOk] :: ModelState state -> Bool
[_contractState] :: ModelState state -> state

-- | The <a>Spec</a> monad is a state monad over the <a>ModelState</a> with
--   reader and writer components to keep track of newly created symbolic
--   tokens. It is used exclusively by the <a>nextState</a> function to
--   model the effects of an action on the blockchain.
newtype Spec state a
Spec :: WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a -> Spec state a
[unSpec] :: Spec state a -> WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a
coerceSpec :: forall s s' a. Coercible s s' => Spec s a -> Spec s' a

-- | Lens for the contract-specific part of the model state.
contractState :: forall state_aTto state_aU16. Lens (ModelState state_aTto) (ModelState state_aU16) state_aTto state_aU16
currentSlotL :: forall state_aTto. Lens' (ModelState state_aTto) SlotNo
balanceChangesL :: forall state_aTto. Lens' (ModelState state_aTto) (Map (AddressInEra Era) SymValue)
mintedL :: forall state_aTto. Lens' (ModelState state_aTto) SymValue
assertions :: forall state_aTto. Lens' (ModelState state_aTto) [(String, Bool)]
assertionsOk :: forall state_aTto. Lens' (ModelState state_aTto) Bool
symbolics :: forall state_aTto. Lens' (ModelState state_aTto) SymCollectionIndex

-- | Get the current slot.
--   
--   <a>Spec</a> monad update functions: <tt>wait</tt> and
--   <tt>waitUntil</tt>.
currentSlot :: Getter (ModelState state) SlotNo

-- | Get the current wallet balance changes. These are delta balances, so
--   they start out at zero and can be negative. The absolute balances used
--   by the emulator can be set in the <tt>CheckOptions</tt> argument to
--   <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChanges :: Getter (ModelState state) (Map (AddressInEra Era) SymValue)

-- | Get the current balance change for a wallet. This is the delta
--   balance, so it starts out at zero and can be negative. The absolute
--   balance used by the emulator can be set in the <tt>CheckOptions</tt>
--   argument to <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChange :: Ord (AddressInEra Era) => AddressInEra Era -> Getter (ModelState state) SymValue

-- | Get the amount of tokens minted so far. This is used to compute
--   <a>lockedValue</a>.
--   
--   <a>Spec</a> monad update functions: <a>mint</a> and <a>burn</a>.
minted :: Getter (ModelState state) SymValue

-- | How much value is currently locked by contracts. This computed by
--   subtracting the wallet <tt>balances</tt> from the <a>minted</a> value.
lockedValue :: ModelState s -> SymValue

-- | Modify a field in the <a>ModelState</a>
modState :: forall state a. Setter' (ModelState state) a -> (a -> a) -> Spec state ()

-- | Monads with read access to the model state: the <a>Spec</a> monad used
--   in <a>nextState</a>, and the <tt>DL</tt> monad used to construct test
--   scenarios.
class Monad m => GetModelState m where {
    
    -- | The contract state type of the monad. For both <a>Spec</a> and
    --   <tt>DL</tt> this is simply the <tt>state</tt> parameter of the
    --   respective monad.
    type family StateType m :: *;
}

-- | Get the current model state.
getModelState :: GetModelState m => m (ModelState (StateType m))

-- | Get the contract state part of the model state.
getContractState :: GetModelState m => m (StateType m)

-- | Get a component of the model state.
askModelState :: GetModelState m => (ModelState (StateType m) -> a) -> m a

-- | Get a component of the contract state.
askContractState :: GetModelState m => (StateType m -> a) -> m a

-- | Get a component of the model state using a lens.
viewModelState :: GetModelState m => Getting a (ModelState (StateType m)) a -> m a

-- | Get a component of the contract state using a lens.
viewContractState :: GetModelState m => Getting a (StateType m) a -> m a
runSpec :: Spec state () -> Var SymIndex -> ModelState state -> ModelState state
symbolicsCreatedBy :: Spec state () -> Var SymIndex -> ModelState state -> SymCreationIndex
createSymbolic :: forall t state. HasSymbolicRep t => String -> Spec state (Symbolic t)

-- | Create a new symbolic token in <a>nextState</a> - must have a
--   corresponding <tt>registerToken</tt> call in <a>perform</a>
createToken :: String -> Spec state SymToken

-- | Create a new symbolic TxOut in <a>nextState</a> - must have a
--   corresponding <tt>registerTxOut</tt> call in <a>perform</a>
createTxOut :: String -> Spec state SymTxOut

-- | Create a new symbolic TxIn in <a>nextState</a> - must have a
--   corresponding <tt>registerTxIn</tt> call in <a>perform</a>
createTxIn :: String -> Spec state SymTxIn

-- | Mint tokens. Minted tokens start out as <a>lockedValue</a> (i.e. owned
--   by the contract) and can be transferred to wallets using
--   <a>deposit</a>.
mint :: SymValueLike v => v -> Spec state ()

-- | Burn tokens. Equivalent to <tt><a>mint</a> . <a>inv</a></tt>.
burn :: SymValueLike v => v -> Spec state ()

-- | Add tokens to the <a>balanceChange</a> of an address. The added tokens
--   are subtracted from the <a>lockedValue</a> of tokens held by
--   contracts.
deposit :: SymValueLike v => AddressInEra Era -> v -> Spec state ()

-- | Withdraw tokens from an address. The withdrawn tokens are added to the
--   <a>lockedValue</a> of tokens held by contracts.
withdraw :: SymValueLike v => AddressInEra Era -> v -> Spec state ()

-- | Transfer tokens between wallets, updating their <tt>balances</tt>.
transfer :: SymValueLike v => AddressInEra Era -> AddressInEra Era -> v -> Spec state ()

-- | Assert that a particular predicate holds at a point in the
--   specification
assertSpec :: String -> Bool -> Spec state ()
instance Test.QuickCheck.ContractModel.Internal.Spec.GetModelState (Test.QuickCheck.ContractModel.Internal.Spec.Spec state)
instance GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state)
instance GHC.Show.Show state => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state)
instance GHC.Base.Monad (Test.QuickCheck.ContractModel.Internal.Spec.Spec state)
instance GHC.Base.Applicative (Test.QuickCheck.ContractModel.Internal.Spec.Spec state)
instance GHC.Base.Functor (Test.QuickCheck.ContractModel.Internal.Spec.Spec state)
instance Control.Monad.State.Class.MonadState state (Test.QuickCheck.ContractModel.Internal.Spec.Spec state)
instance GHC.Base.Functor Test.QuickCheck.ContractModel.Internal.Spec.ModelState

module Test.QuickCheck.ContractModel.Internal.Utils
getTxOuts :: Tx Era -> [TxOut CtxTx Era]
getTxInputs :: Tx Era -> UTxO Era -> [TxOut CtxUTxO Era]
bucket :: (Num a, Ord a, Show a, Integral a) => a -> a -> [String]

module Test.QuickCheck.ContractModel.Internal.ChainIndex
data ChainState
ChainState :: SlotNo -> UTxO Era -> ChainState
[slot] :: ChainState -> SlotNo
[utxo] :: ChainState -> UTxO Era
data TxInState
TxInState :: Tx Era -> ChainState -> Bool -> TxInState
[tx] :: TxInState -> Tx Era
[chainState] :: TxInState -> ChainState
[accepted] :: TxInState -> Bool
data ChainIndex
ChainIndex :: [TxInState] -> NetworkId -> ChainIndex
[transactions] :: ChainIndex -> [TxInState]
[networkId] :: ChainIndex -> NetworkId
class HasChainIndex m
getChainIndex :: HasChainIndex m => m ChainIndex
getChainState :: HasChainIndex m => m ChainState
allMinAda :: ChainIndex -> ProtocolParameters -> [Lovelace]
type FeeCalculation = NetworkId -> TxInState -> Map (AddressInEra Era) Value
signerPaysFees :: FeeCalculation
mkAddrFromWitness :: NetworkId -> KeyWitness Era -> Address ShelleyAddr
getBalanceChangesDiscountingFees :: ChainIndex -> FeeCalculation -> Map (AddressInEra Era) Value
txBalanceChanges :: TxInState -> Map (AddressInEra Era) Value
instance (GHC.Base.Monad m, Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex m) => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monad m, Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex m) => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monad m, GHC.Base.Monoid w, Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex m) => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.Internal.ChainIndex.ChainIndex

module Test.QuickCheck.ContractModel.Internal.Model
class HasSymbolics a
getAllSymbolics :: HasSymbolics a => a -> SymCollectionIndex
getAllSymbolics :: (HasSymbolics a, Generic a, GenericHasSymbolics (Rep a)) => a -> SymCollectionIndex
newtype BaseType a
BaseType :: a -> BaseType a
class GenericHasSymbolics f
genericGetAllSymbolics :: GenericHasSymbolics f => f k -> SymCollectionIndex

-- | A <a>ContractModel</a> instance captures everything that is needed to
--   generate and run tests of a contract or set of contracts. It specifies
--   among other things
--   
--   <ul>
--   <li>what operations are supported by the contract
--   (<a>Action</a>),</li>
--   <li>when they are valid (<a>precondition</a>),</li>
--   <li>how to generate random actions (<a>arbitraryAction</a>),</li>
--   <li>how the operations affect the state (<a>nextState</a>), and</li>
--   <li>how to run the operations in the emulator (<tt>perform</tt>)</li>
--   </ul>
class (Typeable state, Show state, HasActions state) => ContractModel state where {
    
    -- | The type of actions that are supported by the contract. An action
    --   usually represents a single <a>callEndpoint</a> or a transfer of
    --   tokens, but it can be anything that can be interpreted in the
    --   <tt>EmulatorTrace</tt> monad.
    data family Action state;
}

-- | Given the current model state, provide a QuickCheck generator for a
--   random next action. This is used in the <a>Arbitrary</a> instance for
--   <a>Actions</a>s as well as by <tt>anyAction</tt> and
--   <tt>anyActions</tt>.
arbitraryAction :: ContractModel state => ModelState state -> Gen (Action state)

-- | The name of an Action, used to report statistics.
actionName :: ContractModel state => Action state -> String

-- | The probability that we will generate a <a>WaitUntil</a> in a given
--   state
waitProbability :: ContractModel state => ModelState state -> Double

-- | Control the distribution of how long <a>WaitUntil</a> waits
arbitraryWaitInterval :: ContractModel state => ModelState state -> Gen SlotNo

-- | The initial state, before any actions have been performed.
initialState :: ContractModel state => state

-- | The <a>precondition</a> function decides if a given action is valid in
--   a given state. Typically actions generated by <a>arbitraryAction</a>
--   will satisfy the precondition, but if they don't they will be
--   discarded and another action will be generated. More importantly, the
--   preconditions are used when shrinking (see <a>shrinkAction</a>) to
--   ensure that shrunk test cases still make sense.
--   
--   If an explicit <tt>action</tt> in a <tt>DL</tt> scenario violates the
--   precondition an error is raised.
precondition :: ContractModel state => ModelState state -> Action state -> Bool

-- | <a>nextReactiveState</a> is run every time the model <a>wait</a>s for
--   a slot to be reached. This can be used to model reactive components of
--   off-chain code.
nextReactiveState :: ContractModel state => SlotNo -> Spec state ()

-- | This is where the model logic is defined. Given an action,
--   <a>nextState</a> specifies the effects running that action has on the
--   model state. It runs in the <a>Spec</a> monad, which is a state monad
--   over the <a>ModelState</a>.
nextState :: ContractModel state => Action state -> Spec state ()

-- | When a test involving random sequences of actions fails, the framework
--   tries to find a minimal failing test case by shrinking the original
--   failure. Action sequences are shrunk by removing individual actions,
--   or by replacing an action by one of the (simpler) actions returned by
--   <a>shrinkAction</a>.
--   
--   See <a>shrink</a> for more information on shrinking.
shrinkAction :: ContractModel state => ModelState state -> Action state -> [Action state]
restricted :: ContractModel state => Action state -> Bool

-- | Check if a given action creates new symbolic tokens in a given
--   <a>ModelState</a>
createsSymbolics :: ContractModel state => ModelState state -> Action state -> Bool

-- | Wait the given number of slots. Updates the <a>currentSlot</a> of the
--   model state.
wait :: ContractModel state => Integer -> Spec state ()

-- | Wait until the given slot. Has no effect if <a>currentSlot</a> is
--   greater than the given slot.
waitUntil :: ContractModel state => SlotNo -> Spec state ()
contractAction :: ContractModel state => ModelState state -> Action state -> Action (ModelState state) SymIndex
data Actions s
Actions_ :: [String] -> Smart [Act s] -> Actions s
pattern ContractAction :: () => Bool -> Action state -> Action (ModelState state) SymIndex
pattern WaitUntil :: () => SlotNo -> Action (ModelState state) ()
pattern Observation :: () => String -> (SymbolicSemantics -> ChainState -> Bool) -> Action (ModelState state) ()
pattern Actions :: [Act s] -> Actions s
data Act s
Bind :: Var SymIndex -> Action s -> Act s
[varOf] :: Act s -> Var SymIndex
[actionOf] :: Act s -> Action s
NoBind :: Var SymIndex -> Action s -> Act s
[varOf] :: Act s -> Var SymIndex
[actionOf] :: Act s -> Action s
ActWaitUntil :: Var () -> SlotNo -> Act s
ActObservation :: Var () -> String -> (SymbolicSemantics -> ChainState -> Bool) -> Act s
mapActions :: (Action s -> Action s') -> Actions s -> Actions s'
isBind :: Act s -> Bool
toStateModelActions :: ContractModel state => Actions state -> Actions (ModelState state)
fromStateModelActions :: Actions (ModelState s) -> Actions s
dummyModelState :: state -> ModelState state
stateAfter :: ContractModel state => Actions state -> ModelState state
annotatedStateAfter :: ContractModel state => Actions state -> Annotated (ModelState state)
asserts :: ModelState state -> Property
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics GHC.Integer.Type.Integer
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics GHC.Types.Int
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics GHC.Types.Char
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics Cardano.Api.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics Cardano.Api.Value.Quantity
instance Test.QuickCheck.StateModel.Variables.HasVariables (Cardano.Api.Address.AddressInEra Test.QuickCheck.ContractModel.Internal.Common.Era)
instance Test.QuickCheck.StateModel.Variables.HasVariables Cardano.Api.Value.Quantity
instance Test.QuickCheck.StateModel.Variables.HasVariables Cardano.Api.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Actions state)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel s => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.ContractModel.Internal.Model.Actions s)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel s => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Act s)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Act state)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => GHC.Show.Show (Test.QuickCheck.StateModel.Action (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state) a)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => GHC.Classes.Eq (Test.QuickCheck.StateModel.Action (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state) a)
instance Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.ContractModel.Internal.Model.Action state) => Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.StateModel.Action (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state) a)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => Test.QuickCheck.StateModel.StateModel (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state)
instance Test.QuickCheck.ContractModel.Internal.Symbolics.HasSymbolicRep t => Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Test.QuickCheck.ContractModel.Internal.Symbolics.Symbolic t)
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Test.QuickCheck.ContractModel.Internal.Model.BaseType a)
instance (Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics k, Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics v) => Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Data.Map.Internal.Map k v)
instance (GHC.Generics.Generic a, Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics (GHC.Generics.Rep a)) => Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics a
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics c => Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics (GHC.Generics.K1 i c)
instance forall k (f :: k -> *) i (c :: GHC.Generics.Meta). Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics f => Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics (GHC.Generics.M1 i c f)
instance Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics GHC.Generics.U1
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics f, Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics g) => Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics (f GHC.Generics.:*: g)
instance forall k (f :: k -> *) (g :: k -> *). (Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics f, Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics g) => Test.QuickCheck.ContractModel.Internal.Model.GenericHasSymbolics (f GHC.Generics.:+: g)

module Test.QuickCheck.ContractModel.DL

-- | The monad for writing test scenarios. It supports non-deterministic
--   choice through <a>Alternative</a>, failure with <a>MonadFail</a>, and
--   access to the model state through <a>GetModelState</a>. It is lazy, so
--   scenarios can be potentially infinite, although the probability of
--   termination needs to be high enough that concrete test cases are
--   always finite. See <a>stopping</a> for more information on
--   termination.
type DL state = DL (ModelState state)
class ActionLike state a | a -> state

-- | Generate a specific action. Fails if the action's <a>precondition</a>
--   is not satisfied.
action :: ActionLike state a => a -> DL state ()
observe :: ContractModel state => String -> ((forall t. HasSymbolicRep t => Symbolic t -> t) -> ChainState -> Bool) -> DL state ()
waitUntilDL :: forall state. ContractModel state => SlotNo -> DL state ()

-- | Generate a random action using <a>arbitraryAction</a>. The generated
--   action is guaranteed to satisfy its <a>precondition</a>. Fails with
--   <tt>Stuck</tt> if no action satisfying the precondition can be found
--   after 100 attempts.
anyAction :: DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. The argument is the
--   expected number of actions in the sequence chosen from a geometric
--   distribution, unless in the <a>stopping</a> stage, in which case as
--   few actions as possible are generated.
anyActions :: Int -> DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. Actions may be
--   generated until the <a>stopping</a> stage is reached; the expected
--   length is size/2.
anyActions_ :: DL state ()

-- | Test case generation from <a>DL</a> scenarios have a target length of
--   the action sequence to be generated that is based on the QuickCheck
--   size parameter (see <a>sized</a>). However, given that scenarios can
--   contain explicit <a>action</a>s it might not be possible to stop the
--   scenario once the target length has been reached.
--   
--   Instead, once the target number of actions have been reached,
--   generation goes into the <i>stopping</i> phase. In this phase branches
--   starting with <a>stopping</a> are preferred, if possible. Conversely,
--   before the stopping phase, branches starting with <a>stopping</a> are
--   avoided unless there are no other possible choices.
--   
--   For example, here is the definition of <a>anyActions</a>:
--   
--   <pre>
--   <a>anyActions</a> n = <a>stopping</a> <a>&lt;|&gt;</a> pure ()
--                          <a>&lt;|&gt;</a> (<a>weight</a> (fromIntegral n) &gt;&gt; <a>anyAction</a> &gt;&gt; <a>anyActions</a> n)
--   </pre>
--   
--   The effect of this definition is that the second or third branch will
--   be taken until the desired number of actions have been generated, at
--   which point the <a>stopping</a> branch will be taken and generation
--   stops (or continues with whatever comes after the <a>anyActions</a>
--   call).
--   
--   Now, it might not be possible, or too hard, to find a way to terminate
--   a scenario. For instance, this scenario has no finite test cases:
--   
--   <pre>
--   looping = <a>anyAction</a> &gt;&gt; looping
--   </pre>
--   
--   To prevent test case generation from looping, if a scenario has not
--   terminated after generating <tt>2 * n + 20</tt> actions, where
--   <tt>n</tt> is when the stopping phase kicks in, generation fails with
--   a <tt>Looping</tt> error.
stopping :: DL state ()

-- | By default, <a>Alternative</a> choice (<a>&lt;|&gt;</a>) picks among
--   the next actions with equal probability. So, for instance, this code
--   chooses between the actions <tt>a</tt>, <tt>b</tt> and <tt>c</tt>,
--   with a probability <tt>1/3</tt> of choosing each:
--   
--   <pre>
--   unbiasedChoice a b c = <a>action</a> a <a>&lt;|&gt;</a> <a>action</a> b <a>&lt;|&gt;</a> <a>action</a> c
--   </pre>
--   
--   To change this you can use <a>weight</a>, which multiplies the
--   relative probability of picking a branch by the given number.
--   
--   For instance, the following scenario picks the action <tt>a</tt> with
--   probability <tt>2/3</tt> and the action <tt>b</tt> with probability
--   <tt>1/3</tt>:
--   
--   <pre>
--   biasedChoice a b = <a>weight</a> 2 (<a>action</a> a) <a>&lt;|&gt;</a> <a>weight</a> (<a>action</a> b)
--   </pre>
--   
--   Calls to <a>weight</a> need to appear at the top-level after a choice,
--   preceding any actions (<a>action</a>/<a>anyAction</a>) or random
--   generation (<tt>forAllQ</tt>), or they will have no effect.
weight :: Double -> DL state ()

-- | Sometimes test case generation should depend on QuickCheck's size
--   parameter. This can be accessed using <tt>getSize</tt>. For example,
--   <tt>anyActions_</tt> is defined by
--   
--   <pre>
--   anyActions_ = do n &lt;- getSize
--                    anyActions (n <a>div</a> 2 + 1)
--   </pre>
--   
--   so that we generate a random number of actions, but on average half
--   the size (which is about the same as the average random positive
--   integer, or length of a list).
getSize :: DL state Int

-- | The <a>monitor</a> function allows you to collect statistics of your
--   testing using QuickCheck functions like <a>label</a>, <a>collect</a>,
--   <a>classify</a>, and <a>tabulate</a>. See also the <tt>monitoring</tt>
--   method of <a>ContractModel</a> which is called for all actions in a
--   test case (regardless of whether they are generated by an explicit
--   <a>action</a> or an <a>anyAction</a>).
monitor :: (Property -> Property) -> DL state ()

-- | Fail unless the given predicate holds of the model state.
--   
--   Equivalent to
--   
--   <pre>
--   assertModel msg p = do
--     s &lt;- <a>getModelState</a>
--     <a>assert</a> msg (p s)
--   </pre>
assertModel :: String -> (ModelState state -> Bool) -> DL state ()

-- | Turn a <a>DL</a> scenario into a QuickCheck property. Generates a
--   random <a>Actions</a> matching the scenario and feeds it to the given
--   property. The property can be a full property running the emulator and
--   checking the results, defined using <tt>propRunActions_</tt>,
--   <tt>propRunActions</tt>, or <tt>propRunActionsWithOptions</tt>.
--   Assuming a model for an auction contract and <a>DL</a> scenario that
--   checks that you can always complete the auction, you can write:
--   
--   <pre>
--   finishAuction :: <a>DL</a> AuctionState ()
--   prop_Auction  = <tt>propRunActions_</tt> handles
--     where handles = ...
--   prop_Finish = <a>forAllDL</a> finishAuction prop_Auction
--   </pre>
--   
--   However, there is also value in a property that does not run the
--   emulator at all:
--   
--   <pre>
--   prop_FinishModel = <a>forAllDL</a> finishAuction $ const True
--   </pre>
--   
--   This will check all the assertions and other failure conditions of the
--   <a>DL</a> scenario very quickly. Once this property passes a large
--   number of tests, you can run the full property checking that the model
--   agrees with reality.
forAllDL :: (ContractModel state, Testable p) => DL state () -> (Actions state -> p) -> Property
forAllUniqueDL :: forall state p. (ContractModel state, Testable p) => Annotated (ModelState state) -> DL state () -> (Actions state -> p) -> Property
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel state => Test.QuickCheck.ContractModel.DL.ActionLike state (Test.QuickCheck.ContractModel.Internal.Model.Action state)
instance (Test.QuickCheck.ContractModel.Internal.Model.ContractModel state, Data.Typeable.Internal.Typeable a) => Test.QuickCheck.ContractModel.DL.ActionLike state (Test.QuickCheck.StateModel.Action (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state) a)
instance Test.QuickCheck.ContractModel.Internal.Spec.GetModelState (Test.QuickCheck.ContractModel.DL.DL state)
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel s => Test.QuickCheck.DynamicLogic.Internal.DynLogicModel (Test.QuickCheck.ContractModel.Internal.Spec.ModelState s)

module Test.QuickCheck.ContractModel.Internal
class (ContractModel state, IsRunnable m) => RunModel state m

-- | Perform an <a>Action</a> in some <a>state</a> in the <a>Monad</a>
--   <tt>m</tt>. This is the function that's used to exercise the actual
--   stateful implementation, usually through various side-effects as
--   permitted by <tt>m</tt>. It produces a value of type <tt>a</tt>, eg.
--   some observable output from the <a>Action</a> that should later be
--   kept in the environment through a `Var a` also passed to the
--   <a>nextState</a> function.
--   
--   The <tt>Lookup</tt> parameter provides an <i>environment</i> to lookup
--   `Var a` instances from previous steps.
perform :: RunModel state m => ModelState state -> Action state -> (forall t. HasSymbolicRep t => Symbolic t -> t) -> RunMonad m ()

-- | Allows the user to attach information to the <a>Property</a> at each
--   step of the process. This function is given the full transition that's
--   been executed, including the start and ending <a>state</a>, the
--   <a>Action</a>, the current environment to <tt>Lookup</tt> and the
--   value produced by <a>perform</a> while executing this step.
monitoring :: RunModel state m => (ModelState state, ModelState state) -> Action state -> (forall t. HasSymbolicRep t => Symbolic t -> t) -> SymIndex -> Property -> Property
newtype RunMonad m a
RunMonad :: WriterT SymIndex m a -> RunMonad m a
[unRunMonad] :: RunMonad m a -> WriterT SymIndex m a
liftRunMonad :: (forall a. m a -> n a) -> RunMonad m a -> RunMonad n a
registerSymbolic :: (Monad m, HasSymbolicRep t) => String -> t -> RunMonad m ()
registerToken :: Monad m => String -> AssetId -> RunMonad m ()
registerTxOut :: Monad m => String -> TxOut CtxUTxO Era -> RunMonad m ()
registerTxIn :: Monad m => String -> TxIn -> RunMonad m ()
withLocalSymbolics :: Monad m => RunMonad m () -> RunMonad m SymIndex
type DefaultRealized m = (Realized m SymIndex ~ SymIndex, Realized m () ~ ())
class (DefaultRealized m, HasChainIndex m, Monad m) => IsRunnable m
awaitSlot :: IsRunnable m => SlotNo -> m ()
translateSymbolic :: (Var SymIndex -> SymIndex) -> SymbolicSemantics
data ContractModelResult state
ContractModelResult :: ModelState state -> Map SymToken AssetId -> ChainIndex -> ContractModelResult state
[finalModelState] :: ContractModelResult state -> ModelState state
[symbolicTokens] :: ContractModelResult state -> Map SymToken AssetId
[finalChainIndex] :: ContractModelResult state -> ChainIndex
runContractModel :: (ContractModel state, RunModel state m, HasChainIndex m) => Actions state -> PropertyM (RunMonad m) (ContractModelResult state)
data BalanceChangeOptions
BalanceChangeOptions :: Bool -> FeeCalculation -> ProtocolParameters -> (AddressInEra Era -> String) -> BalanceChangeOptions
[observeScriptValue] :: BalanceChangeOptions -> Bool
[feeCalucation] :: BalanceChangeOptions -> FeeCalculation
[protocolParameters] :: BalanceChangeOptions -> ProtocolParameters
[addressPrettyPrinter] :: BalanceChangeOptions -> AddressInEra Era -> String
assertBalanceChangesMatch :: BalanceChangeOptions -> ContractModelResult state -> Property
instance GHC.Base.Monad m => Control.Monad.Writer.Class.MonadWriter Test.QuickCheck.ContractModel.Internal.Symbolics.SymIndex (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance GHC.Base.Monad m => GHC.Base.Monad (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance GHC.Base.Functor m => GHC.Base.Functor (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance (Test.QuickCheck.ContractModel.Internal.IsRunnable m, Test.QuickCheck.ContractModel.Internal.RunModel state m) => Test.QuickCheck.StateModel.RunModel (Test.QuickCheck.ContractModel.Internal.Spec.ModelState state) (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance (GHC.Base.Monoid w, Test.QuickCheck.ContractModel.Internal.DefaultRealized m, Test.QuickCheck.ContractModel.Internal.IsRunnable m) => Test.QuickCheck.ContractModel.Internal.IsRunnable (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Test.QuickCheck.ContractModel.Internal.DefaultRealized m, Test.QuickCheck.ContractModel.Internal.IsRunnable m) => Test.QuickCheck.ContractModel.Internal.IsRunnable (Control.Monad.Trans.State.Lazy.StateT s m)
instance (Test.QuickCheck.ContractModel.Internal.DefaultRealized m, Test.QuickCheck.ContractModel.Internal.IsRunnable m) => Test.QuickCheck.ContractModel.Internal.IsRunnable (Control.Monad.Trans.Reader.ReaderT r m)
instance Test.QuickCheck.ContractModel.Internal.IsRunnable m => Test.QuickCheck.ContractModel.Internal.IsRunnable (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance Control.Monad.Trans.Class.MonadTrans Test.QuickCheck.ContractModel.Internal.RunMonad
instance (GHC.Base.Monad m, Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex m) => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Test.QuickCheck.ContractModel.Internal.RunMonad m)
instance (GHC.Base.Monad m, Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex m) => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Test.QuickCheck.StateModel.PostconditionM m)

module Test.QuickCheck.ContractModel

-- | A <a>ContractModel</a> instance captures everything that is needed to
--   generate and run tests of a contract or set of contracts. It specifies
--   among other things
--   
--   <ul>
--   <li>what operations are supported by the contract
--   (<a>Action</a>),</li>
--   <li>when they are valid (<a>precondition</a>),</li>
--   <li>how to generate random actions (<a>arbitraryAction</a>),</li>
--   <li>how the operations affect the state (<a>nextState</a>), and</li>
--   <li>how to run the operations in the emulator (<tt>perform</tt>)</li>
--   </ul>
class (Typeable state, Show state, HasActions state) => ContractModel state where {
    
    -- | The type of actions that are supported by the contract. An action
    --   usually represents a single <a>callEndpoint</a> or a transfer of
    --   tokens, but it can be anything that can be interpreted in the
    --   <tt>EmulatorTrace</tt> monad.
    data family Action state;
}

-- | Given the current model state, provide a QuickCheck generator for a
--   random next action. This is used in the <a>Arbitrary</a> instance for
--   <a>Actions</a>s as well as by <tt>anyAction</tt> and
--   <tt>anyActions</tt>.
arbitraryAction :: ContractModel state => ModelState state -> Gen (Action state)

-- | The name of an Action, used to report statistics.
actionName :: ContractModel state => Action state -> String

-- | The probability that we will generate a <a>WaitUntil</a> in a given
--   state
waitProbability :: ContractModel state => ModelState state -> Double

-- | Control the distribution of how long <a>WaitUntil</a> waits
arbitraryWaitInterval :: ContractModel state => ModelState state -> Gen SlotNo

-- | The initial state, before any actions have been performed.
initialState :: ContractModel state => state

-- | The <a>precondition</a> function decides if a given action is valid in
--   a given state. Typically actions generated by <a>arbitraryAction</a>
--   will satisfy the precondition, but if they don't they will be
--   discarded and another action will be generated. More importantly, the
--   preconditions are used when shrinking (see <a>shrinkAction</a>) to
--   ensure that shrunk test cases still make sense.
--   
--   If an explicit <tt>action</tt> in a <tt>DL</tt> scenario violates the
--   precondition an error is raised.
precondition :: ContractModel state => ModelState state -> Action state -> Bool

-- | <a>nextReactiveState</a> is run every time the model <a>wait</a>s for
--   a slot to be reached. This can be used to model reactive components of
--   off-chain code.
nextReactiveState :: ContractModel state => SlotNo -> Spec state ()

-- | This is where the model logic is defined. Given an action,
--   <a>nextState</a> specifies the effects running that action has on the
--   model state. It runs in the <a>Spec</a> monad, which is a state monad
--   over the <a>ModelState</a>.
nextState :: ContractModel state => Action state -> Spec state ()

-- | When a test involving random sequences of actions fails, the framework
--   tries to find a minimal failing test case by shrinking the original
--   failure. Action sequences are shrunk by removing individual actions,
--   or by replacing an action by one of the (simpler) actions returned by
--   <a>shrinkAction</a>.
--   
--   See <a>shrink</a> for more information on shrinking.
shrinkAction :: ContractModel state => ModelState state -> Action state -> [Action state]
restricted :: ContractModel state => Action state -> Bool
class (ContractModel state, IsRunnable m) => RunModel state m

-- | Perform an <a>Action</a> in some <a>state</a> in the <a>Monad</a>
--   <tt>m</tt>. This is the function that's used to exercise the actual
--   stateful implementation, usually through various side-effects as
--   permitted by <tt>m</tt>. It produces a value of type <tt>a</tt>, eg.
--   some observable output from the <a>Action</a> that should later be
--   kept in the environment through a `Var a` also passed to the
--   <a>nextState</a> function.
--   
--   The <tt>Lookup</tt> parameter provides an <i>environment</i> to lookup
--   `Var a` instances from previous steps.
perform :: RunModel state m => ModelState state -> Action state -> (forall t. HasSymbolicRep t => Symbolic t -> t) -> RunMonad m ()

-- | Allows the user to attach information to the <a>Property</a> at each
--   step of the process. This function is given the full transition that's
--   been executed, including the start and ending <a>state</a>, the
--   <a>Action</a>, the current environment to <tt>Lookup</tt> and the
--   value produced by <a>perform</a> while executing this step.
monitoring :: RunModel state m => (ModelState state, ModelState state) -> Action state -> (forall t. HasSymbolicRep t => Symbolic t -> t) -> SymIndex -> Property -> Property
class (DefaultRealized m, HasChainIndex m, Monad m) => IsRunnable m
awaitSlot :: IsRunnable m => SlotNo -> m ()
type DefaultRealized m = (Realized m SymIndex ~ SymIndex, Realized m () ~ ())
newtype RunMonad m a
RunMonad :: WriterT SymIndex m a -> RunMonad m a
[unRunMonad] :: RunMonad m a -> WriterT SymIndex m a
data Actions s
data Act s
Bind :: Var SymIndex -> Action s -> Act s
[varOf] :: Act s -> Var SymIndex
[actionOf] :: Act s -> Action s
NoBind :: Var SymIndex -> Action s -> Act s
[varOf] :: Act s -> Var SymIndex
[actionOf] :: Act s -> Action s
ActWaitUntil :: Var () -> SlotNo -> Act s
ActObservation :: Var () -> String -> (SymbolicSemantics -> ChainState -> Bool) -> Act s
pattern Actions :: [Act s] -> Actions s
ContractAction :: Bool -> Action state -> Action (ModelState state) SymIndex
WaitUntil :: SlotNo -> Action (ModelState state) ()
stateAfter :: ContractModel state => Actions state -> ModelState state
runContractModel :: (ContractModel state, RunModel state m, HasChainIndex m) => Actions state -> PropertyM (RunMonad m) (ContractModelResult state)
liftRunMonad :: (forall a. m a -> n a) -> RunMonad m a -> RunMonad n a

-- | Lens for the contract-specific part of the model state.
contractState :: forall state_aTto state_aU16. Lens (ModelState state_aTto) (ModelState state_aU16) state_aTto state_aU16
registerSymbolic :: (Monad m, HasSymbolicRep t) => String -> t -> RunMonad m ()
registerToken :: Monad m => String -> AssetId -> RunMonad m ()
registerTxOut :: Monad m => String -> TxOut CtxUTxO Era -> RunMonad m ()
registerTxIn :: Monad m => String -> TxIn -> RunMonad m ()
class HasChainIndex m
getChainIndex :: HasChainIndex m => m ChainIndex
getChainState :: HasChainIndex m => m ChainState
data ChainIndex
ChainIndex :: [TxInState] -> NetworkId -> ChainIndex
[transactions] :: ChainIndex -> [TxInState]
[networkId] :: ChainIndex -> NetworkId
data ChainState
ChainState :: SlotNo -> UTxO Era -> ChainState
[slot] :: ChainState -> SlotNo
[utxo] :: ChainState -> UTxO Era
data TxInState
TxInState :: Tx Era -> ChainState -> Bool -> TxInState
[tx] :: TxInState -> Tx Era
[chainState] :: TxInState -> ChainState
[accepted] :: TxInState -> Bool
type Era = BabbageEra
data Symbolic t

-- | A symbolic token is a token that is only available at runtime
type SymToken = Symbolic AssetId

-- | A SymTxOut is a `TxOut CtxUTxO Era` that is only available at runtime
type SymTxOut = Symbolic (TxOut CtxUTxO Era)

-- | A SymTxIn is a <a>TxIn</a> that is only available at runtime
type SymTxIn = Symbolic TxIn

-- | A symbolic value is a combination of a real value and a value
--   associating symbolic tokens with an amount
data SymValue

-- | Check if a symbolic value is zero
symIsZero :: SymValue -> Bool

-- | Check if one symbolic value is less than or equal to another
symLeq :: SymValue -> SymValue -> Bool

-- | Using a semantics function for symbolic tokens, convert a SymValue to
--   a Value
toValue :: (SymToken -> AssetId) -> SymValue -> Value

-- | Invert a sym token mapping to turn a Value into a SymValue, useful for
--   error reporting
toSymVal :: (AssetId -> Maybe SymToken) -> Value -> SymValue
inv :: SymValue -> SymValue
class SymValueLike v
toSymValue :: SymValueLike v => v -> SymValue
class TokenLike t

-- | Get the value of a specific token in a <a>SymValue</a>
symAssetIdValueOf :: TokenLike t => SymValue -> t -> Quantity

-- | Convert a token and an amount to a <a>SymValue</a>
symAssetIdValue :: TokenLike t => t -> Quantity -> SymValue
class HasSymbolics a
getAllSymbolics :: HasSymbolics a => a -> SymCollectionIndex
getAllSymbolics :: (HasSymbolics a, Generic a, GenericHasSymbolics (Rep a)) => a -> SymCollectionIndex
class HasSymbolicRep t
data BalanceChangeOptions
BalanceChangeOptions :: Bool -> FeeCalculation -> ProtocolParameters -> (AddressInEra Era -> String) -> BalanceChangeOptions
[observeScriptValue] :: BalanceChangeOptions -> Bool
[feeCalucation] :: BalanceChangeOptions -> FeeCalculation
[protocolParameters] :: BalanceChangeOptions -> ProtocolParameters
[addressPrettyPrinter] :: BalanceChangeOptions -> AddressInEra Era -> String
assertBalanceChangesMatch :: BalanceChangeOptions -> ContractModelResult state -> Property
signerPaysFees :: FeeCalculation
asserts :: ModelState state -> Property

-- | The <a>ModelState</a> models the state of the blockchain. It contains,
--   
--   <ul>
--   <li>the contract-specific state (<a>contractState</a>)</li>
--   <li>the current slot (<a>currentSlot</a>)</li>
--   <li>the wallet balances (<tt>balances</tt>)</li>
--   <li>the amount that has been minted (<a>minted</a>)</li>
--   </ul>
data ModelState state

-- | The <a>Spec</a> monad is a state monad over the <a>ModelState</a> with
--   reader and writer components to keep track of newly created symbolic
--   tokens. It is used exclusively by the <a>nextState</a> function to
--   model the effects of an action on the blockchain.
newtype Spec state a
Spec :: WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a -> Spec state a
[unSpec] :: Spec state a -> WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a

-- | Monads with read access to the model state: the <a>Spec</a> monad used
--   in <a>nextState</a>, and the <tt>DL</tt> monad used to construct test
--   scenarios.
class Monad m => GetModelState m where {
    
    -- | The contract state type of the monad. For both <a>Spec</a> and
    --   <tt>DL</tt> this is simply the <tt>state</tt> parameter of the
    --   respective monad.
    type family StateType m :: *;
}

-- | Get the current model state.
getModelState :: GetModelState m => m (ModelState (StateType m))
runSpec :: Spec state () -> Var SymIndex -> ModelState state -> ModelState state

-- | Get the current slot.
--   
--   <a>Spec</a> monad update functions: <tt>wait</tt> and
--   <tt>waitUntil</tt>.
currentSlot :: Getter (ModelState state) SlotNo

-- | Get the current wallet balance changes. These are delta balances, so
--   they start out at zero and can be negative. The absolute balances used
--   by the emulator can be set in the <tt>CheckOptions</tt> argument to
--   <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChanges :: Getter (ModelState state) (Map (AddressInEra Era) SymValue)

-- | Get the current balance change for a wallet. This is the delta
--   balance, so it starts out at zero and can be negative. The absolute
--   balance used by the emulator can be set in the <tt>CheckOptions</tt>
--   argument to <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChange :: Ord (AddressInEra Era) => AddressInEra Era -> Getter (ModelState state) SymValue

-- | Get the amount of tokens minted so far. This is used to compute
--   <a>lockedValue</a>.
--   
--   <a>Spec</a> monad update functions: <a>mint</a> and <a>burn</a>.
minted :: Getter (ModelState state) SymValue

-- | How much value is currently locked by contracts. This computed by
--   subtracting the wallet <tt>balances</tt> from the <a>minted</a> value.
lockedValue :: ModelState s -> SymValue

-- | Get the contract state part of the model state.
getContractState :: GetModelState m => m (StateType m)

-- | Get a component of the model state.
askModelState :: GetModelState m => (ModelState (StateType m) -> a) -> m a

-- | Get a component of the contract state.
askContractState :: GetModelState m => (StateType m -> a) -> m a

-- | Get a component of the model state using a lens.
viewModelState :: GetModelState m => Getting a (ModelState (StateType m)) a -> m a

-- | Get a component of the contract state using a lens.
viewContractState :: GetModelState m => Getting a (StateType m) a -> m a
createSymbolic :: forall t state. HasSymbolicRep t => String -> Spec state (Symbolic t)

-- | Create a new symbolic token in <a>nextState</a> - must have a
--   corresponding <tt>registerToken</tt> call in <a>perform</a>
createToken :: String -> Spec state SymToken

-- | Create a new symbolic TxOut in <a>nextState</a> - must have a
--   corresponding <tt>registerTxOut</tt> call in <a>perform</a>
createTxOut :: String -> Spec state SymTxOut

-- | Create a new symbolic TxIn in <a>nextState</a> - must have a
--   corresponding <tt>registerTxIn</tt> call in <a>perform</a>
createTxIn :: String -> Spec state SymTxIn

-- | Mint tokens. Minted tokens start out as <a>lockedValue</a> (i.e. owned
--   by the contract) and can be transferred to wallets using
--   <a>deposit</a>.
mint :: SymValueLike v => v -> Spec state ()

-- | Burn tokens. Equivalent to <tt><a>mint</a> . <a>inv</a></tt>.
burn :: SymValueLike v => v -> Spec state ()

-- | Add tokens to the <a>balanceChange</a> of an address. The added tokens
--   are subtracted from the <a>lockedValue</a> of tokens held by
--   contracts.
deposit :: SymValueLike v => AddressInEra Era -> v -> Spec state ()

-- | Withdraw tokens from an address. The withdrawn tokens are added to the
--   <a>lockedValue</a> of tokens held by contracts.
withdraw :: SymValueLike v => AddressInEra Era -> v -> Spec state ()

-- | Transfer tokens between wallets, updating their <tt>balances</tt>.
transfer :: SymValueLike v => AddressInEra Era -> AddressInEra Era -> v -> Spec state ()

-- | Wait until the given slot. Has no effect if <a>currentSlot</a> is
--   greater than the given slot.
waitUntil :: ContractModel state => SlotNo -> Spec state ()

-- | Wait the given number of slots. Updates the <a>currentSlot</a> of the
--   model state.
wait :: ContractModel state => Integer -> Spec state ()

-- | Assert that a particular predicate holds at a point in the
--   specification
assertSpec :: String -> Bool -> Spec state ()
coerceSpec :: forall s s' a. Coercible s s' => Spec s a -> Spec s' a
fromStateModelActions :: Actions (ModelState s) -> Actions s

module Test.QuickCheck.ContractModel.ThreatModel.Cardano.Api
addressOfTxOut :: TxOut ctx Era -> AddressAny
valueOfTxOut :: TxOut ctx Era -> Value

-- | Get the datum from a transaction output.
datumOfTxOut :: TxOut ctx Era -> TxOutDatum ctx Era
redeemerOfTxIn :: Tx Era -> TxIn -> Maybe ScriptData
paymentCredentialToAddressAny :: PaymentCredential -> AddressAny

-- | Construct a script address.
scriptAddressAny :: ScriptHash -> AddressAny

-- | Construct a public key address.
keyAddressAny :: Hash PaymentKey -> AddressAny

-- | Check if an address is a public key address.
isKeyAddressAny :: AddressAny -> Bool
recomputeScriptData :: Maybe Word64 -> (Word64 -> Word64) -> TxBodyScriptData Era -> TxBodyScriptData Era
emptyTxBodyScriptData :: TxBodyScriptData Era
addScriptData :: Word64 -> Data (ShelleyLedgerEra Era) -> (Data (ShelleyLedgerEra Era), ExUnits) -> TxBodyScriptData Era -> TxBodyScriptData Era
addDatum :: Data (ShelleyLedgerEra Era) -> TxBodyScriptData Era -> TxBodyScriptData Era
toCtxUTxODatum :: TxOutDatum CtxTx Era -> TxOutDatum CtxUTxO Era

-- | Convert ScriptData to a <a>Datum</a>.
txOutDatum :: ScriptData -> TxOutDatum CtxTx Era

-- | Convert a Haskell value to ScriptData for use as a <a>Redeemer</a> or
--   convert to a <a>Datum</a> with <a>txOutDatum</a>.
toScriptData :: ToData a => a -> ScriptData

-- | Used for new inputs.
dummyTxId :: TxId
makeTxOut :: AddressAny -> Value -> TxOutDatum CtxTx Era -> ReferenceScript Era -> TxOut CtxUTxO Era
txSigners :: Tx Era -> [Hash PaymentKey]
txInputs :: Tx Era -> [TxIn]
txOutputs :: Tx Era -> [TxOut CtxTx Era]

-- | Check if a value is less or equal than another value.
leqValue :: Value -> Value -> Bool

-- | Keep only the Ada part of a value.
projectAda :: Value -> Value

-- | The result of validating a transaction. In case of failure, it
--   includes a list of reasons.
data ValidityReport
ValidityReport :: Bool -> [String] -> ValidityReport
[valid] :: ValidityReport -> Bool
[errors] :: ValidityReport -> [String]
validateTx :: ProtocolParameters -> Tx Era -> UTxO Era -> ValidityReport

-- | Keep only UTxOs mentioned in the given transaction.
restrictUTxO :: Tx Era -> UTxO Era -> UTxO Era
convValidityInterval :: (TxValidityLowerBound era, TxValidityUpperBound era) -> ValidityInterval
instance GHC.Show.Show Test.QuickCheck.ContractModel.ThreatModel.Cardano.Api.ValidityReport
instance GHC.Classes.Eq Test.QuickCheck.ContractModel.ThreatModel.Cardano.Api.ValidityReport
instance GHC.Classes.Ord Test.QuickCheck.ContractModel.ThreatModel.Cardano.Api.ValidityReport

module Test.QuickCheck.ContractModel.ThreatModel.TxModifier

-- | A transaction output paired with its index in the transaction.
data Output
Output :: TxOut CtxTx Era -> TxIx -> Output
[outputTxOut] :: Output -> TxOut CtxTx Era
[outputIx] :: Output -> TxIx

-- | A transaction input reference togheter with the corresponding
--   <a>TxOut</a> from the <a>UTxO</a> set.
data Input
Input :: TxOut CtxUTxO Era -> TxIn -> Input
[inputTxOut] :: Input -> TxOut CtxUTxO Era
[inputTxIn] :: Input -> TxIn

-- | Functions common to both <a>Input</a>s and <a>Output</a>s.
class IsInputOrOutput t

-- | Change the target address of an input or an output. For outputs this
--   means redirecting an output to a different address, and for inputs it
--   means modifying the UTxO set, changing the owner of the given input.
--   
--   <i>Note: Does not work for script inputs.</i>
changeAddressOf :: IsInputOrOutput t => t -> AddressAny -> TxModifier

-- | Change the value of an input or an output.
changeValueOf :: IsInputOrOutput t => t -> Value -> TxModifier

-- | Change the datum on an input or an output.
changeDatumOf :: IsInputOrOutput t => t -> Datum -> TxModifier

-- | Get the address (pubkey or script address) of an input or an output.
addressOf :: IsInputOrOutput t => t -> AddressAny

-- | Get the value at an input or an output.
valueOf :: IsInputOrOutput t => t -> Value

-- | Type synonym for datums. The <a>CtxTx</a> context means that the
--   actual datum value can be present, not just the hash.
type Datum = TxOutDatum CtxTx Era

-- | Redeemers are plain <a>ScriptData</a>.
type Redeemer = ScriptData

-- | The type of transaction modifiers. When combined using the monoid
--   instance, individual modifications are applied in left-to-right order.
newtype TxModifier
TxModifier :: [TxMod] -> TxModifier
data TxMod
[RemoveInput] :: TxIn -> TxMod
[RemoveOutput] :: TxIx -> TxMod
[ChangeOutput] :: TxIx -> Maybe AddressAny -> Maybe Value -> Maybe Datum -> TxMod
[ChangeInput] :: TxIn -> Maybe AddressAny -> Maybe Value -> Maybe Datum -> TxMod
[ChangeScriptInput] :: TxIn -> Maybe Value -> Maybe Datum -> Maybe Redeemer -> TxMod
[ChangeValidityRange] :: Maybe (TxValidityLowerBound Era) -> Maybe (TxValidityUpperBound Era) -> TxMod
[AddOutput] :: AddressAny -> Value -> Datum -> TxMod
[AddInput] :: AddressAny -> Value -> Datum -> TxMod
[AddPlutusScriptInput] :: PlutusScript PlutusScriptV2 -> Value -> Datum -> Redeemer -> TxMod
[AddSimpleScriptInput] :: SimpleScript SimpleScriptV2 -> Value -> TxMod
[ReplaceTx] :: Tx Era -> UTxO Era -> TxMod
txMod :: TxMod -> TxModifier
applyTxModifier :: Tx Era -> UTxO Era -> TxModifier -> (Tx Era, UTxO Era)
applyTxMod :: Tx Era -> UTxO Era -> TxMod -> (Tx Era, UTxO Era)

-- | Add a new output of any type (public key or script)
addOutput :: AddressAny -> Value -> Datum -> TxModifier

-- | Remove an output of any type.
removeOutput :: Output -> TxModifier

-- | Add a new public key input.
addKeyInput :: AddressAny -> Value -> Datum -> TxModifier

-- | Remove an input of any type.
removeInput :: Input -> TxModifier

-- | Add a plutus script input.
addPlutusScriptInput :: PlutusScript PlutusScriptV2 -> Value -> Datum -> Redeemer -> TxModifier

-- | Add a simple script input.
addSimpleScriptInput :: SimpleScript SimpleScriptV2 -> Value -> TxModifier

-- | Change the redeemer of a script input.
changeRedeemerOf :: Input -> Redeemer -> TxModifier

-- | Change the validity range of the transaction.
changeValidityRange :: (TxValidityLowerBound Era, TxValidityUpperBound Era) -> TxModifier

-- | Change the validity lower bound of the transaction.
changeValidityLowerBound :: TxValidityLowerBound Era -> TxModifier

-- | Change the validity upper bound of the transaction.
changeValidityUpperBound :: TxValidityUpperBound Era -> TxModifier

-- | The most general transaction modifier. Simply replace the original
--   transaction and <a>UTxO</a> set by the given values. In most cases the
--   modifiers above should be sufficient.
replaceTx :: Tx Era -> UTxO Era -> TxModifier
instance GHC.Show.Show Test.QuickCheck.ContractModel.ThreatModel.TxModifier.Output
instance GHC.Show.Show Test.QuickCheck.ContractModel.ThreatModel.TxModifier.Input
instance GHC.Show.Show Test.QuickCheck.ContractModel.ThreatModel.TxModifier.TxMod
instance GHC.Base.Monoid Test.QuickCheck.ContractModel.ThreatModel.TxModifier.TxModifier
instance GHC.Base.Semigroup Test.QuickCheck.ContractModel.ThreatModel.TxModifier.TxModifier
instance Test.QuickCheck.ContractModel.ThreatModel.TxModifier.IsInputOrOutput Test.QuickCheck.ContractModel.ThreatModel.TxModifier.Output
instance Test.QuickCheck.ContractModel.ThreatModel.TxModifier.IsInputOrOutput Test.QuickCheck.ContractModel.ThreatModel.TxModifier.Input

module Test.QuickCheck.ContractModel.ThreatModel.Pretty

-- | Format a list of strings as a paragraph. The structure of the list is
--   not considered other than inserting whitespace between consecutive
--   elements. Use with <a>counterexampleTM</a> when printing longer texts.
paragraph :: [String] -> String
block :: Doc -> [Doc] -> Doc
fblock :: Doc -> [Doc] -> Doc
hblock :: Doc -> [Doc] -> Doc
hblock' :: Int -> Doc -> [Doc] -> Doc
pList :: [Doc] -> Doc
pSet :: [Doc] -> Doc
pArgs :: [Doc] -> Doc
(<:>) :: Doc -> Doc -> Doc
infixr 6 <:>
prettyInput :: Input -> Doc
prettyOutput :: Output -> Doc
prettyUTxO :: UTxO Era -> Doc
prettyIn :: TxIn -> Doc
prettyTxOut :: TxOut CtxUTxO Era -> Doc
prettyTxOutTx :: TxOut CtxTx Era -> Doc
prettyAddress :: AddressAny -> Doc
prettyIx :: TxIx -> Doc
prettyValue :: Value -> Doc
prettyAssetId :: AssetId -> Doc
prettyHash :: Show a => a -> Doc
prettyDatum :: Datum -> Doc
prettyTx :: Tx Era -> Doc
prettyRedeemer :: [TxIn] -> [PolicyId] -> RdmrPtr -> (Data era, ExUnits) -> Doc
prettyDatumMap :: TxBodyScriptData Era -> Doc
prettyMinting :: TxMintValue build Era -> Doc
prettyValidity :: (TxValidityLowerBound Era, TxValidityUpperBound Era) -> Doc
prettyLowerBound :: TxValidityLowerBound Era -> Doc
prettyUpperBound :: TxValidityUpperBound Era -> Doc
prettyTxModifier :: TxModifier -> Doc
prettyScriptData :: ScriptData -> Doc
prettyBytes :: Bool -> ByteString -> Doc


-- | The threat modelling framework allows you to write down and test
--   properties of modifications of valid transactions.
--   
--   A threat model is represented by a value in the <a>ThreatModel</a>
--   monad, and is evaluated in the context of a single valid transaction
--   and the chain state at the point it validated (a
--   <a>ThreatModelEnv</a>). Transactions and chain states can most easily
--   be obtained using a <a>ContractModelResult</a> from
--   <a>runContractModel</a>, but they can in principle come from anywhere.
--   
--   As an example, here is a <a>ThreatModel</a> that checks that any
--   interaction with <tt>myScript</tt> requires <tt>theToken</tt> to be
--   present:
--   
--   <pre>
--   tokenThreatModel :: <a>ThreatModel</a> ()
--   tokenThreatModel = do
--     <a>ensureHasInputAt</a> myScript
--   
--     let hasToken out = theToken <a>`leqValue`</a> <a>valueOf</a> out
--     i &lt;- <a>anyInputSuchThat</a>  hasToken
--     o &lt;- <a>anyOutputSuchThat</a> hasToken
--   
--     <a>shouldNotValidate</a> $ <a>changeValueOf</a> i (<a>valueOf</a> i &lt;&gt; negateValue theToken)
--                      &lt;&gt; <a>changeValueOf</a> o (<a>valueOf</a> o &lt;&gt; negateValue theToken)
--   </pre>
--   
--   For a more complex example see
--   <a>Test.QuickCheck.ContractModel.ThreatModel.DoubleSatisfaction</a>.
module Test.QuickCheck.ContractModel.ThreatModel

-- | The type of transaction modifiers. When combined using the monoid
--   instance, individual modifications are applied in left-to-right order.
data TxModifier

-- | A transaction input reference togheter with the corresponding
--   <a>TxOut</a> from the <a>UTxO</a> set.
data Input
Input :: TxOut CtxUTxO Era -> TxIn -> Input
[inputTxOut] :: Input -> TxOut CtxUTxO Era
[inputTxIn] :: Input -> TxIn

-- | A transaction output paired with its index in the transaction.
data Output
Output :: TxOut CtxTx Era -> TxIx -> Output
[outputTxOut] :: Output -> TxOut CtxTx Era
[outputIx] :: Output -> TxIx

-- | Type synonym for datums. The <a>CtxTx</a> context means that the
--   actual datum value can be present, not just the hash.
type Datum = TxOutDatum CtxTx Era

-- | Redeemers are plain <a>ScriptData</a>.
type Redeemer = ScriptData

-- | Functions common to both <a>Input</a>s and <a>Output</a>s.
class IsInputOrOutput t

-- | Change the target address of an input or an output. For outputs this
--   means redirecting an output to a different address, and for inputs it
--   means modifying the UTxO set, changing the owner of the given input.
--   
--   <i>Note: Does not work for script inputs.</i>
changeAddressOf :: IsInputOrOutput t => t -> AddressAny -> TxModifier

-- | Change the value of an input or an output.
changeValueOf :: IsInputOrOutput t => t -> Value -> TxModifier

-- | Change the datum on an input or an output.
changeDatumOf :: IsInputOrOutput t => t -> Datum -> TxModifier

-- | Get the address (pubkey or script address) of an input or an output.
addressOf :: IsInputOrOutput t => t -> AddressAny

-- | Get the value at an input or an output.
valueOf :: IsInputOrOutput t => t -> Value

-- | Add a new output of any type (public key or script)
addOutput :: AddressAny -> Value -> Datum -> TxModifier

-- | Remove an output of any type.
removeOutput :: Output -> TxModifier

-- | Add a new public key input.
addKeyInput :: AddressAny -> Value -> Datum -> TxModifier

-- | Add a plutus script input.
addPlutusScriptInput :: PlutusScript PlutusScriptV2 -> Value -> Datum -> Redeemer -> TxModifier

-- | Add a simple script input.
addSimpleScriptInput :: SimpleScript SimpleScriptV2 -> Value -> TxModifier

-- | Remove an input of any type.
removeInput :: Input -> TxModifier

-- | Change the redeemer of a script input.
changeRedeemerOf :: Input -> Redeemer -> TxModifier

-- | Change the validity range of the transaction.
changeValidityRange :: (TxValidityLowerBound Era, TxValidityUpperBound Era) -> TxModifier

-- | Change the validity lower bound of the transaction.
changeValidityLowerBound :: TxValidityLowerBound Era -> TxModifier

-- | Change the validity upper bound of the transaction.
changeValidityUpperBound :: TxValidityUpperBound Era -> TxModifier

-- | The most general transaction modifier. Simply replace the original
--   transaction and <a>UTxO</a> set by the given values. In most cases the
--   modifiers above should be sufficient.
replaceTx :: Tx Era -> UTxO Era -> TxModifier

-- | The threat model monad is how you construct threat models. It works in
--   the context of a given transaction and the UTxO set at the point where
--   the transaction was validated (see <a>ThreatModelEnv</a>) and lets you
--   construct properties about the validatity of modifications of the
--   original transaction.
data ThreatModel a

-- | The context in which a <a>ThreatModel</a> is executed. Contains a
--   transaction, its UTxO set and the protocol parameters. See
--   <a>getThreatModelEnv</a> and <a>originalTx</a> to access this
--   information in a threat model.
data ThreatModelEnv
ThreatModelEnv :: Tx Era -> UTxO Era -> ProtocolParameters -> ThreatModelEnv
[currentTx] :: ThreatModelEnv -> Tx Era
[currentUTxOs] :: ThreatModelEnv -> UTxO Era
[pparams] :: ThreatModelEnv -> ProtocolParameters

-- | Evaluate a <a>ThreatModel</a> on a list of transactions with their
--   context. Fails the property if the threat model fails on any of the
--   transactions.
runThreatModel :: ThreatModel a -> [ThreatModelEnv] -> Property

-- | Evaluate a <a>ThreatModel</a> on the result of running a
--   <a>ContractModel</a> test (see <a>runContractModel</a>). Checks the
--   threat model on all transactions produced by the test.
assertThreatModel :: ThreatModel a -> ProtocolParameters -> ContractModelResult state -> Property

-- | Check a precondition. If the argument threat model fails, the
--   evaluation of the current transaction is skipped. If all transactions
--   in an evaluation of <a>runThreatModel</a> are skipped it is considered
--   a <i>discarded</i> test for QuickCheck.
--   
--   Having the argument to <a>threatPrecondition</a> be a threat model
--   computation instead of a plain boolean allows you do express
--   preconditions talking about the validation of modified transactions
--   (using <a>shouldValidate</a> and <a>shouldNotValidate</a>). See
--   <a>ensure</a> for the boolean version.
threatPrecondition :: ThreatModel a -> ThreatModel a

-- | Returns <tt>True</tt> if evaluated under a <a>threatPrecondition</a>
--   and <tt>False</tt> otherwise.
inPrecondition :: ThreatModel Bool

-- | Same as <a>threatPrecondition</a> but takes a boolean and skips the
--   test if the argument is <tt>False</tt>.
ensure :: Bool -> ThreatModel ()

-- | Precondition that check that the original transaction has an input at
--   a given address. Useful, for example, to ensure that you only consider
--   transactions that trie to spend a script output from the script under
--   test.
ensureHasInputAt :: AddressAny -> ThreatModel ()

-- | Check that a given modification of the original transaction validates.
--   The modified transaction is printed in counterexample when this fails,
--   or if it succeeds in a precondition and the test fails later.
shouldValidate :: TxModifier -> ThreatModel ()

-- | Check that a given modification of the original transaction does not
--   validate. The modified transaction is printed in counterexample when
--   it does validate, or if it doesn't in a satisfied precondition and the
--   test fails later.
shouldNotValidate :: TxModifier -> ThreatModel ()

-- | The result of validating a transaction. In case of failure, it
--   includes a list of reasons.
data ValidityReport
ValidityReport :: Bool -> [String] -> ValidityReport
[valid] :: ValidityReport -> Bool
[errors] :: ValidityReport -> [String]

-- | The most low-level way to validate a modified transaction. In most
--   cases <a>shouldValidate</a> and <a>shouldNotValidate</a> are
--   preferred.
validate :: TxModifier -> ThreatModel ValidityReport

-- | Get the current context.
getThreatModelEnv :: ThreatModel ThreatModelEnv

-- | Get the original transaction from the context.
originalTx :: ThreatModel (Tx Era)

-- | Get the inputs from the original transaction.
getTxInputs :: ThreatModel [Input]

-- | Get the outputs from the original transaction.
getTxOutputs :: ThreatModel [Output]

-- | Get the redeemer (if any) for an input of the original transaction.
getRedeemer :: Input -> ThreatModel (Maybe Redeemer)

-- | Generate a random value. Takes a QuickCheck generator and a
--   <a>shrink</a> function.
forAllTM :: Show a => Gen a -> (a -> [a]) -> ThreatModel a

-- | Pick a random value from a list. Skips the test if the list is empty.
pickAny :: Show a => [a] -> ThreatModel a

-- | Pick a random signer of the original transaction.
anySigner :: ThreatModel (Hash PaymentKey)

-- | Pick a random input satisfying the given predicate.
anyInputSuchThat :: (Input -> Bool) -> ThreatModel Input

-- | Pick a random output satisfying the given predicate.
anyOutputSuchThat :: (Output -> Bool) -> ThreatModel Output

-- | Print the given string in case this threat model fails. Threat model
--   counterpart of the QuickCheck <a>counterexample</a> function.
counterexampleTM :: String -> ThreatModel ()

-- | Threat model counterpart of QuickCheck's <a>tabulate</a> function.
tabulateTM :: String -> [String] -> ThreatModel ()

-- | Threat model counterpart of QuickCheck's <a>collect</a> function.
collectTM :: Show a => a -> ThreatModel ()

-- | Threat model counterpart of QuickCheck's <a>classify</a> function.
classifyTM :: Bool -> String -> ThreatModel ()

-- | Monitoring that's shared between all transactions evaulated. Avoid
--   this in favour of <a>tabulateTM</a>, <a>collectTM</a> and
--   <a>classifyTM</a> when possible.
monitorThreatModel :: (Property -> Property) -> ThreatModel ()

-- | Monitoring that's local to the current transaction. Use
--   <a>counterexampleTM</a> when possible.
monitorLocalThreatModel :: (Property -> Property) -> ThreatModel ()

-- | Keep only the Ada part of a value.
projectAda :: Value -> Value

-- | Check if a value is less or equal than another value.
leqValue :: Value -> Value -> Bool

-- | Construct a public key address.
keyAddressAny :: Hash PaymentKey -> AddressAny

-- | Construct a script address.
scriptAddressAny :: ScriptHash -> AddressAny

-- | Check if an address is a public key address.
isKeyAddressAny :: AddressAny -> Bool

-- | Convert ScriptData to a <a>Datum</a>.
txOutDatum :: ScriptData -> TxOutDatum CtxTx Era

-- | Convert a Haskell value to ScriptData for use as a <a>Redeemer</a> or
--   convert to a <a>Datum</a> with <a>txOutDatum</a>.
toScriptData :: ToData a => a -> ScriptData

-- | Get the datum from a transaction output.
datumOfTxOut :: TxOut ctx Era -> TxOutDatum ctx Era

-- | Format a list of strings as a paragraph. The structure of the list is
--   not considered other than inserting whitespace between consecutive
--   elements. Use with <a>counterexampleTM</a> when printing longer texts.
paragraph :: [String] -> String
prettyAddress :: AddressAny -> Doc
prettyValue :: Value -> Doc
prettyDatum :: Datum -> Doc
prettyInput :: Input -> Doc
prettyOutput :: Output -> Doc
instance GHC.Show.Show Test.QuickCheck.ContractModel.ThreatModel.ThreatModelEnv
instance GHC.Base.Functor Test.QuickCheck.ContractModel.ThreatModel.ThreatModel
instance GHC.Base.Applicative Test.QuickCheck.ContractModel.ThreatModel.ThreatModel
instance GHC.Base.Monad Test.QuickCheck.ContractModel.ThreatModel.ThreatModel
instance Control.Monad.Fail.MonadFail Test.QuickCheck.ContractModel.ThreatModel.ThreatModel

module Test.QuickCheck.ContractModel.ThreatModel.DoubleSatisfaction

-- | Check for double satisfaction vulnerabilities.
--   
--   For a transaction with a public key output to an address (the victim)
--   other than the signer (the attacker),
--   
--   <ul>
--   <li>if you cannot redirect (the Ada from) the victim to the attacker,
--   i.e. there is a script that care about the output to the victim,</li>
--   <li>but it validates when you bundle the redirected transaction with a
--   "safe script" that spends the same amount to the victim, tagging the
--   output with a unique datum,</li>
--   </ul>
--   
--   then we have found a double satisfaction vulnerability in the script
--   that stopped the first modified transaction.
doubleSatisfaction :: ThreatModel ()
