-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Wallet API
--   
--   Plutus ledger library
@package plutus-ledger
@version 1.2.0.0


-- | Encoding and decoding of <tt>ByteString</tt> and serialisable values
--   as base16 encoded JSON strings
module Data.Aeson.Extras
encodeByteString :: ByteString -> Text
decodeByteString :: Value -> Parser ByteString
encodeSerialise :: Serialise a => a -> Text
decodeSerialise :: Serialise a => Value -> Parser a
tryDecode :: Text -> Either String ByteString

-- | Newtype for deriving <tt>ToJSON</tt> and <tt>FromJSON</tt> for types
--   that have a <a>Serialise</a> instance by just encoding the serialized
--   bytes as a JSON string.
newtype JSONViaSerialise a
JSONViaSerialise :: a -> JSONViaSerialise a
instance Codec.Serialise.Class.Serialise a => Data.Aeson.Types.ToJSON.ToJSON (Data.Aeson.Extras.JSONViaSerialise a)
instance Codec.Serialise.Class.Serialise a => Data.Aeson.Types.FromJSON.FromJSON (Data.Aeson.Extras.JSONViaSerialise a)

module Data.Time.Units.Extra
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Units.Second
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Units.Second
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Units.Millisecond
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Units.Millisecond

module Ledger.Builtins.Orphans
instance GHC.Generics.Generic PlutusTx.Builtins.Internal.BuiltinData
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Data.Data
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Data.Data
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Builtins.Internal.BuiltinByteString
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Builtins.Internal.BuiltinData
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Builtins.Internal.BuiltinData
instance Codec.Serialise.Class.Serialise PlutusTx.Builtins.Internal.BuiltinData

module Ledger.Contexts.Orphans
instance GHC.Classes.Ord Plutus.V1.Ledger.Contexts.ScriptPurpose

module Ledger.Crypto.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Control.Newtype.Generics.Newtype Plutus.V1.Ledger.Crypto.PubKeyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Crypto.PubKeyHash

module Ledger.Scripts.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.DatumHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.RedeemerHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.MintingPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.StakeValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.ScriptHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.ScriptHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.ValidatorHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Context
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Context
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.StakeValidator
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.StakeValidator
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MintingPolicy
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MintingPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Redeemer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Datum
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Script

module Ledger.Scripts
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceedsHash :: WitCtx ctx -> BuiltinByteString
examplePlutusScriptAlwaysFailsHash :: WitCtx ctx -> BuiltinByteString
data WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake

module Ledger.Credential.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.Credential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.Credential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.StakingCredential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.StakingCredential

module Ledger.DCert.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.DCert.DCert
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.DCert.DCert
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.DCert.DCert

module Ledger.Address.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Address.Address
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Address.Address


-- | Slots and slot ranges.
module Ledger.Slot

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Interval a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.LowerBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.UpperBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Extended a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Slot.Slot
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Slot.Slot
instance Prettyprinter.Internal.Pretty Ledger.Slot.Slot
instance Data.Hashable.Class.Hashable Ledger.Slot.Slot
instance Codec.Serialise.Class.Serialise Ledger.Slot.Slot
instance GHC.Real.Integral Ledger.Slot.Slot
instance GHC.Real.Real Ledger.Slot.Slot
instance GHC.Enum.Enum Ledger.Slot.Slot
instance GHC.Num.Num Ledger.Slot.Slot
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Slot.Slot
instance PlutusTx.IsData.Class.FromData Ledger.Slot.Slot
instance PlutusTx.IsData.Class.ToData Ledger.Slot.Slot
instance PlutusTx.Enum.Enum Ledger.Slot.Slot
instance PlutusTx.Ord.Ord Ledger.Slot.Slot
instance PlutusTx.Eq.Eq Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveGroup Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveMonoid Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveSemigroup Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Slot.Slot
instance Data.Data.Data Ledger.Slot.Slot
instance GHC.Generics.Generic Ledger.Slot.Slot
instance GHC.Show.Show Ledger.Slot.Slot
instance GHC.Classes.Ord Ledger.Slot.Slot
instance GHC.Classes.Eq Ledger.Slot.Slot


-- | <i>Deprecated: Use Plutus.Script.Utils.V1.Typed.Scripts.Validators
--   instead</i>
module Ledger.Typed.Scripts.Validators


-- | Typed transaction inputs and outputs. This module defines typed
--   versions of various ledger types. The ultimate goal is to make sure
--   that the script types attached to inputs and outputs line up, to avoid
--   type errors at validation time.

-- | <i>Deprecated: Use Plutus.Script.Utils.V1.Typed.Scripts instead</i>
module Ledger.Typed.Tx


-- | <i>Deprecated: Use Plutus.Script.Utils.Typed instead</i>
module Ledger.Typed.TypeUtils


-- | Copied from plutus-ledger-api because not exported
module Prettyprinter.Extras

-- | Newtype wrapper for deriving <a>Pretty</a> via a <a>Show</a> instance
newtype PrettyShow a
PrettyShow :: a -> PrettyShow a
[unPrettyShow] :: PrettyShow a -> a
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | Newtype wrapper for deriving <a>Pretty</a> for a <a>Foldable</a>
--   container by calling <a>toList</a>.
newtype PrettyFoldable f a
PrettyFoldable :: f a -> PrettyFoldable f a
[unPrettyFoldable] :: PrettyFoldable f a -> f a
newtype Tagged (s :: k) b
Tagged :: b -> Tagged (s :: k) b
instance (Data.Foldable.Foldable f, Prettyprinter.Internal.Pretty a) => Prettyprinter.Internal.Pretty (Prettyprinter.Extras.PrettyFoldable f a)
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Prettyprinter.Extras.PrettyShow a)
instance (GHC.TypeLits.KnownSymbol a, Prettyprinter.Internal.Pretty b) => Prettyprinter.Internal.Pretty (Data.Tagged.Tagged a b)

module Ledger.Value.Orphans
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.CurrencySymbol
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.TokenName
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.AssetClass
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.AssetClass
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.Value
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.Value
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.Value
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.Value
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (PlutusTx.AssocMap.Map k v)
instance (Codec.Serialise.Class.Serialise k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (PlutusTx.AssocMap.Map k v)
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.Lovelace
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.Quantity
instance GHC.Generics.Generic Cardano.Api.Value.AssetId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Value.AssetId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Value.AssetId
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.AssetId
instance Prettyprinter.Internal.Pretty Cardano.Api.Value.AssetId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.TokenName
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON k) => Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.AssocMap.Map k v)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON k) => Data.Aeson.Types.FromJSON.FromJSON (PlutusTx.AssocMap.Map k v)
instance Prettyprinter.Internal.Pretty Cardano.Api.Value.Lovelace
instance Prettyprinter.Internal.Pretty Cardano.Api.Value.Value
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.Value
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.PolicyId
instance Codec.Serialise.Class.Serialise Cardano.Api.Value.AssetName

module Ledger.Tx.Orphans.V2
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V2.Ledger.Tx.OutputDatum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V2.Ledger.Tx.OutputDatum
instance Codec.Serialise.Class.Serialise Plutus.V2.Ledger.Tx.OutputDatum
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V2.Ledger.Tx.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V2.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V2.Ledger.Tx.TxOut

module Ledger.Tx.Orphans.V1
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.RedeemerPtr
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.RedeemerPtr
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.ScriptTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.ScriptTag
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.ScriptTag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.TxId
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Bytes.LedgerBytes

module Ledger.Crypto
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | A cryptographic private key.
newtype PrivateKey
PrivateKey :: LedgerBytes -> PrivateKey
[getPrivateKey] :: PrivateKey -> LedgerBytes

-- | A message with a cryptographic signature.
newtype Signature
Signature :: BuiltinByteString -> Signature
[getSignature] :: Signature -> BuiltinByteString

-- | Passphrase newtype to mark intent
newtype Passphrase
Passphrase :: ByteString -> Passphrase
[unPassphrase] :: Passphrase -> ByteString

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | Check whether the given <a>Signature</a> was signed by the private key
--   corresponding to the given public key.
signedBy :: ByteArrayAccess a => Signature -> PubKey -> a -> Bool

-- | Sign a message using a private key and passphrase.
sign :: ByteArrayAccess a => a -> XPrv -> Passphrase -> Signature

-- | Sign the hash of a transaction using a private key and passphrase.
signTx :: TxId -> XPrv -> Passphrase -> Signature

-- | Generate a private key from a seed phrase and passphrase
generateFromSeed :: ByteString -> Passphrase -> XPrv
toPublicKey :: XPrv -> PubKey
xPubToPublicKey :: XPub -> PubKey

-- | Sign a message using a private key with no passphrase.
sign' :: ByteArrayAccess a => a -> XPrv -> Signature

-- | Sign the hash of a transaction using a private key that has no
--   passphrase.
signTx' :: TxId -> XPrv -> Signature

-- | Generate a private key from a seed phrase without a passphrase.
generateFromSeed' :: ByteString -> XPrv
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PrivateKey
instance Data.Hashable.Class.Hashable Ledger.Crypto.PrivateKey
instance Prettyprinter.Internal.Pretty Ledger.Crypto.PrivateKey
instance GHC.Show.Show Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.PrivateKey
instance Codec.Serialise.Class.Serialise Ledger.Crypto.PrivateKey
instance PlutusTx.Ord.Ord Ledger.Crypto.PrivateKey
instance PlutusTx.Eq.Eq Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Crypto.PrivateKey
instance Control.Newtype.Generics.Newtype Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.PrivateKey
instance GHC.Generics.Generic Ledger.Crypto.PrivateKey
instance GHC.Classes.Ord Ledger.Crypto.PrivateKey
instance GHC.Classes.Eq Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Crypto.PubKey
instance Prettyprinter.Internal.Pretty Ledger.Crypto.PubKey
instance GHC.Show.Show Ledger.Crypto.PubKey
instance Data.String.IsString Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.PubKey
instance Codec.Serialise.Class.Serialise Ledger.Crypto.PubKey
instance PlutusTx.Ord.Ord Ledger.Crypto.PubKey
instance PlutusTx.Eq.Eq Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.PubKey
instance Control.Newtype.Generics.Newtype Ledger.Crypto.PubKey
instance GHC.Generics.Generic Ledger.Crypto.PubKey
instance GHC.Classes.Ord Ledger.Crypto.PubKey
instance GHC.Classes.Eq Ledger.Crypto.PubKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.Signature
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Crypto.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Crypto.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Crypto.Signature
instance Data.String.IsString Ledger.Crypto.Passphrase
instance Prettyprinter.Internal.Pretty Ledger.Crypto.Signature
instance GHC.Show.Show Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.FromData Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.ToData Ledger.Crypto.Signature
instance Codec.Serialise.Class.Serialise Ledger.Crypto.Signature
instance PlutusTx.Ord.Ord Ledger.Crypto.Signature
instance PlutusTx.Eq.Eq Ledger.Crypto.Signature
instance GHC.Generics.Generic Ledger.Crypto.Signature
instance GHC.Classes.Ord Ledger.Crypto.Signature
instance GHC.Classes.Eq Ledger.Crypto.Signature
instance GHC.Show.Show Ledger.Crypto.Passphrase

module Ledger.Orphans
instance Data.Data.Data Ouroboros.Network.Magic.NetworkMagic
instance Data.Data.Data Cardano.Api.NetworkId.NetworkId
instance GHC.Generics.Generic Cardano.Api.NetworkId.NetworkId
instance GHC.Generics.Generic Cardano.Api.Value.Lovelace
instance GHC.Generics.Generic Cardano.Api.Value.PolicyId
instance GHC.Generics.Generic Cardano.Api.Value.Quantity
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Time.POSIXTime
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Web.Internal.HttpApiData.ToHttpApiData Ledger.Crypto.PrivateKey
instance Web.Internal.HttpApiData.FromHttpApiData Ledger.Crypto.PrivateKey
instance Web.Internal.HttpApiData.ToHttpApiData Plutus.V1.Ledger.Bytes.LedgerBytes
instance Web.Internal.HttpApiData.FromHttpApiData Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Tx.TxId
instance Codec.Serialise.Class.Serialise (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Time.POSIXTime

module Ledger.Address
toPubKeyHash :: Address -> Maybe PubKeyHash
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential
scriptHashAddress :: ValidatorHash -> Address
stakingCredential :: Address -> Maybe StakingCredential
toValidatorHash :: Address -> Maybe ValidatorHash
type CardanoAddress = AddressInEra BabbageEra
newtype PaymentPrivateKey
PaymentPrivateKey :: XPrv -> PaymentPrivateKey
[unPaymentPrivateKey] :: PaymentPrivateKey -> XPrv
newtype PaymentPubKey
PaymentPubKey :: PubKey -> PaymentPubKey
[unPaymentPubKey] :: PaymentPubKey -> PubKey
newtype PaymentPubKeyHash
PaymentPubKeyHash :: PubKeyHash -> PaymentPubKeyHash
[unPaymentPubKeyHash] :: PaymentPubKeyHash -> PubKeyHash
newtype StakePubKey
StakePubKey :: PubKey -> StakePubKey
[unStakePubKey] :: StakePubKey -> PubKey
newtype StakePubKeyHash
StakePubKeyHash :: PubKeyHash -> StakePubKeyHash
[unStakePubKeyHash] :: StakePubKeyHash -> PubKeyHash
toPlutusAddress :: AddressInEra era -> Address
toPlutusPubKeyHash :: Hash PaymentKey -> PubKeyHash
cardanoAddressCredential :: AddressInEra era -> Credential
cardanoPubKeyHash :: AddressInEra era -> Maybe PubKeyHash
cardanoStakingCredential :: AddressInEra era -> Maybe StakingCredential
paymentPubKeyHash :: PaymentPubKey -> PaymentPubKeyHash

-- | The address that should be targeted by a transaction output locked by
--   the given public payment key (with its staking credentials).
pubKeyHashAddress :: PaymentPubKeyHash -> Maybe StakingCredential -> Address

-- | The address that should be targeted by a transaction output locked by
--   the given public key. (with its staking credentials).
pubKeyAddress :: PaymentPubKey -> Maybe StakingCredential -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script (with its staking credentials).
scriptValidatorHashAddress :: ValidatorHash -> Maybe StakingCredential -> Address

-- | Construct a <a>StakingCredential</a> from a public key hash.
stakePubKeyHashCredential :: StakePubKeyHash -> StakingCredential

-- | Construct a <a>StakingCredential</a> from a validator script hash.
stakeValidatorHashCredential :: StakeValidatorHash -> StakingCredential
xprvToPaymentPubKey :: XPrv -> PaymentPubKey
xprvToPaymentPubKeyHash :: XPrv -> PaymentPubKeyHash
xprvToStakingCredential :: XPrv -> StakingCredential
xprvToStakePubKey :: XPrv -> StakePubKey
xprvToStakePubKeyHash :: XPrv -> StakePubKeyHash

-- | Cardano address of a versioned <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Versioned Validator -> AddressInEra BabbageEra
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKeyHash
instance Prettyprinter.Internal.Pretty Ledger.Address.StakePubKeyHash
instance GHC.Show.Show Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.FromData Ledger.Address.StakePubKeyHash
instance PlutusTx.IsData.Class.ToData Ledger.Address.StakePubKeyHash
instance Data.Hashable.Class.Hashable Ledger.Address.StakePubKeyHash
instance Codec.Serialise.Class.Serialise Ledger.Address.StakePubKeyHash
instance PlutusTx.Ord.Ord Ledger.Address.StakePubKeyHash
instance PlutusTx.Eq.Eq Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.StakePubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.StakePubKeyHash
instance GHC.Generics.Generic Ledger.Address.StakePubKeyHash
instance GHC.Classes.Ord Ledger.Address.StakePubKeyHash
instance GHC.Classes.Eq Ledger.Address.StakePubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.StakePubKey
instance Prettyprinter.Internal.Pretty Ledger.Address.StakePubKey
instance GHC.Show.Show Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.FromData Ledger.Address.StakePubKey
instance PlutusTx.IsData.Class.ToData Ledger.Address.StakePubKey
instance Codec.Serialise.Class.Serialise Ledger.Address.StakePubKey
instance PlutusTx.Ord.Ord Ledger.Address.StakePubKey
instance PlutusTx.Eq.Eq Ledger.Address.StakePubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.StakePubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.StakePubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.StakePubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.StakePubKey
instance GHC.Generics.Generic Ledger.Address.StakePubKey
instance GHC.Classes.Ord Ledger.Address.StakePubKey
instance GHC.Classes.Eq Ledger.Address.StakePubKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKeyHash
instance Prettyprinter.Internal.Pretty Ledger.Address.PaymentPubKeyHash
instance GHC.Show.Show Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.FromData Ledger.Address.PaymentPubKeyHash
instance PlutusTx.IsData.Class.ToData Ledger.Address.PaymentPubKeyHash
instance Data.Hashable.Class.Hashable Ledger.Address.PaymentPubKeyHash
instance Codec.Serialise.Class.Serialise Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Ord.Ord Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Eq.Eq Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.PaymentPubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.PaymentPubKeyHash
instance GHC.Generics.Generic Ledger.Address.PaymentPubKeyHash
instance GHC.Classes.Ord Ledger.Address.PaymentPubKeyHash
instance GHC.Classes.Eq Ledger.Address.PaymentPubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Ledger.Address.PaymentPubKey
instance Prettyprinter.Internal.Pretty Ledger.Address.PaymentPubKey
instance GHC.Show.Show Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.UnsafeFromData Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.FromData Ledger.Address.PaymentPubKey
instance PlutusTx.IsData.Class.ToData Ledger.Address.PaymentPubKey
instance Codec.Serialise.Class.Serialise Ledger.Address.PaymentPubKey
instance PlutusTx.Ord.Ord Ledger.Address.PaymentPubKey
instance PlutusTx.Eq.Eq Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Address.PaymentPubKey
instance GHC.Generics.Generic Ledger.Address.PaymentPubKey
instance GHC.Classes.Ord Ledger.Address.PaymentPubKey
instance GHC.Classes.Eq Ledger.Address.PaymentPubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Api.Address.AddressInEra Cardano.Api.Eras.BabbageEra)


-- | Interface to the transaction types from 'cardano-api'
module Ledger.Tx.CardanoAPI.Internal
newtype CardanoBuildTx
CardanoBuildTx :: TxBodyContent BuildTx BabbageEra -> CardanoBuildTx
[getCardanoBuildTx] :: CardanoBuildTx -> TxBodyContent BuildTx BabbageEra

-- | Cardano tx from any era.
data CardanoTx
[CardanoTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> CardanoTx
getEmulatorEraTx :: CardanoTx -> Tx BabbageEra
pattern CardanoEmulatorEraTx :: Tx BabbageEra -> CardanoTx
txOutRefs :: CardanoTx -> [(TxOut, TxOutRef)]
unspentOutputsTx :: CardanoTx -> Map TxOutRef TxOut
fromCardanoTxId :: TxId -> TxId
fromCardanoTxIn :: TxIn -> TxOutRef
fromCardanoTxOutToPV1TxInfoTxOut :: TxOut CtxTx era -> TxOut
fromCardanoTxOutToPV1TxInfoTxOut' :: TxOut CtxUTxO era -> TxOut
fromCardanoTxOutToPV2TxInfoTxOut :: TxOut CtxTx era -> TxOut
fromCardanoTxOutToPV2TxInfoTxOut' :: TxOut CtxUTxO era -> TxOut
fromCardanoTxOutDatumHash :: TxOutDatum CtxTx era -> Maybe DatumHash
fromCardanoTxOutDatum :: TxOutDatum CtxTx era -> OutputDatum
fromCardanoTxOutValue :: TxOutValue era -> Value

-- | <i>Deprecated: we now use Cardano address internally, if you need a
--   plutus address use <a>toPlutusAddress</a> </i>
fromCardanoAddressInEra :: AddressInEra era -> Address

-- | <i>Deprecated: Shouldn't be used as we use Cardano address internally
--   now</i>
fromCardanoAddress :: Address addrtype -> Address
fromCardanoAssetId :: AssetId -> AssetClass
fromCardanoAssetName :: AssetName -> TokenName
fromCardanoMintValue :: TxMintValue build era -> Value
fromCardanoValue :: Value -> Value
fromCardanoPolicyId :: PolicyId -> MintingPolicyHash
fromCardanoFee :: TxFee era -> Lovelace
fromCardanoValidityRange :: (TxValidityLowerBound era, TxValidityUpperBound era) -> SlotRange
fromCardanoScriptInEra :: ScriptInEra era -> Maybe (Versioned Script)

-- | <i>Deprecated: Shouldn't be used as we use Cardano address internally
--   now</i>
fromCardanoPaymentKeyHash :: Hash PaymentKey -> PubKeyHash
fromCardanoScriptData :: ScriptData -> BuiltinData
fromCardanoPlutusScript :: HasTypeProxy lang => PlutusScript lang -> Script
fromCardanoScriptInAnyLang :: ScriptInAnyLang -> Maybe (Versioned Script)
fromCardanoReferenceScript :: ReferenceScript BabbageEra -> Maybe (Versioned Script)
fromCardanoLovelace :: Lovelace -> Value
fromCardanoSlotNo :: SlotNo -> Slot

-- | Given a 'C.TxScriptValidity era', if the <tt>era</tt> supports
--   scripts, return a <tt>True</tt> or <tt>False</tt> depending on script
--   validity. If the <tt>era</tt> does not support scripts, always return
--   <tt>True</tt>.
fromTxScriptValidity :: TxScriptValidity era -> Bool
toTxScriptValidity :: ShelleyBasedEra era -> Bool -> TxScriptValidity era

-- | Given a 'C.TxBody from a 'C.Tx era', return the datums and redeemers
--   along with their hashes.
scriptDataFromCardanoTxBody :: TxBody era -> (Map DatumHash Datum, Redeemers)

-- | Extract plutus scripts from a Cardano API tx body.
--   
--   Note that Plutus scripts are only supported in Alonzo era and onwards.
plutusScriptsFromTxBody :: TxBody era -> Map ScriptHash (Versioned Script)
makeTransactionBody :: Maybe (PParams (BabbageEra StandardCrypto)) -> Map RdmrPtr ExUnits -> CardanoBuildTx -> Either ToCardanoError (TxBody BabbageEra)
toCardanoTxIn :: TxOutRef -> Either ToCardanoError TxIn
toCardanoTxOut :: NetworkId -> TxOut -> Either ToCardanoError (TxOut CtxTx BabbageEra)
toCardanoTxOutDatum :: OutputDatum -> Either ToCardanoError (TxOutDatum CtxTx BabbageEra)
toCardanoTxOutDatumHash :: DatumHash -> Either ToCardanoError (TxOutDatum ctx BabbageEra)
toCardanoTxOutDatumHashFromDatum :: Datum -> TxOutDatum ctx BabbageEra
toCardanoTxOutDatumInline :: Datum -> TxOutDatum CtxTx BabbageEra
toCardanoTxOutDatumInTx :: Datum -> TxOutDatum CtxTx BabbageEra
toCardanoTxOutNoDatum :: TxOutDatum CtxTx BabbageEra
toCardanoTxOutValue :: Value -> TxOutValue BabbageEra
toCardanoAddressInEra :: NetworkId -> Address -> Either ToCardanoError (AddressInEra BabbageEra)
toCardanoAssetId :: AssetClass -> Either ToCardanoError AssetId
toCardanoAssetName :: TokenName -> Either ToCardanoError AssetName
toCardanoPolicyId :: MintingPolicyHash -> Either ToCardanoError PolicyId
toCardanoValue :: Value -> Either ToCardanoError Value
toCardanoLovelace :: Value -> Either ToCardanoError Lovelace
toCardanoFee :: Lovelace -> TxFee BabbageEra
adaToCardanoValue :: Ada -> Value
toCardanoValidityRange :: SlotRange -> Either ToCardanoError (TxValidityLowerBound BabbageEra, TxValidityUpperBound BabbageEra)
toCardanoScriptInEra :: Versioned Script -> Either ToCardanoError (ScriptInEra BabbageEra)
toCardanoPaymentKeyHash :: PaymentPubKeyHash -> Either ToCardanoError (Hash PaymentKey)
toCardanoScriptData :: BuiltinData -> ScriptData
toCardanoScriptDataHash :: DatumHash -> Either ToCardanoError (Hash ScriptData)
toCardanoScriptHash :: ValidatorHash -> Either ToCardanoError ScriptHash
toCardanoStakeKeyHash :: PubKeyHash -> Either ToCardanoError (Hash StakeKey)
toCardanoPlutusScript :: SerialiseAsRawBytes plutusScript => AsType plutusScript -> Script -> Either ToCardanoError plutusScript
toCardanoScriptInAnyLang :: Versioned Script -> Either ToCardanoError ScriptInAnyLang
toCardanoReferenceScript :: Maybe (Versioned Script) -> Either ToCardanoError (ReferenceScript BabbageEra)
toCardanoTxId :: TxId -> Either ToCardanoError TxId
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError
data FromCardanoError
SimpleScriptsNotSupported :: FromCardanoError
deserialiseFromRawBytes :: SerialiseAsRawBytes t => AsType t -> ByteString -> Either ToCardanoError t
zeroExecutionUnits :: ExecutionUnits
tag :: String -> Either ToCardanoError t -> Either ToCardanoError t

-- | Run code that needs an <tt>IsCardanoEra</tt> constraint while you only
--   have an <tt>EraInMode</tt> value.
withIsCardanoEra :: EraInMode era CardanoMode -> (IsCardanoEra era => r) -> r
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance GHC.Generics.Generic Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Cardano.BM.Data.Tracer.ToObject Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Generics.Generic Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Generics.Generic Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance GHC.Generics.Generic (Cardano.Api.Script.PlutusScriptOrReferenceInput lang)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.PlutusScriptOrReferenceInput Cardano.Api.Script.PlutusScriptV1)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.PlutusScriptOrReferenceInput Cardano.Api.Script.PlutusScriptV1)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.PlutusScriptOrReferenceInput Cardano.Api.Script.PlutusScriptV2)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.PlutusScriptOrReferenceInput Cardano.Api.Script.PlutusScriptV2)
instance Data.Aeson.Types.FromJSON.FromJSONKey Cardano.Api.Value.PolicyId
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Api.Value.PolicyId
instance GHC.Generics.Generic (Cardano.Api.TxBody.TxBodyContent Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxBodyContent Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxBodyContent Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance GHC.Show.Show Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.ToCardanoError
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.FromCardanoError
instance GHC.Classes.Eq Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Codec.Serialise.Class.Serialise Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxInsReference Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxInsReference Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxReturnCollateral ctx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxReturnCollateral Cardano.Api.TxBody.CtxTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxTotalCollateral Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxTotalCollateral Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxInsCollateral Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxInsCollateral Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON w => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.BuildTxWith Cardano.Api.TxBody.BuildTx w)
instance Data.Aeson.Types.FromJSON.FromJSON w => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.BuildTxWith Cardano.Api.TxBody.BuildTx w)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.PlutusScript Cardano.Api.Script.PlutusScriptV1)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.PlutusScript Cardano.Api.Script.PlutusScriptV2)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.PlutusScript Cardano.Api.Script.PlutusScriptV1)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.PlutusScript Cardano.Api.Script.PlutusScriptV2)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxTxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxMint)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxStake)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxTxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxMint)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptDatum Cardano.Api.Script.WitCtxStake)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.ScriptData.ScriptData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.ScriptData.ScriptData
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptDatum ctx) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptWitness ctx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptDatum ctx) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptWitness ctx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxTxIn Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxMint Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxStake Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxTxIn Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxMint Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.Witness Cardano.Api.Script.WitCtxStake Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxMintValue Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxMintValue Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxFee Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxFee Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxValidityLowerBound Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxValidityLowerBound Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxValidityUpperBound Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxValidityUpperBound Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxExtraKeyWitnesses Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxExtraKeyWitnesses Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxScriptValidity Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxScriptValidity Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxMetadataInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxMetadataInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Script.ScriptInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Script.ScriptInEra Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxAuxScripts Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxAuxScripts Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxWithdrawals Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxWithdrawals Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxCertificates Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxCertificates Cardano.Api.TxBody.BuildTx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.TxBody.TxUpdateProposal Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.TxBody.TxUpdateProposal Cardano.Api.Eras.BabbageEra)

module Ledger.Value.CardanoAPI
data Value
newtype Lovelace
Lovelace :: Integer -> Lovelace
data AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
data PolicyId
data AssetName
selectAsset :: Value -> AssetId -> Quantity
valueToList :: Value -> [(AssetId, Quantity)]
valueFromList :: [(AssetId, Quantity)] -> Value
selectLovelace :: Value -> Lovelace
filterValue :: (AssetId -> Bool) -> Value -> Value
negateValue :: Value -> Value
lovelaceToValue :: Lovelace -> Value
lovelaceValueOf :: Integer -> Value
adaValueOf :: Rational -> Value
isZero :: Value -> Bool
isAdaOnlyValue :: Value -> Bool
noAdaValue :: Value -> Value
adaOnlyValue :: Value -> Value
adaToCardanoValue :: Ada -> Value
singleton :: PolicyId -> AssetName -> Integer -> Value
assetIdValue :: AssetId -> Integer -> Value
scale :: Integer -> Value -> Value
split :: Value -> (Value, Value)
policyId :: Versioned MintingPolicy -> PolicyId
toCardanoValue :: Value -> Either ToCardanoError Value
fromCardanoValue :: Value -> Value
toCardanoAssetId :: AssetClass -> Either ToCardanoError AssetId
fromCardanoAssetId :: AssetId -> AssetClass
combine :: Monoid m => (AssetId -> Quantity -> Quantity -> m) -> Value -> Value -> m
valueGeq :: Value -> Value -> Bool
valueLeq :: Value -> Value -> Bool
instance PlutusTx.Lattice.JoinSemiLattice Cardano.Api.Value.Value

module Ledger.Tx.Orphans
instance GHC.Generics.Generic Cardano.Api.TxIn.TxIn
instance GHC.Generics.Generic Cardano.Api.TxIn.TxId
instance GHC.Generics.Generic Cardano.Api.TxIn.TxIx
instance Codec.Serialise.Class.Serialise Cardano.Api.TxIn.TxIn
instance Codec.Serialise.Class.Serialise Cardano.Api.TxIn.TxIx
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Tx.Tx Cardano.Api.Eras.BabbageEra)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Tx.Tx Cardano.Api.Eras.BabbageEra)
instance Prettyprinter.Internal.Pretty (Cardano.Api.TxBody.TxOutDatum ctx era) => Prettyprinter.Internal.Pretty (Cardano.Api.TxBody.TxOut ctx era)
instance Prettyprinter.Internal.Pretty (Cardano.Api.TxBody.TxOutDatum Cardano.Api.TxBody.CtxTx era)
instance Prettyprinter.Internal.Pretty (Cardano.Api.TxBody.TxOutDatum Cardano.Api.TxBody.CtxUTxO era)
instance Prettyprinter.Internal.Pretty Cardano.Api.TxIn.TxId
instance Codec.Serialise.Class.Serialise Cardano.Api.TxIn.TxId
instance Prettyprinter.Internal.Pretty Cardano.Api.TxIn.TxIn

module Ledger.Typed.Scripts.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Script.Utils.Typed.TypedValidator a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Script.Utils.Typed.TypedValidator a)
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError

module Ledger.Typed.Scripts
data Language
PlutusV1 :: Language
PlutusV2 :: Language
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash
generalise :: TypedValidator a -> TypedValidator Any
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy
vValidatorScript :: TypedValidator a -> Versioned Validator
validatorAddress :: TypedValidator a -> Address
validatorHash :: TypedValidator a -> ValidatorHash
validatorScript :: TypedValidator a -> Validator
class UnsafeFromData sc => IsScriptContext sc
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator
mkUntypedStakeValidator :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedStakeValidator
mkUntypedMintingPolicy :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedMintingPolicy
data TypedValidator a
TypedValidator :: Versioned Validator -> ValidatorHash -> Versioned MintingPolicy -> MintingPolicyHash -> TypedValidator a
[tvValidator] :: TypedValidator a -> Versioned Validator
[tvValidatorHash] :: TypedValidator a -> ValidatorHash
[tvForwardingMPS] :: TypedValidator a -> Versioned MintingPolicy
[tvForwardingMPSHash] :: TypedValidator a -> MintingPolicyHash
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()
class ValidatorTypes a where {
    type family RedeemerType a;
    type family DatumType a;
    type RedeemerType a = ();
    type DatumType a = ();
}
type family DatumType a
type family RedeemerType a
validatorCardanoAddress :: NetworkId -> TypedValidator a -> AddressInEra BabbageEra
validatorCardanoAddressAny :: NetworkId -> TypedValidator a -> AddressAny
data Any
type ScriptContextV1 = ScriptContext
type ScriptContextV2 = ScriptContext
type UntypedMintingPolicy = BuiltinData -> BuiltinData -> ()
type UntypedStakeValidator = BuiltinData -> BuiltinData -> ()
data MintingPolicy
data Validator
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError
mkForwardingMintingPolicy :: Versioned Validator -> Versioned MintingPolicy

-- | Make a <a>TypedValidator</a> (with no type constraints) from an
--   untyped <a>Validator</a> script.
unsafeMkTypedValidator :: Versioned Validator -> TypedValidator Any
type ValidatorType a = DatumType a -> RedeemerType a -> ScriptContext -> Bool
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

module Ledger.Tx.Internal
type ReferenceScript = ReferenceScript BabbageEra
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer
cardanoTxOutValue :: TxOut ctx era -> Value
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)
toCtxUTxOTxOut :: TxOut -> TxOut CtxUTxO BabbageEra

-- | Get a hash from the stored TxOutDatum (either directly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutDatum :: forall d. FromData d => TxOut -> Maybe d
cardanoTxOutDatumHash :: TxOutDatum CtxUTxO BabbageEra -> Maybe (Hash ScriptData)
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)
emptyTxBodyContent :: TxBodyContent BuildTx BabbageEra
data Language
PlutusV1 :: Language
PlutusV2 :: Language
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId
[txOutRefIdx] :: TxOutRef -> Integer
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.Withdrawal
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.Withdrawal
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.Withdrawal
instance GHC.Generics.Generic Ledger.Tx.Internal.Withdrawal
instance GHC.Classes.Eq Ledger.Tx.Internal.Withdrawal
instance GHC.Show.Show Ledger.Tx.Internal.Withdrawal
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.Certificate
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.Certificate
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.Certificate
instance GHC.Generics.Generic Ledger.Tx.Internal.Certificate
instance GHC.Classes.Eq Ledger.Tx.Internal.Certificate
instance GHC.Show.Show Ledger.Tx.Internal.Certificate
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.Internal.TxOut
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.Internal.TxOut
instance GHC.Generics.Generic Ledger.Tx.Internal.TxOut
instance GHC.Classes.Eq Ledger.Tx.Internal.TxOut
instance GHC.Show.Show Ledger.Tx.Internal.TxOut
instance Cardano.Binary.ToCBOR.ToCBOR Ledger.Tx.Internal.TxOut
instance Cardano.Binary.FromCBOR.FromCBOR Ledger.Tx.Internal.TxOut
instance Codec.Serialise.Class.Serialise Ledger.Tx.Internal.TxOut
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.Certificate
instance Prettyprinter.Internal.Pretty Ledger.Tx.Internal.Withdrawal

module Ledger.Index.Internal

-- | A transaction on the blockchain. Invalid transactions are still put on
--   the chain to be able to collect fees.
newtype OnChainTx
OnChainTx :: Validated (Tx EmulatorEra) -> OnChainTx
[getOnChainTx] :: OnChainTx -> Validated (Tx EmulatorEra)
eitherTx :: (CardanoTx -> r) -> (CardanoTx -> r) -> OnChainTx -> r
unOnChain :: OnChainTx -> CardanoTx
type EmulatorEra = BabbageEra StandardCrypto

-- | The UTxOs of a blockchain indexed by their references.
type UtxoIndex = UTxO BabbageEra

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxIn -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError

-- | Balancing failed, it needed more than the maximum number of collateral
--   inputs
MaxCollateralInputsExceeded :: ValidationError
_MaxCollateralInputsExceeded :: Prism' ValidationError ()
_CardanoLedgerValidationError :: Prism' ValidationError Text
_ScriptFailure :: Prism' ValidationError ScriptError
_TxOutRefNotFound :: Prism' ValidationError TxIn
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
type ValidationSuccess = (RedeemerReport, Validated (Tx EmulatorEra))
type RedeemerReport = Map RdmrPtr ([Text], ExUnits)
data ValidationResult

-- | A transaction failed to validate in phase 1.
FailPhase1 :: !CardanoTx -> !ValidationError -> ValidationResult

-- | A transaction failed to validate in phase 2. The <tt>Value</tt>
--   indicates the amount of collateral stored in the transaction.
FailPhase2 :: !OnChainTx -> !ValidationError -> !Value -> ValidationResult
Success :: !OnChainTx -> !RedeemerReport -> ValidationResult
_Success :: Prism' ValidationResult (OnChainTx, RedeemerReport)
_FailPhase2 :: Prism' ValidationResult (OnChainTx, ValidationError, Value)
_FailPhase1 :: Prism' ValidationResult (CardanoTx, ValidationError)
data ValidationResultSimple
ValidationFailPhase1 :: !CardanoTx -> !ValidationError -> ValidationResultSimple
ValidationFailPhase2 :: !CardanoTx -> !ValidationError -> !Value -> ValidationResultSimple
ValidationSuccess :: !CardanoTx -> ValidationResultSimple
toValidationResultSimple :: ValidationResult -> ValidationResultSimple
cardanoTxFromValidationResult :: ValidationResult -> CardanoTx
toOnChain :: ValidationResult -> Maybe OnChainTx

-- | Get logs from evaluating plutus scripts.
getEvaluationLogs :: ValidationResult -> [Text]
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationResultSimple
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationResultSimple
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationResultSimple
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationResult
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationResult
instance Prettyprinter.Internal.Pretty Ledger.Index.Internal.ValidationResult
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationPhase
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationPhase
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationPhase
instance GHC.Show.Show Ledger.Index.Internal.ValidationPhase
instance GHC.Classes.Eq Ledger.Index.Internal.ValidationPhase
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationResult
instance GHC.Show.Show Ledger.Index.Internal.ValidationResult
instance GHC.Classes.Eq Ledger.Index.Internal.ValidationResult
instance Prettyprinter.Internal.Pretty Ledger.Index.Internal.ValidationError
instance Prettyprinter.Internal.Pretty Ledger.Index.Internal.ValidationPhase
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.Internal.ValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.Internal.ValidationError
instance GHC.Generics.Generic Ledger.Index.Internal.OnChainTx
instance GHC.Show.Show Ledger.Index.Internal.OnChainTx
instance GHC.Classes.Eq Ledger.Index.Internal.OnChainTx
instance GHC.Generics.Generic Ledger.Index.Internal.ValidationError
instance GHC.Show.Show Ledger.Index.Internal.ValidationError
instance GHC.Classes.Eq Ledger.Index.Internal.ValidationError
instance GHC.Base.Semigroup (Cardano.Api.Query.UTxO era)
instance GHC.Base.Monoid (Cardano.Api.Query.UTxO era)
instance Codec.Serialise.Class.Serialise Ledger.Index.Internal.OnChainTx


-- | Interface to the transaction types from 'cardano-api'
module Ledger.Tx.CardanoAPI
newtype CardanoBuildTx
CardanoBuildTx :: TxBodyContent BuildTx BabbageEra -> CardanoBuildTx
[getCardanoBuildTx] :: CardanoBuildTx -> TxBodyContent BuildTx BabbageEra

-- | Cardano tx from any era.
data CardanoTx
[CardanoTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> CardanoTx
fromCardanoTxInsCollateral :: TxInsCollateral era -> [TxIn]
fromCardanoTotalCollateral :: TxTotalCollateral BabbageEra -> Maybe Lovelace
fromCardanoReturnCollateral :: TxReturnCollateral CtxTx BabbageEra -> Maybe TxOut
toCardanoTotalCollateral :: Maybe Lovelace -> TxTotalCollateral BabbageEra
toCardanoReturnCollateral :: Maybe TxOut -> TxReturnCollateral CtxTx BabbageEra
toCardanoDatumWitness :: Maybe Datum -> ScriptDatum WitCtxTxIn
toCardanoTxInReferenceWitnessHeader :: Versioned TxOutRef -> Either ToCardanoError WitnessHeader
toCardanoTxInScriptWitnessHeader :: Versioned Script -> Either ToCardanoError WitnessHeader
toCardanoMintWitness :: Redeemer -> Maybe (Versioned TxOutRef) -> Maybe (Versioned MintingPolicy) -> Either ToCardanoError (ScriptWitness WitCtxMint BabbageEra)
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError
data FromCardanoError
SimpleScriptsNotSupported :: FromCardanoError
getRequiredSigners :: Tx BabbageEra -> [PaymentPubKeyHash]
fromPlutusIndex :: UtxoIndex -> UTxO (BabbageEra StandardCrypto)
fromPlutusTxOut :: TxOut -> TxOut (BabbageEra StandardCrypto)
fromPlutusTxOutRef :: TxOutRef -> Either ToCardanoError (TxIn StandardCrypto)

module Ledger.Tx
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId
[txOutRefIdx] :: TxOutRef -> Integer
inScripts :: TxIn -> Maybe (Validator, Redeemer, Datum)
isPayToScriptOut :: TxOut -> Bool
isPubKeyOut :: TxOut -> Bool
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
pubKeyTxIns :: Fold (Set TxIn) TxIn
scriptTxIns :: Fold (Set TxIn) TxIn
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag
data Language
PlutusV1 :: Language
PlutusV2 :: Language
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
type ReferenceScript = ReferenceScript BabbageEra
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer
cardanoTxOutValue :: TxOut ctx era -> Value
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)
toCtxUTxOTxOut :: TxOut -> TxOut CtxUTxO BabbageEra

-- | Get a hash from the stored TxOutDatum (either directly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutDatum :: forall d. FromData d => TxOut -> Maybe d
cardanoTxOutDatumHash :: TxOutDatum CtxUTxO BabbageEra -> Maybe (Hash ScriptData)
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)
emptyTxBodyContent :: TxBodyContent BuildTx BabbageEra
newtype TxId
TxId :: Hash StandardCrypto EraIndependentTxBody -> TxId
data TxIn
TxIn :: TxId -> TxIx -> TxIn
newtype TxIx
TxIx :: Word -> TxIx

-- | Offchain view of a transaction output.
data DecoratedTxOut
PublicKeyDecoratedTxOut :: PubKeyHash -> Maybe StakingCredential -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut

-- | The pubKey hash that protects the transaction address
[_decoratedTxOutPubKeyHash] :: DecoratedTxOut -> PubKeyHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Optional datum (inline datum or datum in transaction body) attached to
--   the transaction output.
[_decoratedTxOutPubKeyDatum] :: DecoratedTxOut -> Maybe (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)
ScriptDecoratedTxOut :: ValidatorHash -> Maybe StakingCredential -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> DecoratedTxOut

-- | The hash of the script that protects the transaction address
[_decoratedTxOutValidatorHash] :: DecoratedTxOut -> ValidatorHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Datum attached to the transaction output, either in full (inline datum
--   or datum in transaction body) or as a hash reference. A transaction
--   output protected by a Plutus script is guardateed to have an
--   associated datum.
[_decoratedTxOutScriptDatum] :: DecoratedTxOut -> (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)

-- | Full version of the validator protecting the transaction output
[_decoratedTxOutValidator] :: DecoratedTxOut -> Maybe (Versioned Validator)
toTxOut :: NetworkId -> DecoratedTxOut -> Either ToCardanoError TxOut

-- | Converts a transaction output from the chain index to the
--   plutus-ledger-api transaction output.
--   
--   Note that <a>DecoratedTxOut</a> supports features such inline datums
--   and reference scripts which are not supported by V1 TxOut. Converting
--   from <a>DecoratedTxOut</a> to <a>TxOut</a> and back is therefore
--   lossy.
toTxInfoTxOut :: DecoratedTxOut -> TxOut
toDecoratedTxOut :: TxOut -> Maybe DecoratedTxOut
decoratedTxOutPubKeyHash :: Traversal' DecoratedTxOut PubKeyHash
decoratedTxOutAddress :: Getter DecoratedTxOut Address
decoratedTxOutDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutValue :: Lens' DecoratedTxOut Value
decoratedTxOutPubKeyDatum :: Traversal' DecoratedTxOut (Maybe (DatumHash, DatumFromQuery))
decoratedTxOutScriptDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutStakingCredential :: Lens' DecoratedTxOut (Maybe StakingCredential)
decoratedTxOutReferenceScript :: Lens' DecoratedTxOut (Maybe (Versioned Script))
decoratedTxOutValidatorHash :: Traversal' DecoratedTxOut ValidatorHash
decoratedTxOutValidator :: Traversal' DecoratedTxOut (Maybe (Versioned Validator))
_PublicKeyDecoratedTxOut :: Prism' DecoratedTxOut (PubKeyHash, Maybe StakingCredential, Value, Maybe (DatumHash, DatumFromQuery), Maybe (Versioned Script))
_ScriptDecoratedTxOut :: Prism' DecoratedTxOut (ValidatorHash, Maybe StakingCredential, Value, (DatumHash, DatumFromQuery), Maybe (Versioned Script), Maybe (Versioned Validator))
_decoratedTxOutAddress :: DecoratedTxOut -> Address
mkDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkPubkeyDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkScriptDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> Maybe DecoratedTxOut

-- | A datum in a transaction output that comes from a chain index query.
data DatumFromQuery
DatumUnknown :: DatumFromQuery
DatumInline :: Datum -> DatumFromQuery
DatumInBody :: Datum -> DatumFromQuery
datumInDatumFromQuery :: Traversal' DatumFromQuery Datum
getCardanoTxId :: CardanoTx -> TxId
getCardanoTxInputs :: CardanoTx -> [TxIn]
getCardanoTxCollateralInputs :: CardanoTx -> [TxIn]
getCardanoTxOutRefs :: CardanoTx -> [(TxOut, TxIn)]
getCardanoTxOutputs :: CardanoTx -> [TxOut]
getCardanoTxRedeemers :: CardanoTx -> Redeemers
getCardanoTxSpentOutputs :: CardanoTx -> Set TxIn
getCardanoTxProducedOutputs :: CardanoTx -> Map TxIn TxOut
getCardanoTxReturnCollateral :: CardanoTx -> Maybe TxOut
getCardanoTxProducedReturnCollateral :: CardanoTx -> Map TxIn TxOut
getCardanoTxTotalCollateral :: CardanoTx -> Maybe Lovelace
getCardanoTxFee :: CardanoTx -> Lovelace
getCardanoTxMint :: CardanoTx -> Value
getCardanoTxValidityRange :: CardanoTx -> SlotRange
getCardanoTxData :: CardanoTx -> Map DatumHash Datum

-- | Cardano tx from any era.
data CardanoTx
[CardanoTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> CardanoTx
pattern CardanoEmulatorEraTx :: Tx BabbageEra -> CardanoTx
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError
addCardanoTxSignature :: PrivateKey -> CardanoTx -> CardanoTx
getTxBodyContentInputs :: TxBodyContent ctx era -> [TxIn]
getTxBodyContentCollateralInputs :: TxBodyContent ctx era -> [TxIn]
getTxBodyContentReturnCollateral :: TxBodyContent ctx BabbageEra -> Maybe TxOut
getTxBodyContentMint :: TxBodyContent ctx era -> Value
txBodyContentIns :: Lens' (TxBodyContent BuildTx BabbageEra) [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn BabbageEra))]
txBodyContentCollateralIns :: Lens' (TxBodyContent BuildTx BabbageEra) [TxIn]
txBodyContentOuts :: Lens' (TxBodyContent ctx BabbageEra) [TxOut]
decoratedTxOutPlutusValue :: DecoratedTxOut -> Value
fromDecoratedIndex :: NetworkId -> Map TxOutRef DecoratedTxOut -> Either ToCardanoError UtxoIndex
instance Prettyprinter.Internal.Pretty Ledger.Tx.DecoratedTxOut
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.CardanoTx
instance Prettyprinter.Internal.Pretty Ledger.Tx.CardanoAPI.Internal.CardanoBuildTx
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.DecoratedTxOut
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.DecoratedTxOut
instance GHC.Generics.Generic Ledger.Tx.DecoratedTxOut
instance Codec.Serialise.Class.Serialise Ledger.Tx.DecoratedTxOut
instance GHC.Classes.Eq Ledger.Tx.DecoratedTxOut
instance GHC.Show.Show Ledger.Tx.DecoratedTxOut
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Tx.DatumFromQuery
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Tx.DatumFromQuery
instance GHC.Generics.Generic Ledger.Tx.DatumFromQuery
instance Codec.Serialise.Class.Serialise Ledger.Tx.DatumFromQuery
instance GHC.Classes.Eq Ledger.Tx.DatumFromQuery
instance GHC.Show.Show Ledger.Tx.DatumFromQuery

module Ledger.Blockchain

-- | A transaction on the blockchain. Invalid transactions are still put on
--   the chain to be able to collect fees.
newtype OnChainTx
OnChainTx :: Validated (Tx EmulatorEra) -> OnChainTx
[getOnChainTx] :: OnChainTx -> Validated (Tx EmulatorEra)

-- | A block on the blockchain. This is just a list of transactions
--   following on from the chain so far.
type Block = [OnChainTx]

-- | Block identifier (usually a hash)
newtype BlockId
BlockId :: ByteString -> BlockId
[getBlockId] :: BlockId -> ByteString

-- | A blockchain, which is just a list of blocks, starting with the
--   newest.
type Blockchain = [Block]
newtype Context
Context :: BuiltinData -> Context
eitherTx :: (CardanoTx -> r) -> (CardanoTx -> r) -> OnChainTx -> r
unOnChain :: OnChainTx -> CardanoTx
onChainTxIsValid :: OnChainTx -> Bool

-- | Outputs consumed from the UTXO set by the <a>OnChainTx</a>
consumableInputs :: OnChainTx -> [TxIn]

-- | Outputs added to the UTXO set by the <a>OnChainTx</a>
outputsProduced :: OnChainTx -> Map TxIn TxOut
instance GHC.Generics.Generic Ledger.Blockchain.BlockId
instance GHC.Classes.Ord Ledger.Blockchain.BlockId
instance GHC.Classes.Eq Ledger.Blockchain.BlockId
instance GHC.Show.Show Ledger.Blockchain.BlockId
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Blockchain.BlockId
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Blockchain.BlockId
instance Prettyprinter.Internal.Pretty Ledger.Blockchain.BlockId


-- | An index of unspent transaction outputs, and some functions for
--   validating transactions using the index.
module Ledger.Index

-- | The UTxOs of a blockchain indexed by their references.
type UtxoIndex = UTxO BabbageEra

-- | Update the index for the addition of a transaction.
insert :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of only the collateral inputs of a
--   failed transaction.
insertCollateral :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of a block.
insertBlock :: Block -> UtxoIndex -> UtxoIndex

-- | Create an index of all UTxOs on the chain.
initialise :: Blockchain -> UtxoIndex

-- | Find an unspent transaction output by the <tt>TxOutRef</tt> that
--   spends it.
lookup :: TxIn -> UtxoIndex -> Maybe TxOut
getCollateral :: UtxoIndex -> CardanoTx -> Value

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxIn -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError

-- | Balancing failed, it needed more than the maximum number of collateral
--   inputs
MaxCollateralInputsExceeded :: ValidationError
_TxOutRefNotFound :: Prism' ValidationError TxIn
_ScriptFailure :: Prism' ValidationError ScriptError
_CardanoLedgerValidationError :: Prism' ValidationError Text
data ValidationResult

-- | A transaction failed to validate in phase 1.
FailPhase1 :: !CardanoTx -> !ValidationError -> ValidationResult

-- | A transaction failed to validate in phase 2. The <tt>Value</tt>
--   indicates the amount of collateral stored in the transaction.
FailPhase2 :: !OnChainTx -> !ValidationError -> !Value -> ValidationResult
Success :: !OnChainTx -> !RedeemerReport -> ValidationResult
_Success :: Prism' ValidationResult (OnChainTx, RedeemerReport)
_FailPhase1 :: Prism' ValidationResult (CardanoTx, ValidationError)
_FailPhase2 :: Prism' ValidationResult (OnChainTx, ValidationError, Value)
cardanoTxFromValidationResult :: ValidationResult -> CardanoTx
toOnChain :: ValidationResult -> Maybe OnChainTx

-- | Get logs from evaluating plutus scripts.
getEvaluationLogs :: ValidationResult -> [Text]
type ValidationSuccess = (RedeemerReport, Validated (Tx EmulatorEra))
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase
type RedeemerReport = Map RdmrPtr ([Text], ExUnits)

-- | TODO Should be calculated based on the maximum script size permitted
--   on the Cardano blockchain.
maxFee :: Ada

-- | Adjust a single transaction output so it contains at least the minimum
--   amount of Ada and return the adjustment (if any) and the updated
--   TxOut.
adjustTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> ([Lovelace], TxOut)

-- | Exact computation of the mimimum Ada required for a given TxOut. TODO:
--   Should be moved to cardano-api-extended once created
minAdaTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Lovelace

-- | Provide a reasonable estimate of the mimimum of Ada required for a
--   TxOut.
--   
--   An exact estimate of the the mimimum of Ada in a TxOut is determined
--   by two things: - the <tt>PParams</tt>, more precisely its
--   <tt>coinPerUTxOWord</tt> parameter. - the size of the <a>TxOut</a>. In
--   many situations though, we need to determine a plausible value for the
--   minimum of Ada needed for a TxOut without knowing much of the
--   <a>TxOut</a>. This function provides a value big enough to balance
--   UTxOs without a large inlined data (larger than a hash) nor a complex
--   val with a lot of minted values. It's superior to the lowest minimum
--   needed for an UTxO, as the lowest value require no datum. An estimate
--   of the minimum required Ada for each tx output.
minAdaTxOutEstimated :: Ada
minLovelaceTxOutEstimated :: Lovelace
maxMinAdaTxOut :: Ada
createGenesisTransaction :: Map CardanoAddress Value -> CardanoTx

-- | cardano-ledger validation rules require the presence of inputs and we
--   have to provide a stub TxIn for the genesis transaction.
genesisTxIn :: TxIn
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data SatInt


-- | <a>AddressMap</a>s and functions for working on them.
--   
--   <a>AddressMap</a>s are used to represent the limited knowledge about
--   the state of the ledger that the wallet retains. Rather than keeping
--   the entire ledger (which can be very large) the wallet only tracks the
--   UTxOs at particular addresses.
module Ledger.AddressMap

-- | A map of <tt>Address</tt>es and their unspent outputs.
newtype AddressMap
AddressMap :: Map CardanoAddress UtxoMap -> AddressMap
[getAddressMap] :: AddressMap -> Map CardanoAddress UtxoMap
type UtxoMap = Map TxIn (CardanoTx, TxOut)

-- | Add an address with no unspent outputs to a map. If the address
--   already exists, do nothing.
addAddress :: CardanoAddress -> AddressMap -> AddressMap

-- | Add a list of <tt>Address</tt>es with no unspent outputs to the map.
addAddresses :: [CardanoAddress] -> AddressMap -> AddressMap

-- | Get the funds available at a particular address.
fundsAt :: CardanoAddress -> Lens' AddressMap UtxoMap

-- | The total value of unspent outputs (which the map knows about) at an
--   address.
values :: AddressMap -> Map CardanoAddress Value

-- | Walk through the address map, applying an effectful function to each
--   entry.
traverseWithKey :: Applicative f => (CardanoAddress -> Map TxIn (CardanoTx, TxOut) -> f (Map TxIn (CardanoTx, TxOut))) -> AddressMap -> f AddressMap

-- | An address map with a single unspent transaction output.
singleton :: (CardanoAddress, TxIn, CardanoTx, TxOut) -> AddressMap

-- | Update an <a>AddressMap</a> with the inputs and outputs of a new
--   transaction. <tt>updateAddresses</tt> does <i>not</i> add or remove
--   any keys from the map.
updateAddresses :: OnChainTx -> AddressMap -> AddressMap

-- | Update an <a>AddressMap</a> with the inputs and outputs of a new
--   transaction, including all addresses in the transaction.
updateAllAddresses :: OnChainTx -> AddressMap -> AddressMap

-- | Determine the unspent output that an input refers to
lookupOutRef :: TxIn -> AddressMap -> Maybe TxOut

-- | The unspent transaction outputs of the ledger as a whole.
fromChain :: Blockchain -> AddressMap
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.AddressMap.AddressMap
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.AddressMap.AddressMap
instance Codec.Serialise.Class.Serialise Ledger.AddressMap.AddressMap
instance GHC.Generics.Generic Ledger.AddressMap.AddressMap
instance GHC.Classes.Eq Ledger.AddressMap.AddressMap
instance GHC.Show.Show Ledger.AddressMap.AddressMap
instance GHC.Base.Semigroup Ledger.AddressMap.AddressMap
instance GHC.Base.Monoid Ledger.AddressMap.AddressMap
instance Control.Lens.At.Ixed Ledger.AddressMap.AddressMap
instance Control.Lens.At.At Ledger.AddressMap.AddressMap

module Ledger
data SatInt
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[exBudgetCPU] :: ExBudget -> ExCPU
[exBudgetMemory] :: ExBudget -> ExMemory
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU
findContinuingOutputs :: ScriptContext -> [Integer]
findDatum :: DatumHash -> TxInfo -> Maybe Datum
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findOwnInput :: ScriptContext -> Maybe TxInInfo
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo
fromSymbol :: CurrencySymbol -> ValidatorHash
getContinuingOutputs :: ScriptContext -> [TxOut]
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
ownHash :: ScriptContext -> ValidatorHash
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)
pubKeyOutput :: TxOut -> Maybe PubKeyHash
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]
spendsOutput :: TxInfo -> TxId -> Integer -> Bool
txSignedBy :: TxInfo -> PubKeyHash -> Bool
valueLockedBy :: TxInfo -> ValidatorHash -> Value
valuePaidTo :: TxInfo -> PubKeyHash -> Value
valueProduced :: TxInfo -> Value
valueSpent :: TxInfo -> Value
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Value
[txInfoMint] :: TxInfo -> Value
[txInfoDCert] :: TxInfo -> [DCert]
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]
[txInfoId] :: TxInfo -> TxId
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId
[txOutRefIdx] :: TxOutRef -> Integer
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString
newtype DatumHash
DatumHash :: BuiltinByteString -> DatumHash
newtype Datum
Datum :: BuiltinData -> Datum
[getDatum] :: Datum -> BuiltinData
type POSIXTimeRange = Interval POSIXTime
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a
newtype ValidatorHash
ValidatorHash :: BuiltinByteString -> ValidatorHash
toPubKeyHash :: Address -> Maybe PubKeyHash
newtype MintingPolicyHash
MintingPolicyHash :: BuiltinByteString -> MintingPolicyHash
inScripts :: TxIn -> Maybe (Validator, Redeemer, Datum)
isPayToScriptOut :: TxOut -> Bool
isPubKeyOut :: TxOut -> Bool
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut
pubKeyTxIns :: Fold (Set TxIn) TxIn
scriptTxIns :: Fold (Set TxIn) TxIn
data RedeemerPtr
RedeemerPtr :: ScriptTag -> Integer -> RedeemerPtr
type Redeemers = Map RedeemerPtr Redeemer
data ScriptTag
Spend :: ScriptTag
Mint :: ScriptTag
Cert :: ScriptTag
Reward :: ScriptTag
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script
newtype Redeemer
Redeemer :: BuiltinData -> Redeemer
[getRedeemer] :: Redeemer -> BuiltinData
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential
applyArguments :: Script -> [Data] -> Script
applyMintingPolicyScript :: Context -> MintingPolicy -> Redeemer -> Script
applyStakeValidatorScript :: Context -> StakeValidator -> Redeemer -> Script
applyValidator :: Context -> Validator -> Datum -> Redeemer -> Script
evaluateScript :: MonadError ScriptError m => Script -> m (ExBudget, [Text])
fromCompiledCode :: CompiledCode a -> Script
mkMintingPolicyScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> MintingPolicy
mkStakeValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> ()) -> StakeValidator
mkValidatorScript :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ()) -> Validator
runMintingPolicyScript :: MonadError ScriptError m => Context -> MintingPolicy -> Redeemer -> m (ExBudget, [Text])
runScript :: MonadError ScriptError m => Context -> Validator -> Datum -> Redeemer -> m (ExBudget, [Text])
runStakeValidatorScript :: MonadError ScriptError m => Context -> StakeValidator -> Redeemer -> m (ExBudget, [Text])
scriptSize :: Script -> Integer
unMintingPolicyScript :: MintingPolicy -> Script
unStakeValidatorScript :: StakeValidator -> Script
unValidatorScript :: Validator -> Script
unitDatum :: Datum
unitRedeemer :: Redeemer
newtype Context
Context :: BuiltinData -> Context
newtype MintingPolicy
MintingPolicy :: Script -> MintingPolicy
[getMintingPolicy] :: MintingPolicy -> Script
newtype RedeemerHash
RedeemerHash :: BuiltinByteString -> RedeemerHash
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[unScript] :: Script -> Program DeBruijn DefaultUni DefaultFun ()
data ScriptError
EvaluationError :: [Text] -> String -> ScriptError
EvaluationException :: String -> String -> ScriptError
newtype ScriptHash
ScriptHash :: BuiltinByteString -> ScriptHash
[getScriptHash] :: ScriptHash -> BuiltinByteString
newtype StakeValidator
StakeValidator :: Script -> StakeValidator
[getStakeValidator] :: StakeValidator -> Script
newtype StakeValidatorHash
StakeValidatorHash :: BuiltinByteString -> StakeValidatorHash
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
filterValue :: (AssetId -> Bool) -> Value -> Value
negateValue :: Value -> Value
selectAsset :: Value -> AssetId -> Quantity
selectLovelace :: Value -> Lovelace
valueFromList :: [(AssetId, Quantity)] -> Value
valueToList :: Value -> [(AssetId, Quantity)]
data WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
newtype TxId
TxId :: Hash StandardCrypto EraIndependentTxBody -> TxId
data TxIn
TxIn :: TxId -> TxIx -> TxIn
newtype TxIx
TxIx :: Word -> TxIx
data AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
data AssetName
newtype Lovelace
Lovelace :: Integer -> Lovelace
data PolicyId
data Value
dataHash :: BuiltinData -> BuiltinByteString
datumHash :: Datum -> DatumHash
mintingPolicyHash :: Versioned MintingPolicy -> MintingPolicyHash
redeemerHash :: Redeemer -> RedeemerHash
scriptCurrencySymbol :: Versioned MintingPolicy -> CurrencySymbol
scriptHash :: Versioned Script -> ScriptHash
stakeValidatorHash :: Versioned StakeValidator -> StakeValidatorHash
validatorHash :: Versioned Validator -> ValidatorHash
data Language
PlutusV1 :: Language
PlutusV2 :: Language
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
to :: a -> Interval a
from :: a -> Interval a
always :: Interval a
scriptHashAddress :: ValidatorHash -> Address
stakingCredential :: Address -> Maybe StakingCredential
toValidatorHash :: Address -> Maybe ValidatorHash
after :: Ord a => a -> Interval a -> Bool
before :: Ord a => a -> Interval a -> Bool
contains :: Ord a => Interval a -> Interval a -> Bool
hull :: Ord a => Interval a -> Interval a -> Interval a
intersection :: Ord a => Interval a -> Interval a -> Interval a
interval :: a -> a -> Interval a
isEmpty :: (Enum a, Ord a) => Interval a -> Bool
lowerBound :: a -> LowerBound a
member :: Ord a => a -> Interval a -> Bool
never :: Interval a
overlaps :: (Enum a, Ord a) => Interval a -> Interval a -> Bool
singleton :: a -> Interval a
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a
upperBound :: a -> UpperBound a
type Closure = Bool
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a
fromMilliSeconds :: DiffMilliSeconds -> POSIXTime
newtype DiffMilliSeconds
DiffMilliSeconds :: Integer -> DiffMilliSeconds
examplePlutusScriptAlwaysSucceedsHash :: WitCtx ctx -> BuiltinByteString
examplePlutusScriptAlwaysFailsHash :: WitCtx ctx -> BuiltinByteString

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer

-- | A message with a cryptographic signature.
newtype Signature
Signature :: BuiltinByteString -> Signature
[getSignature] :: Signature -> BuiltinByteString

-- | Passphrase newtype to mark intent
newtype Passphrase
Passphrase :: ByteString -> Passphrase
[unPassphrase] :: Passphrase -> ByteString
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | A cryptographic private key.
newtype PrivateKey
PrivateKey :: LedgerBytes -> PrivateKey
[getPrivateKey] :: PrivateKey -> LedgerBytes

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | Check whether the given <a>Signature</a> was signed by the private key
--   corresponding to the given public key.
signedBy :: ByteArrayAccess a => Signature -> PubKey -> a -> Bool

-- | Sign the hash of a transaction using a private key and passphrase.
signTx :: TxId -> XPrv -> Passphrase -> Signature

-- | Sign the hash of a transaction using a private key that has no
--   passphrase.
signTx' :: TxId -> XPrv -> Signature

-- | Sign a message using a private key and passphrase.
sign :: ByteArrayAccess a => a -> XPrv -> Passphrase -> Signature

-- | Sign a message using a private key with no passphrase.
sign' :: ByteArrayAccess a => a -> XPrv -> Signature

-- | Generate a private key from a seed phrase and passphrase
generateFromSeed :: ByteString -> Passphrase -> XPrv

-- | Generate a private key from a seed phrase without a passphrase.
generateFromSeed' :: ByteString -> XPrv
xPubToPublicKey :: XPub -> PubKey
toPublicKey :: XPrv -> PubKey
newtype PaymentPubKey
PaymentPubKey :: PubKey -> PaymentPubKey
[unPaymentPubKey] :: PaymentPubKey -> PubKey
newtype PaymentPrivateKey
PaymentPrivateKey :: XPrv -> PaymentPrivateKey
[unPaymentPrivateKey] :: PaymentPrivateKey -> XPrv
type CardanoAddress = AddressInEra BabbageEra
cardanoAddressCredential :: AddressInEra era -> Credential
cardanoStakingCredential :: AddressInEra era -> Maybe StakingCredential
cardanoPubKeyHash :: AddressInEra era -> Maybe PubKeyHash
toPlutusAddress :: AddressInEra era -> Address
toPlutusPubKeyHash :: Hash PaymentKey -> PubKeyHash
newtype PaymentPubKeyHash
PaymentPubKeyHash :: PubKeyHash -> PaymentPubKeyHash
[unPaymentPubKeyHash] :: PaymentPubKeyHash -> PubKeyHash
xprvToPaymentPubKey :: XPrv -> PaymentPubKey
newtype StakePubKey
StakePubKey :: PubKey -> StakePubKey
[unStakePubKey] :: StakePubKey -> PubKey
xprvToPaymentPubKeyHash :: XPrv -> PaymentPubKeyHash
newtype StakePubKeyHash
StakePubKeyHash :: PubKeyHash -> StakePubKeyHash
[unStakePubKeyHash] :: StakePubKeyHash -> PubKeyHash
xprvToStakePubKey :: XPrv -> StakePubKey
xprvToStakePubKeyHash :: XPrv -> StakePubKeyHash
xprvToStakingCredential :: XPrv -> StakingCredential
paymentPubKeyHash :: PaymentPubKey -> PaymentPubKeyHash

-- | The address that should be targeted by a transaction output locked by
--   the given public payment key (with its staking credentials).
pubKeyHashAddress :: PaymentPubKeyHash -> Maybe StakingCredential -> Address

-- | The address that should be targeted by a transaction output locked by
--   the given public key. (with its staking credentials).
pubKeyAddress :: PaymentPubKey -> Maybe StakingCredential -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script (with its staking credentials).
scriptValidatorHashAddress :: ValidatorHash -> Maybe StakingCredential -> Address

-- | Construct a <a>StakingCredential</a> from a public key hash.
stakePubKeyHashCredential :: StakePubKeyHash -> StakingCredential

-- | Construct a <a>StakingCredential</a> from a validator script hash.
stakeValidatorHashCredential :: StakeValidatorHash -> StakingCredential

-- | Cardano address of a versioned <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Versioned Validator -> AddressInEra BabbageEra
data ToCardanoError

-- | A C.TxBodyError converted to String
TxBodyError :: String -> ToCardanoError
DeserialisationError :: ToCardanoError
InvalidValidityRange :: ToCardanoError
ValueNotPureAda :: ToCardanoError
OutputHasZeroAda :: ToCardanoError
StakingPointersNotSupported :: ToCardanoError
SimpleScriptsNotSupportedToCardano :: ToCardanoError
MissingInputValidator :: ToCardanoError
MissingDatum :: ToCardanoError
MissingMintingPolicy :: ToCardanoError
ScriptPurposeNotSupported :: ScriptTag -> ToCardanoError
MissingMintingPolicyRedeemer :: ToCardanoError
MissingStakeValidator :: ToCardanoError
UnsupportedPlutusVersion :: Language -> ToCardanoError
Tag :: String -> ToCardanoError -> ToCardanoError

-- | Cardano tx from any era.
data CardanoTx
[CardanoTx] :: IsCardanoEra era => Tx era -> EraInMode era CardanoMode -> CardanoTx
pattern CardanoEmulatorEraTx :: Tx BabbageEra -> CardanoTx
adaToCardanoValue :: Ada -> Value
fromCardanoValue :: Value -> Value
toCardanoValue :: Value -> Either ToCardanoError Value
fromCardanoAssetId :: AssetId -> AssetClass
toCardanoAssetId :: AssetClass -> Either ToCardanoError AssetId
lovelaceToValue :: Lovelace -> Value
lovelaceValueOf :: Integer -> Value
adaValueOf :: Rational -> Value
isZero :: Value -> Bool
isAdaOnlyValue :: Value -> Bool
noAdaValue :: Value -> Value
adaOnlyValue :: Value -> Value
assetIdValue :: AssetId -> Integer -> Value
scale :: Integer -> Value -> Value
split :: Value -> (Value, Value)
policyId :: Versioned MintingPolicy -> PolicyId
combine :: Monoid m => (AssetId -> Quantity -> Quantity -> m) -> Value -> Value -> m
valueGeq :: Value -> Value -> Bool
valueLeq :: Value -> Value -> Bool
type ReferenceScript = ReferenceScript BabbageEra
type MintingWitnessesMap = Map MintingPolicyHash (Redeemer, Maybe (Versioned TxOutRef))
type ScriptsMap = Map ScriptHash (Versioned Script)
newtype TxOut
TxOut :: TxOut CtxTx BabbageEra -> TxOut
[getTxOut] :: TxOut -> TxOut CtxTx BabbageEra
data Certificate
Certificate :: DCert -> Maybe Redeemer -> Certificate
[certificateDcert] :: Certificate -> DCert

-- | redeemer for script credential
[certificateRedeemer] :: Certificate -> Maybe Redeemer

-- | Stake withdrawal, if applicable the script should be included in
--   txScripts.
data Withdrawal
Withdrawal :: Credential -> Integer -> Maybe Redeemer -> Withdrawal

-- | staking credential
[withdrawalCredential] :: Withdrawal -> Credential

-- | amount of withdrawal in Lovelace, must withdraw all eligible amount
[withdrawalAmount] :: Withdrawal -> Integer

-- | redeemer for script credential
[withdrawalRedeemer] :: Withdrawal -> Maybe Redeemer
cardanoTxOutValue :: TxOut ctx era -> Value
txOutValue :: TxOut -> Value
outValue :: Lens TxOut TxOut Value (TxOutValue BabbageEra)
outValue' :: Lens' TxOut (TxOutValue BabbageEra)
toSizedTxOut :: TxOut -> Sized (TxOut StandardBabbage)
toCtxUTxOTxOut :: TxOut -> TxOut CtxUTxO BabbageEra

-- | Get a hash from the stored TxOutDatum (either directly or by hashing
--   the inlined datum)
txOutDatumHash :: TxOut -> Maybe DatumHash
txOutDatum :: forall d. FromData d => TxOut -> Maybe d
cardanoTxOutDatumHash :: TxOutDatum CtxUTxO BabbageEra -> Maybe (Hash ScriptData)
txOutPubKey :: TxOut -> Maybe PubKeyHash
txOutAddress :: TxOut -> CardanoAddress
outAddress :: Lens' TxOut (AddressInEra BabbageEra)
outDatumHash :: Lens TxOut TxOut (Maybe DatumHash) (TxOutDatum CtxTx BabbageEra)
txOutReferenceScript :: TxOut -> ReferenceScript
outReferenceScript :: Lens' TxOut ReferenceScript
lookupScript :: ScriptsMap -> ScriptHash -> Maybe (Versioned Script)
lookupValidator :: ScriptsMap -> ValidatorHash -> Maybe (Versioned Validator)
lookupMintingPolicy :: ScriptsMap -> MintingPolicyHash -> Maybe (Versioned MintingPolicy)
lookupStakeValidator :: ScriptsMap -> StakeValidatorHash -> Maybe (Versioned StakeValidator)
emptyTxBodyContent :: TxBodyContent BuildTx BabbageEra

-- | A reason why a transaction is invalid.
data ValidationError

-- | The transaction output consumed by a transaction input could not be
--   found (either because it was already spent, or because there was no
--   transaction with the given hash on the blockchain).
TxOutRefNotFound :: TxIn -> ValidationError

-- | For pay-to-script outputs: evaluation of the validator script failed.
ScriptFailure :: ScriptError -> ValidationError

-- | An error from Cardano.Ledger validation
CardanoLedgerValidationError :: Text -> ValidationError

-- | Balancing failed, it needed more than the maximum number of collateral
--   inputs
MaxCollateralInputsExceeded :: ValidationError

-- | The UTxOs of a blockchain indexed by their references.
type UtxoIndex = UTxO BabbageEra

-- | A transaction on the blockchain. Invalid transactions are still put on
--   the chain to be able to collect fees.
newtype OnChainTx
OnChainTx :: Validated (Tx EmulatorEra) -> OnChainTx
[getOnChainTx] :: OnChainTx -> Validated (Tx EmulatorEra)
eitherTx :: (CardanoTx -> r) -> (CardanoTx -> r) -> OnChainTx -> r
unOnChain :: OnChainTx -> CardanoTx
data ValidationResult

-- | A transaction failed to validate in phase 1.
FailPhase1 :: !CardanoTx -> !ValidationError -> ValidationResult

-- | A transaction failed to validate in phase 2. The <tt>Value</tt>
--   indicates the amount of collateral stored in the transaction.
FailPhase2 :: !OnChainTx -> !ValidationError -> !Value -> ValidationResult
Success :: !OnChainTx -> !RedeemerReport -> ValidationResult
type RedeemerReport = Map RdmrPtr ([Text], ExUnits)
type ValidationSuccess = (RedeemerReport, Validated (Tx EmulatorEra))
type ValidationErrorInPhase = (ValidationPhase, ValidationError)
data ValidationPhase
Phase1 :: ValidationPhase
Phase2 :: ValidationPhase
_TxOutRefNotFound :: Prism' ValidationError TxIn
_ScriptFailure :: Prism' ValidationError ScriptError
_CardanoLedgerValidationError :: Prism' ValidationError Text
_FailPhase1 :: Prism' ValidationResult (CardanoTx, ValidationError)
_FailPhase2 :: Prism' ValidationResult (OnChainTx, ValidationError, Value)
_Success :: Prism' ValidationResult (OnChainTx, RedeemerReport)
cardanoTxFromValidationResult :: ValidationResult -> CardanoTx
toOnChain :: ValidationResult -> Maybe OnChainTx

-- | Get logs from evaluating plutus scripts.
getEvaluationLogs :: ValidationResult -> [Text]

-- | A datum in a transaction output that comes from a chain index query.
data DatumFromQuery
DatumUnknown :: DatumFromQuery
DatumInline :: Datum -> DatumFromQuery
DatumInBody :: Datum -> DatumFromQuery

-- | Offchain view of a transaction output.
data DecoratedTxOut
PublicKeyDecoratedTxOut :: PubKeyHash -> Maybe StakingCredential -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> DecoratedTxOut

-- | The pubKey hash that protects the transaction address
[_decoratedTxOutPubKeyHash] :: DecoratedTxOut -> PubKeyHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Optional datum (inline datum or datum in transaction body) attached to
--   the transaction output.
[_decoratedTxOutPubKeyDatum] :: DecoratedTxOut -> Maybe (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)
ScriptDecoratedTxOut :: ValidatorHash -> Maybe StakingCredential -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> DecoratedTxOut

-- | The hash of the script that protects the transaction address
[_decoratedTxOutValidatorHash] :: DecoratedTxOut -> ValidatorHash

-- | The staking credential of the transaction address, if any
[_decoratedTxOutStakingCredential] :: DecoratedTxOut -> Maybe StakingCredential

-- | Value of the transaction output.
[_decoratedTxOutValue] :: DecoratedTxOut -> Value

-- | Datum attached to the transaction output, either in full (inline datum
--   or datum in transaction body) or as a hash reference. A transaction
--   output protected by a Plutus script is guardateed to have an
--   associated datum.
[_decoratedTxOutScriptDatum] :: DecoratedTxOut -> (DatumHash, DatumFromQuery)

-- | Value of the transaction output.
[_decoratedTxOutReferenceScript] :: DecoratedTxOut -> Maybe (Versioned Script)

-- | Full version of the validator protecting the transaction output
[_decoratedTxOutValidator] :: DecoratedTxOut -> Maybe (Versioned Validator)
datumInDatumFromQuery :: Traversal' DatumFromQuery Datum
decoratedTxOutPubKeyDatum :: Traversal' DecoratedTxOut (Maybe (DatumHash, DatumFromQuery))
decoratedTxOutPubKeyHash :: Traversal' DecoratedTxOut PubKeyHash
decoratedTxOutReferenceScript :: Lens' DecoratedTxOut (Maybe (Versioned Script))
decoratedTxOutScriptDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
decoratedTxOutStakingCredential :: Lens' DecoratedTxOut (Maybe StakingCredential)
decoratedTxOutValidator :: Traversal' DecoratedTxOut (Maybe (Versioned Validator))
decoratedTxOutValidatorHash :: Traversal' DecoratedTxOut ValidatorHash
decoratedTxOutValue :: Lens' DecoratedTxOut Value
_PublicKeyDecoratedTxOut :: Prism' DecoratedTxOut (PubKeyHash, Maybe StakingCredential, Value, Maybe (DatumHash, DatumFromQuery), Maybe (Versioned Script))
_ScriptDecoratedTxOut :: Prism' DecoratedTxOut (ValidatorHash, Maybe StakingCredential, Value, (DatumHash, DatumFromQuery), Maybe (Versioned Script), Maybe (Versioned Validator))
mkDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkPubkeyDecoratedTxOut :: CardanoAddress -> Value -> Maybe (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe DecoratedTxOut
mkScriptDecoratedTxOut :: CardanoAddress -> Value -> (DatumHash, DatumFromQuery) -> Maybe (Versioned Script) -> Maybe (Versioned Validator) -> Maybe DecoratedTxOut
_decoratedTxOutAddress :: DecoratedTxOut -> Address
decoratedTxOutAddress :: Getter DecoratedTxOut Address
decoratedTxOutDatum :: Traversal' DecoratedTxOut (DatumHash, DatumFromQuery)
toDecoratedTxOut :: TxOut -> Maybe DecoratedTxOut
toTxOut :: NetworkId -> DecoratedTxOut -> Either ToCardanoError TxOut

-- | Converts a transaction output from the chain index to the
--   plutus-ledger-api transaction output.
--   
--   Note that <a>DecoratedTxOut</a> supports features such inline datums
--   and reference scripts which are not supported by V1 TxOut. Converting
--   from <a>DecoratedTxOut</a> to <a>TxOut</a> and back is therefore
--   lossy.
toTxInfoTxOut :: DecoratedTxOut -> TxOut
fromDecoratedIndex :: NetworkId -> Map TxOutRef DecoratedTxOut -> Either ToCardanoError UtxoIndex
getCardanoTxId :: CardanoTx -> TxId
getCardanoTxInputs :: CardanoTx -> [TxIn]
getTxBodyContentInputs :: TxBodyContent ctx era -> [TxIn]
getCardanoTxCollateralInputs :: CardanoTx -> [TxIn]
getTxBodyContentCollateralInputs :: TxBodyContent ctx era -> [TxIn]
getCardanoTxOutRefs :: CardanoTx -> [(TxOut, TxIn)]
getCardanoTxOutputs :: CardanoTx -> [TxOut]
getCardanoTxProducedOutputs :: CardanoTx -> Map TxIn TxOut
getCardanoTxSpentOutputs :: CardanoTx -> Set TxIn
getCardanoTxReturnCollateral :: CardanoTx -> Maybe TxOut
getTxBodyContentReturnCollateral :: TxBodyContent ctx BabbageEra -> Maybe TxOut
getCardanoTxProducedReturnCollateral :: CardanoTx -> Map TxIn TxOut
getCardanoTxTotalCollateral :: CardanoTx -> Maybe Lovelace
getCardanoTxFee :: CardanoTx -> Lovelace
getCardanoTxMint :: CardanoTx -> Value
getTxBodyContentMint :: TxBodyContent ctx era -> Value
getCardanoTxValidityRange :: CardanoTx -> SlotRange
getCardanoTxData :: CardanoTx -> Map DatumHash Datum
txBodyContentIns :: Lens' (TxBodyContent BuildTx BabbageEra) [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn BabbageEra))]
txBodyContentCollateralIns :: Lens' (TxBodyContent BuildTx BabbageEra) [TxIn]
txBodyContentOuts :: Lens' (TxBodyContent ctx BabbageEra) [TxOut]
getCardanoTxRedeemers :: CardanoTx -> Redeemers
addCardanoTxSignature :: PrivateKey -> CardanoTx -> CardanoTx
decoratedTxOutPlutusValue :: DecoratedTxOut -> Value

-- | A blockchain, which is just a list of blocks, starting with the
--   newest.
type Blockchain = [Block]

-- | A block on the blockchain. This is just a list of transactions
--   following on from the chain so far.
type Block = [OnChainTx]

-- | Block identifier (usually a hash)
newtype BlockId
BlockId :: ByteString -> BlockId
[getBlockId] :: BlockId -> ByteString
onChainTxIsValid :: OnChainTx -> Bool

-- | Outputs consumed from the UTXO set by the <a>OnChainTx</a>
consumableInputs :: OnChainTx -> [TxIn]

-- | Outputs added to the UTXO set by the <a>OnChainTx</a>
outputsProduced :: OnChainTx -> Map TxIn TxOut

-- | Create an index of all UTxOs on the chain.
initialise :: Blockchain -> UtxoIndex

-- | Update the index for the addition of a transaction.
insert :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of only the collateral inputs of a
--   failed transaction.
insertCollateral :: CardanoTx -> UtxoIndex -> UtxoIndex

-- | Update the index for the addition of a block.
insertBlock :: Block -> UtxoIndex -> UtxoIndex

-- | Find an unspent transaction output by the <tt>TxOutRef</tt> that
--   spends it.
lookup :: TxIn -> UtxoIndex -> Maybe TxOut
getCollateral :: UtxoIndex -> CardanoTx -> Value

-- | Adjust a single transaction output so it contains at least the minimum
--   amount of Ada and return the adjustment (if any) and the updated
--   TxOut.
adjustTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> ([Lovelace], TxOut)

-- | Exact computation of the mimimum Ada required for a given TxOut. TODO:
--   Should be moved to cardano-api-extended once created
minAdaTxOut :: PParams (BabbageEra StandardCrypto) -> TxOut -> Lovelace

-- | Provide a reasonable estimate of the mimimum of Ada required for a
--   TxOut.
--   
--   An exact estimate of the the mimimum of Ada in a TxOut is determined
--   by two things: - the <tt>PParams</tt>, more precisely its
--   <tt>coinPerUTxOWord</tt> parameter. - the size of the <a>TxOut</a>. In
--   many situations though, we need to determine a plausible value for the
--   minimum of Ada needed for a TxOut without knowing much of the
--   <a>TxOut</a>. This function provides a value big enough to balance
--   UTxOs without a large inlined data (larger than a hash) nor a complex
--   val with a lot of minted values. It's superior to the lowest minimum
--   needed for an UTxO, as the lowest value require no datum. An estimate
--   of the minimum required Ada for each tx output.
minAdaTxOutEstimated :: Ada
minLovelaceTxOutEstimated :: Lovelace
maxMinAdaTxOut :: Ada

-- | TODO Should be calculated based on the maximum script size permitted
--   on the Cardano blockchain.
maxFee :: Ada

-- | cardano-ledger validation rules require the presence of inputs and we
--   have to provide a stub TxIn for the genesis transaction.
genesisTxIn :: TxIn
createGenesisTransaction :: Map CardanoAddress Value -> CardanoTx
data DCert
data NetworkId
data Credential
data StakingCredential

module Ledger.Test
someCode :: CompiledCode (BuiltinData -> BuiltinData -> BuiltinData -> ())
someValidator :: Validator
someTypedValidator :: TypedValidator Any
someValidatorHash :: ValidatorHash
someCardanoAddress :: NetworkId -> CardanoAddress
someAddress :: Address
someValidatorV2 :: Validator
someTypedValidatorV2 :: TypedValidator Any
someValidatorHashV2 :: ValidatorHash
someCardanoAddressV2 :: NetworkId -> CardanoAddress
someAddressV2 :: Address
mkPolicy :: () -> ScriptContext -> Bool
mkPolicyV2 :: () -> ScriptContext -> Bool
coinMintingPolicy :: Language -> Versioned MintingPolicy
coinMintingPolicyV1 :: MintingPolicy
coinMintingPolicyV2 :: MintingPolicy
coinMintingPolicyHash :: Language -> MintingPolicyHash
coinMintingPolicyHashV1 :: MintingPolicyHash
coinMintingPolicyHashV2 :: MintingPolicyHash
coinMintingPolicyCurrencySymbol :: Language -> CurrencySymbol
coinMintingPolicyCurrencySymbolV1 :: CurrencySymbol
coinMintingPolicyCurrencySymbolV2 :: CurrencySymbol
someToken :: Language -> Value
asRedeemer :: ToData a => a -> Redeemer
asDatum :: ToData a => a -> Datum
coinMintingPolicyId :: Language -> PolicyId
testNetworkMagic :: NetworkMagic
testnet :: NetworkId

module Ledger.CardanoWallet

-- | Emulated wallet with a key and a passphrase
data MockWallet
MockWallet :: Digest Blake2b_160 -> MockPrivateKey -> Maybe MockPrivateKey -> Maybe String -> MockWallet
[mwWalletId] :: MockWallet -> Digest Blake2b_160
[mwPaymentKey] :: MockWallet -> MockPrivateKey
[mwStakeKey] :: MockWallet -> Maybe MockPrivateKey
[mwPrintAs] :: MockWallet -> Maybe String

-- | Wrapper for config files and APIs
newtype WalletNumber
WalletNumber :: Integer -> WalletNumber
[getWallet] :: WalletNumber -> Integer
fromWalletNumber :: WalletNumber -> MockWallet
toWalletNumber :: MockWallet -> WalletNumber

-- | The wallets used in mockchain simulations by default. There are ten
--   wallets by default.
knownMockWallets :: [MockWallet]

-- | Get a known wallet from an <tt>Integer</tt> indexed from 1 to 10.
knownMockWallet :: Integer -> MockWallet
fromSeed :: ByteString -> Passphrase -> MockWallet
fromSeed' :: ByteString -> MockWallet

-- | A mock cardano address for the testnet network.
mockWalletAddress :: MockWallet -> CardanoAddress

-- | Mock wallet's private key
paymentPrivateKey :: MockWallet -> PaymentPrivateKey

-- | The mock wallet's public key hash
paymentPubKeyHash :: MockWallet -> PaymentPubKeyHash

-- | The mock wallet's payment public key
paymentPubKey :: MockWallet -> PaymentPubKey

-- | The mock wallet's staking credentials
stakingCredential :: MockWallet -> Maybe StakingCredential

-- | The mock wallet's stake public key hash
stakePubKeyHash :: MockWallet -> Maybe StakePubKeyHash

-- | The mock wallet's stake public key
stakePubKey :: MockWallet -> Maybe StakePubKey
knownAddresses :: [CardanoAddress]
knownPaymentKeys :: Map PaymentPubKey PaymentPrivateKey
knownPaymentPublicKeys :: [PaymentPubKey]
knownPaymentPrivateKeys :: [PaymentPrivateKey]
instance GHC.Show.Show Ledger.CardanoWallet.MockWallet
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.CardanoWallet.WalletNumber
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.CardanoWallet.WalletNumber
instance GHC.Real.Integral Ledger.CardanoWallet.WalletNumber
instance GHC.Real.Real Ledger.CardanoWallet.WalletNumber
instance GHC.Enum.Enum Ledger.CardanoWallet.WalletNumber
instance GHC.Num.Num Ledger.CardanoWallet.WalletNumber
instance Web.Internal.HttpApiData.FromHttpApiData Ledger.CardanoWallet.WalletNumber
instance Web.Internal.HttpApiData.ToHttpApiData Ledger.CardanoWallet.WalletNumber
instance GHC.Generics.Generic Ledger.CardanoWallet.WalletNumber
instance GHC.Classes.Ord Ledger.CardanoWallet.WalletNumber
instance GHC.Classes.Eq Ledger.CardanoWallet.WalletNumber
instance GHC.Show.Show Ledger.CardanoWallet.WalletNumber
instance GHC.Show.Show Ledger.CardanoWallet.MockPrivateKey
instance GHC.Classes.Eq Ledger.CardanoWallet.MockPrivateKey
instance GHC.Classes.Ord Ledger.CardanoWallet.MockPrivateKey
instance Data.Hashable.Class.Hashable Ledger.CardanoWallet.MockPrivateKey
