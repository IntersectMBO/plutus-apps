-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package plutus-contract
@version 1.2.0.0


-- | Instances for <a>Rec</a> and <a>Var</a> types
module Data.Row.Extras
newtype JsonRec s
JsonRec :: Rec s -> JsonRec s
[unJsonRec] :: JsonRec s -> Rec s
newtype JsonVar s
JsonVar :: Var s -> JsonVar s
[unJsonVar] :: JsonVar s -> Var s

-- | Parse a 'Var s' from JSON if the label of the branch is known.
namedBranchFromJSON :: forall s. (AllUniqueLabels s, Forall s FromJSON) => String -> Value -> Parser (Var s)

-- | Fast diff. The implementation in row-types is exponential in time and
--   memory in the number of overlapping rows, due to limitations in ghc's
--   handling of type families. This version is much faster.
--   
--   Type level Row difference. That is, <tt>l <a>.\\</a> r</tt> is the row
--   remaining after removing any matching elements of <tt>r</tt> from
--   <tt>l</tt>.
type family (l :: Row k) .\\ (r :: Row k) :: Row k
infixl 6 .\\
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonVar s)
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonVar s)

module Data.Text.Extras
abbreviate :: Int -> Text -> Text
tshow :: Show a => a -> Text

module Data.UUID.Extras
isValidVersion :: Int -> UUID -> Bool

-- | A pure list of UUIDs that can be used in testing. This is _almost_ a
--   sequence counting up from zero, but we ensure that the version and
--   variant numbers are correctly set so the resulting UUIDs validate.
mockUUIDs :: [UUID]

-- | Given a UUID from <a>mockUUIDs</a>, returns a simple sequence number.
--   Returns <a>Nothing</a> if your UUID doesn't seem to come from that
--   sequence. As the name suggests, you should really only be using this
--   for mocking/testing.
mockUUIDToSequenceId :: UUID -> Maybe Word32

-- | Create a UUID that can be used in testing, from a simple
--   <a>Word32</a>. Reminder: Use 'fromIntegral i' to call it with an
--   <a>Int</a>.
sequenceIdToMockUUID :: Word32 -> UUID

module Plutus.Contract.Checkpoint
data Checkpoint r
[DoCheckpoint] :: Checkpoint ()
[AllocateKey] :: Checkpoint CheckpointKey
[Store] :: ToJSON a => CheckpointKey -> CheckpointKey -> a -> Checkpoint ()
[Retrieve] :: FromJSON a => CheckpointKey -> Checkpoint (Either CheckpointError (Maybe a))
data CheckpointError
JSONDecodeError :: Text -> CheckpointError
class AsCheckpointError r_ah4E
_CheckpointError :: AsCheckpointError r_ah4E => Prism' r_ah4E CheckpointError
_JSONDecodeError :: AsCheckpointError r_ah4E => Prism' r_ah4E Text
newtype CheckpointStore
CheckpointStore :: Map CheckpointKey (CheckpointStoreItem Value) -> CheckpointStore
[unCheckpointStore] :: CheckpointStore -> Map CheckpointKey (CheckpointStoreItem Value)
data CheckpointStoreItem a
CheckpointStoreItem :: a -> CheckpointKey -> CheckpointStoreItem a
[csValue] :: CheckpointStoreItem a -> a
[csNewKey] :: CheckpointStoreItem a -> CheckpointKey
data CheckpointKey
data CheckpointLogMsg
LogFoundValueRestoringKey :: CheckpointKey -> CheckpointLogMsg
LogDecodingErrorAtKey :: CheckpointKey -> CheckpointLogMsg
LogNoValueForKey :: CheckpointKey -> CheckpointLogMsg
LogDoCheckpoint :: CheckpointLogMsg
LogAllocateKey :: CheckpointLogMsg
LogRetrieve :: CheckpointKey -> CheckpointLogMsg
LogStore :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg
LogKeyUpdate :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg

-- | Create a checkpoint for an action. <tt>handleCheckpoint
--   (jsonCheckpoint action)</tt> will
--   
--   <ul>
--   <li>Obtain a <a>CheckpointKey</a> that identifies the position of the
--   current checkpoint in the program</li>
--   <li>Run <tt>action</tt>, convert its result to JSON and store it in
--   the checkpoint store if there is no value at the key</li>
--   <li>Retrieve the result as a JSON value from the store, parse it, and
--   return it *instead* of running <tt>action</tt> if there is a value at
--   the key.</li>
--   </ul>
jsonCheckpoint :: forall err a effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, AsCheckpointError err) => Eff effs a -> Eff effs a
jsonCheckpointLoop :: forall err a b effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, ToJSON b, FromJSON b, AsCheckpointError err) => (a -> Eff effs (Either b a)) -> a -> Eff effs b

-- | Handle the <a>Checkpoint</a> effect in terms of <a>CheckpointStore</a>
--   and <a>CheckpointKey</a> states.
handleCheckpoint :: forall effs. (Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (LogMsg CheckpointLogMsg) effs) => Eff (Checkpoint : effs) ~> Eff effs

-- | Intervals of checkpoint keys that are completely covered by the
--   checkpoint store.
completedIntervals :: CheckpointStore -> IntervalSet (Interval CheckpointKey)

-- | The maximum key that is present in the store
maxKey :: CheckpointStore -> Maybe CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Traversable.Traversable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance Data.Foldable.Foldable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Base.Functor Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Generics.Generic (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Base.Monoid Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Base.Semigroup Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointStore
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Enum.Enum Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Num.Num Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointError

module Plutus.Contract.Constraints

module Plutus.Contract.Oracle

-- | A value that was observed at a specific point in time
data Observation a
Observation :: a -> POSIXTime -> Observation a

-- | The value
[obsValue] :: Observation a -> a

-- | The time at which the value was observed
[obsTime] :: Observation a -> POSIXTime

-- | <tt>SignedMessage a</tt> contains the signature of a hash of a
--   <a>Datum</a>. The <a>Datum</a> can be decoded to a value of type
--   <tt>a</tt>.
data SignedMessage a
SignedMessage :: Signature -> DatumHash -> Datum -> SignedMessage a

-- | Signature of the message
[osmSignature] :: SignedMessage a -> Signature

-- | Hash of the message
[osmMessageHash] :: SignedMessage a -> DatumHash
[osmDatum] :: SignedMessage a -> Datum
data SignedMessageCheckError

-- | The signature did not match the public key
SignatureMismatch :: Signature -> PaymentPubKey -> DatumHash -> SignedMessageCheckError

-- | The datum was missing from the pending transaction
DatumMissing :: DatumHash -> SignedMessageCheckError

-- | The datum had the wrong shape
DecodingError :: SignedMessageCheckError

-- | The datum that corresponds to the hash is wrong
DatumNotEqualToExpected :: SignedMessageCheckError

-- | Verify the signature on a signed datum hash
checkSignature :: DatumHash -> PaymentPubKey -> Signature -> Either SignedMessageCheckError ()

-- | Extract the contents of the message and produce a constraint that
--   checks that the hash is correct. In off-chain code, where we check the
--   hash straightforwardly, <a>checkHashOffChain</a> can be used instead
--   of this.
checkHashConstraints :: FromData a => SignedMessage a -> Either SignedMessageCheckError (a, TxConstraints i o)

-- | The off-chain version of <a>checkHashConstraints</a>, using the hash
--   function directly instead of obtaining the hash from a
--   <a>ScriptContext</a> value
checkHashOffChain :: FromData a => SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message.
verifySignedMessageOffChain :: FromData a => PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message, using the pending transaction in lieu of a hash
--   function. See <a>verifySignedMessageConstraints</a> for a version that
--   does not require a <a>ScriptContext</a> value.
verifySignedMessageOnChain :: FromData a => ScriptContext -> PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError a

-- | Check the signature on a <a>SignedMessage</a> and extract the contents
--   of the message, producing a <tt>TxConstraint</tt> value that ensures
--   the hashes match up.
verifySignedMessageConstraints :: FromData a => PaymentPubKey -> SignedMessage a -> Either SignedMessageCheckError (a, TxConstraints i o)

-- | Encode a message of type <tt>a</tt> as a <tt>Data</tt> value and sign
--   the hash of the datum.
signMessage :: ToData a => a -> PaymentPrivateKey -> Passphrase -> SignedMessage a

-- | Encode an observation of a value of type <tt>a</tt> that was made at
--   the given time
signObservation :: ToData a => POSIXTime -> a -> PaymentPrivateKey -> Passphrase -> SignedMessage (Observation a)

-- | Encode a message of type <tt>a</tt> as a <tt>Data</tt> value and sign
--   the hash of the datum.
signMessage' :: ToData a => a -> XPrv -> SignedMessage a

-- | Encode an observation of a value of type <tt>a</tt> that was made at
--   the given time
signObservation' :: ToData a => POSIXTime -> a -> XPrv -> SignedMessage (Observation a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.Oracle.Observation
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contract.Oracle.Observation a)
instance PlutusTx.IsData.Class.ToData a => PlutusTx.IsData.Class.ToData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.IsData.Class.FromData a => PlutusTx.IsData.Class.FromData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.IsData.Class.UnsafeFromData a => PlutusTx.IsData.Class.UnsafeFromData (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.Oracle.SignedMessage
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Oracle.Observation a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Oracle.Observation a)
instance GHC.Generics.Generic (Plutus.Contract.Oracle.Observation a)
instance Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Oracle.SignedMessage a)
instance Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Classes.Eq (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Show.Show (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Generics.Generic (Plutus.Contract.Oracle.SignedMessage a)
instance GHC.Show.Show Plutus.Contract.Oracle.SignedMessageCheckError
instance GHC.Generics.Generic Plutus.Contract.Oracle.SignedMessageCheckError
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contract.Oracle.SignedMessage a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.Contract.Oracle.Observation a)

module Plutus.Contract.Resumable

-- | A data type for representing non-deterministic prompts.
data Resumable i o r
[RRequest] :: o -> Resumable i o i
[RSelect] :: Resumable i o Bool
[RZero] :: Resumable i o a
prompt :: Member (Resumable i o) effs => o -> Eff effs i
select :: forall i o effs a. Member (Resumable i o) effs => Eff effs a -> Eff effs a -> Eff effs a
never :: forall i o effs a. Member (Resumable i o) effs => Eff effs a
data Request o
Request :: RequestID -> IterationID -> o -> Request o
[rqID] :: Request o -> RequestID
[itID] :: Request o -> IterationID
[rqRequest] :: Request o -> o
data Response i
Response :: RequestID -> IterationID -> i -> Response i
[rspRqID] :: Response i -> RequestID
[rspItID] :: Response i -> IterationID
[rspResponse] :: Response i -> i

-- | A value that uniquely identifies requests made during the execution of
--   <a>Resumable</a> programs.
newtype RequestID
RequestID :: Natural -> RequestID

-- | A value that uniquely identifies groups of requests.
newtype IterationID
IterationID :: Natural -> IterationID
newtype Requests o
Requests :: [Request o] -> Requests o
[unRequests] :: Requests o -> [Request o]
type ResumableEffs i o effs a = NonDet : State IterationID : State RequestID : State (ReqMap i o effs a) : State (Requests o) : effs
newtype Responses i
Responses :: Map (IterationID, RequestID) i -> Responses i
[unResponses] :: Responses i -> Map (IterationID, RequestID) i
insertResponse :: Response i -> Responses i -> Responses i

-- | A list of all responses ordered by iteration and request ID
responses :: Responses i -> [Response i]
_Responses :: forall i. Iso' (Responses i) (Map (IterationID, RequestID) i)

-- | Interpret the <a>Resumable</a> effect in terms of the <a>Yield</a> and
--   <a>NonDet</a> effects.
handleResumable :: forall i o effs. (Member (Yield o i) effs, Member NonDet effs) => Eff (Resumable i o : effs) ~> Eff effs

-- | Interpret <a>Yield</a> as a prompt-type effect using <a>NonDet</a> to
--   branch out and choose a branch, and the <a>State</a> effects to keep
--   track of request IDs.
suspendNonDet :: forall i o a effs. Eff (Yield o i : ResumableEffs i o effs a) a -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | Status of a suspended <a>MultiRequestContinuation</a>.
data MultiRequestContStatus i o effs a

-- | Done
AResult :: a -> MultiRequestContStatus i o effs a

-- | Waiting for inputs
AContinuation :: MultiRequestContinuation i o effs a -> MultiRequestContStatus i o effs a

-- | A continuation that accepts a response to one of several requests.
data MultiRequestContinuation i o effs a
MultiRequestContinuation :: (Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))) -> Requests o -> MultiRequestContinuation i o effs a

-- | Continuation for the response
[ndcCont] :: MultiRequestContinuation i o effs a -> Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | The list of all open requests.
[ndcRequests] :: MultiRequestContinuation i o effs a -> Requests o

-- | A map of requests to continuations. For each request, identified by a
--   pair of <a>RequestID</a> and <a>IterationID</a>, <a>ReqMap</a>
--   contains the continuation that takes the response to the request.
newtype ReqMap i o effs a
ReqMap :: Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a) -> ReqMap i o effs a
[unReqMap] :: ReqMap i o effs a -> Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a)
instance GHC.Num.Num Plutus.Contract.Resumable.RequestID
instance GHC.Enum.Enum Plutus.Contract.Resumable.RequestID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.RequestID
instance GHC.Generics.Generic Plutus.Contract.Resumable.RequestID
instance GHC.Show.Show Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Ord Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Eq Plutus.Contract.Resumable.RequestID
instance GHC.Base.Semigroup Plutus.Contract.Resumable.IterationID
instance GHC.Num.Num Plutus.Contract.Resumable.IterationID
instance GHC.Enum.Enum Plutus.Contract.Resumable.IterationID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.IterationID
instance GHC.Generics.Generic Plutus.Contract.Resumable.IterationID
instance GHC.Show.Show Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Ord Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Eq Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Request o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Request
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Request
instance GHC.Base.Functor Plutus.Contract.Resumable.Request
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Request o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Response i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Response
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Response
instance GHC.Base.Functor Plutus.Contract.Resumable.Response
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Response i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Requests
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Requests
instance GHC.Base.Functor Plutus.Contract.Resumable.Requests
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Requests o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Requests o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Responses
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Responses
instance GHC.Base.Functor Plutus.Contract.Resumable.Responses
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Responses i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Responses i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Responses i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Requests o)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Response i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Request o)
instance GHC.Base.Monoid Plutus.Contract.Resumable.IterationID

module Plutus.Contract.Schema
newtype Handlers s
Handlers :: Var (Output s) -> Handlers s
[unHandlers] :: Handlers s -> Var (Output s)
handlerName :: Forall (Output s) Unconstrained1 => Handlers s -> String
handlerArgument :: Forall (Output s) ToJSON => Handlers s -> Value
newtype Event s
Event :: Var (Input s) -> Event s
[unEvent] :: Event s -> Var (Input s)
eventName :: Forall (Input s) Unconstrained1 => Event s -> String
initialise :: forall (s :: Row *) l a. (KnownSymbol l, AllUniqueLabels (Output s), HasType l a (Output s)) => a -> Handlers s
type family Input (r :: Row *)
type family Output (r :: Row *)
type EmptySchema = Empty
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Event s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Input s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Handlers s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Output s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Event s)

module Plutus.Contract.Secrets

-- | A secret value. A value of type `Secret a` can't leak onto the
--   blockchain in plain-text unless you use an unsafe function. However, a
--   value of type `Secret a` can end up on the blockchain via one of the
--   escape hatches like <a>escape_sha2_256</a>.
data Secret a

-- | Secret argments are provided in the endpoint argument types.
--   
--   This type guarantees that a `SecretArgument a` that is seen by the
--   endpoint code is a `Secret a` in a way that can not be bypassed by
--   safe code.
data SecretArgument a
UserSide :: a -> SecretArgument a
EndpointSide :: Secret a -> SecretArgument a

-- | Turn a public value into a secret value
mkSecret :: a -> Secret a

-- | Construct a secret argument
secretArg :: a -> SecretArgument a

-- | Extract a secret value from a secret argument
extractSecret :: SecretArgument a -> Secret a

-- | Take the sha2_256 hash of a secret value. The result of this function
--   can be used on the blockchain.
escape_sha2_256 :: Secret BuiltinByteString -> BuiltinByteString

-- | <i>Warning: [Requires Review] An escape hatch is being created. This
--   should only be used in trusted code.</i>
unsafe_escape_secret :: Secret a -> a
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Secrets.SecretArgument a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Secrets.SecretArgument a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Secrets.SecretArgument a)
instance Data.String.IsString s => Data.String.IsString (Plutus.Contract.Secrets.SecretArgument s)
instance GHC.Show.Show (Plutus.Contract.Secrets.Secret a)
instance GHC.Base.Functor Plutus.Contract.Secrets.Secret
instance PlutusTx.Functor.Functor Plutus.Contract.Secrets.Secret
instance GHC.Base.Applicative Plutus.Contract.Secrets.Secret
instance PlutusTx.Applicative.Applicative Plutus.Contract.Secrets.Secret
instance GHC.Base.Monad Plutus.Contract.Secrets.Secret
instance Data.String.IsString s => Data.String.IsString (Plutus.Contract.Secrets.Secret s)


-- | Data type used for minting and burning the thread token value.
module Plutus.Contract.StateMachine.MintingPolarity
data MintingPolarity
Mint :: MintingPolarity
Burn :: MintingPolarity
instance PlutusTx.IsData.Class.ToData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.IsData.Class.FromData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance PlutusTx.Eq.Eq Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance GHC.Show.Show Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity
instance GHC.Classes.Eq Plutus.Contract.StateMachine.MintingPolarity.MintingPolarity


-- | Thread token data type definition and minting policy. Thread tokens
--   are used to identify the contract instance on the blockchain, and
--   ensuring that the state was produced by running the state machine from
--   its initial state.
module Plutus.Contract.StateMachine.ThreadToken
data ThreadToken
ThreadToken :: TxOutRef -> CurrencySymbol -> ThreadToken
[ttOutRef] :: ThreadToken -> TxOutRef
[ttCurrencySymbol] :: ThreadToken -> CurrencySymbol
checkPolicy :: TxOutRef -> (ValidatorHash, MintingPolarity) -> ScriptContext -> Bool
curPolicy :: TxOutRef -> MintingPolicy

-- | The <a>Value</a> containing exactly the thread token.
threadTokenValue :: CurrencySymbol -> ValidatorHash -> Value

-- | Check exactly <tt>n</tt> thread tokens and no other tokens with the
--   given <tt>CurrencySymbol</tt> are in the given <tt>Value</tt>.
checkThreadTokenInner :: CurrencySymbol -> ValidatorHash -> Value -> Integer -> Bool
checkThreadToken :: Maybe ThreadToken -> ValidatorHash -> Value -> Integer -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.ToData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.FromData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Generics.Generic Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Classes.Ord Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Show.Show Plutus.Contract.StateMachine.ThreadToken.ThreadToken
instance GHC.Classes.Eq Plutus.Contract.StateMachine.ThreadToken.ThreadToken


-- | On-chain code fragments for creating a state machine. First define a
--   <tt>StateMachine s i</tt> with input type <tt>i</tt> and state type
--   <tt>s</tt>. Then use <a>mkValidator</a> in on-chain code to check the
--   required hashes and validate the transition, and <tt>mkRedeemer</tt>
--   to make redeemer scripts.
module Plutus.Contract.StateMachine.OnChain

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe ThreadToken -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <tt>ThreadToken</tt> that identifies the contract instance. Make
--   one with <tt>getThreadToken</tt> and pass it on to
--   <a>mkStateMachine</a>. Initialising the machine will then mint a
--   thread token value.
[smThreadToken] :: StateMachine s i -> Maybe ThreadToken
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe ThreadToken -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i

-- | TODO StateMachine can be use only on a testnet at the moment, to
--   enable it on another network, we need to parametrise the networkId
machineAddress :: StateMachineInstance s i -> CardanoAddress

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. ToData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | The <a>Value</a> containing exactly the thread token, if one has been
--   specified.
threadTokenValueOrZero :: StateMachineInstance s i -> Value
instance Data.Aeson.Types.FromJSON.FromJSON s => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance Data.Aeson.Types.ToJSON.ToJSON s => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Show.Show s => GHC.Show.Show (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Plutus.Contract.StateMachine.OnChain.State s)
instance Plutus.Script.Utils.Typed.ValidatorTypes (Plutus.Contract.StateMachine.OnChain.StateMachine s i)

module Plutus.Contract.Test.Coverage.Analysis.Common
type Trm = Term NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Typ = Type NamedTyDeBruijn DefaultUni ()
type Kin = Kind ()
type Dat = Datatype NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Bind = Binding NamedTyDeBruijn NamedDeBruijn DefaultUni DefaultFun ()
type Trm' = Term TyName Name DefaultUni DefaultFun ()
type Typ' = Type TyName DefaultUni ()
type Dat' = Datatype TyName Name DefaultUni DefaultFun ()
type Bind' = Binding TyName Name DefaultUni DefaultFun ()
type Err' = Error DefaultUni DefaultFun ()
pattern BIF_Trace :: Term tyname name uni DefaultFun ()
pattern BIF_If :: Term tyname name uni DefaultFun ()
pattern LIT_Loc :: CoverageAnnotation -> Term tyname name DefaultUni fun ()
pattern Const :: DefaultUni (Esc a) -> a -> Term tyname name DefaultUni fun ()
builtinKind :: SomeTypeIn DefaultUni -> Kin
data Verbosity
Low :: Verbosity
Med :: Verbosity
High :: Verbosity
Unions :: Verbosity
debug :: Bool
verbosity :: [Verbosity]
traceDoc :: Verbosity -> Doc -> a -> a
traceDocIf :: Bool -> Verbosity -> Doc -> a -> a
errorDoc :: HasCallStack => Doc -> a
pattern Star :: Kin
pattern (:->) :: Kin -> Kin -> Kin
infixr 3 :->
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.Analysis.Common.Verbosity

module Plutus.Contract.Test.Coverage.Analysis.DeBruijn
type DBCtx nm = [nm]
class Eq n => IsName n where {
    type family DeBruijn n;
}
mkDeBruijn :: IsName n => n -> Index -> DeBruijn n
class IsDbName n
setDbIndex :: IsDbName n => n -> Index -> n
getDbIndex :: IsDbName n => n -> Index
deBruijn :: HasCallStack => IsName n => DBCtx n -> n -> DeBruijn n
extendDBCtx :: HasCallStack => DBCtx n -> n -> DBCtx n
toDeBruijn_Trm :: HasCallStack => DBCtx TyName -> DBCtx Name -> Trm' -> Trm
toDeBruijn_Typ :: HasCallStack => DBCtx TyName -> Typ' -> Typ
bindCtx_Dat :: HasCallStack => (DBCtx TyName, DBCtx Name) -> Dat' -> (DBCtx TyName, DBCtx Name)
toDeBruijn_Dat :: HasCallStack => Bool -> DBCtx TyName -> Dat' -> Dat
bindCtx_Bind :: HasCallStack => (DBCtx TyName, DBCtx Name) -> Bind' -> (DBCtx TyName, DBCtx Name)
toDeBruijn_Bind :: HasCallStack => Bool -> DBCtx TyName -> DBCtx Name -> Bind' -> Bind
getTrm :: HasCallStack => CompiledCode a -> Trm
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsDbName PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsDbName PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsName PlutusCore.Name.Name
instance Plutus.Contract.Test.Coverage.Analysis.DeBruijn.IsName PlutusCore.Name.TyName

module Plutus.Contract.Test.Coverage.Analysis.Types
data SnocList a
Nil :: SnocList a
(:>) :: SnocList a -> a -> SnocList a
infixl 5 :>
zipWithSnoc :: (a -> b -> c) -> SnocList a -> SnocList b -> SnocList c
data DCon
DCon :: [DTyp] -> DCon
data DDat
DDat :: Bool -> NamedTyDeBruijn -> Kin -> [NamedTyDeBruijn] -> [DCon] -> DDat
data TyCtxEntry
(:::) :: NamedTyDeBruijn -> Kin -> TyCtxEntry
TyCtxRecDat :: SnocList DDat -> TyCtxEntry
TyCtxDat :: DDat -> TyCtxEntry
type TyCtx = SnocList TyCtxEntry
type Subst a = SnocList a
data Dom
DTop :: DTyp -> Int -> Set CoverageAnnotation -> Dom
[ty] :: Dom -> DTyp
[depth] :: Dom -> Int
[_locations] :: Dom -> Set CoverageAnnotation
DError :: Dom
DSusp :: Set CoverageAnnotation -> Dom -> Dom
[_locations] :: Dom -> Set CoverageAnnotation
[inner] :: Dom -> Dom
DTySusp :: NamedTyDeBruijn -> Kin -> Set CoverageAnnotation -> Dom -> Dom
[suspName] :: Dom -> NamedTyDeBruijn
[kind] :: Dom -> Kin
[_locations] :: Dom -> Set CoverageAnnotation
[inner] :: Dom -> Dom
DIf :: DTyp -> Set CoverageAnnotation -> Dom
[argTy] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DTrace :: DTyp -> Set CoverageAnnotation -> Dom
[argTy] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DLoc :: CoverageAnnotation -> Dom
[location] :: Dom -> CoverageAnnotation
DLam :: NamedDeBruijn -> DTyp -> Subst Dom -> Subst DTyp -> Trm -> Set CoverageAnnotation -> Dom
[lamName] :: Dom -> NamedDeBruijn
[argTy] :: Dom -> DTyp
[substD] :: Dom -> Subst Dom
[substT] :: Dom -> Subst DTyp
[body] :: Dom -> Trm
[_locations] :: Dom -> Set CoverageAnnotation
DConstr :: DTyp -> Int -> SnocList Dom -> Set CoverageAnnotation -> Dom
[dat] :: Dom -> DTyp
[constr] :: Dom -> Int
[argsD] :: Dom -> SnocList Dom
[_locations] :: Dom -> Set CoverageAnnotation
DMatch :: DTyp -> Set CoverageAnnotation -> Dom
[dat] :: Dom -> DTyp
[_locations] :: Dom -> Set CoverageAnnotation
DUnion :: [Dom] -> Dom
DWeaken :: Weakening -> Dom -> Dom
[wk] :: Dom -> Weakening
[inner] :: Dom -> Dom
data DTyp
DTVar :: NamedTyDeBruijn -> [DTyp] -> DTyp
DTFun :: DTyp -> DTyp -> DTyp
DTLam :: NamedTyDeBruijn -> Kin -> DTyp -> DTyp
[dtName] :: DTyp -> NamedTyDeBruijn
[dtKind] :: DTyp -> Kin
[dtBody] :: DTyp -> DTyp
DTForall :: NamedTyDeBruijn -> Kin -> DTyp -> DTyp
[dtName] :: DTyp -> NamedTyDeBruijn
[dtKind] :: DTyp -> Kin
[dtBody] :: DTyp -> DTyp
DTWk :: Weakening -> DTyp -> DTyp
[dtWk] :: DTyp -> Weakening
[dtBody] :: DTyp -> DTyp
DTyBuiltin :: Kin -> DTyp
data DArg
TyArg :: DTyp -> DArg
DArg :: Dom -> DArg
newtype Weakening
Wk :: [(Index, Index)] -> Weakening
wkIndex :: HasCallStack => Weakening -> Index -> Index
wkBy :: HasCallStack => Index -> Weakening
shiftWeakening :: HasCallStack => Weakening -> Weakening
topLevelLocations :: HasCallStack => Dom -> Set CoverageAnnotation
instance GHC.Generics.Generic (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance Data.Traversable.Traversable Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance Data.Foldable.Foldable Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance GHC.Base.Functor Plutus.Contract.Test.Coverage.Analysis.Types.SnocList
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance GHC.Generics.Generic Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance GHC.Show.Show Plutus.Contract.Test.Coverage.Analysis.Types.DArg
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance GHC.Base.Semigroup (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance GHC.Base.Monoid (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)

module Plutus.Contract.Test.Coverage.Analysis.Pretty
class Pretty a
pretty :: Pretty a => a -> Doc
prettyPrec :: Pretty a => Int -> a -> Doc
(<?>) :: Doc -> Doc -> Doc
pParen :: Bool -> Doc -> Doc
type PrettyTm tyname name uni fun = (Eq tyname, Pretty tyname, Pretty name, Pretty (SomeTypeIn uni), Pretty (Some (ValueOf uni)), Pretty fun)
type PrettyTy tyname uni = (Eq tyname, Pretty tyname, Pretty (SomeTypeIn uni))
ppTyBind :: Pretty tyname => (tyname, Kind ann) -> Doc
ppAbstr :: Pretty b => Int -> (arg -> Doc) -> Doc -> ([arg], b) -> Doc
ppApp :: PrettyTm tyname name uni fun => Int -> Term tyname name uni fun ann -> Doc
ppApp' :: PrettyTm tyname name uni fun => Int -> Doc -> [Either (Type tyname uni ann) (Term tyname name uni fun ann)] -> Doc
viewApp :: Term tyname name uni fun ann -> (Term tyname name uni fun ann, [Either (Type tyname uni ann) (Term tyname name uni fun ann)])
ppSubst :: Pretty a => Subst a -> Doc
angles :: Doc -> Doc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Test.QuickCheck.Modifiers.NonNegative a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.Type tyname uni ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.TyDecl tyname uni ann)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTy tyname uni, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.VarDecl tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Program tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Binding tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Datatype tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.PrettyTm tyname name uni fun => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusIR.Core.Type.Term tyname name uni fun ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Data.Text.Internal.Text
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusTx.Code.CompiledCode a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Universe.Core.SomeTypeIn PlutusCore.Default.Universe.DefaultUni)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf PlutusCore.Default.Universe.DefaultUni))
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Default.Builtins.DefaultFun
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Name.Name
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.Name.TyName
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.NamedTyDeBruijn
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CoverageAnnotation
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CovLoc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.Kind ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty tyname => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (PlutusCore.Core.Type.TyVarDecl tyname ann)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Set.Internal.Set a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty [a]
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Plutus.Contract.Test.Coverage.Analysis.Types.SnocList a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.TyCtxEntry
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DDat
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DCon
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DTyp
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.DArg
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Types.Int
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusCore.DeBruijn.Internal.Index
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.Weakening
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty b) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (a, b)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty b, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty c) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (a, b, c)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Plutus.Contract.Test.Coverage.Analysis.Types.Dom
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty PlutusTx.Coverage.CoverageIndex
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty k, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty v) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Map.Internal.Map k v)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty Text.PrettyPrint.HughesPJ.Doc
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Base.String
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty GHC.Types.Bool
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty a => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (GHC.Maybe.Maybe a)
instance Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty ()
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf uni)), Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty fun) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (UntypedPlutusCore.Core.Type.Program name uni fun ann)
instance (Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty name, Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (Data.Some.Newtype.Some (Universe.Core.ValueOf uni)), Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty fun) => Plutus.Contract.Test.Coverage.Analysis.Pretty.Pretty (UntypedPlutusCore.Core.Type.Term name uni fun ann)

module Plutus.Contract.Test.Coverage.Analysis.Interpreter
allNonFailLocations :: HasCallStack => CompiledCodeIn DefaultUni DefaultFun a -> Set CoverageAnnotation

module Plutus.Contract.Test.Coverage.Analysis
computeRefinedCoverageIndex :: CompiledCodeIn DefaultUni DefaultFun a -> CoverageIndex
refinedCoverageIndex :: Q Exp

module Plutus.Contract.Test.Coverage.ReportCoverage
writeCoverageReport :: String -> CoverageReport -> IO ()
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Show.Show Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Classes.Eq Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Classes.Ord Plutus.Contract.Test.Coverage.ReportCoverage.Swipe
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.Status
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.IgnoreStatus
instance GHC.Base.Semigroup Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus
instance GHC.Base.Monoid Plutus.Contract.Test.Coverage.ReportCoverage.CoverStatus

module Plutus.Contract.Test.MissingLovelace

-- | Returns the calculated delta between initial and final values. Might
--   be false positive.
--   
--   The tests check if a wallet's funds are equal to some expected value
--   at the end. Unfortunately, because of the adjustion of transactions,
--   the outputs' costs change and it's hard to track these changes in the
--   tests layer.
--   
--   This function tries to check if the difference between final and
--   initial values (<tt>realDelta</tt>) is a result of combination of
--   operations between output's costs and the expected delta.
--   
--   There is a risk when expected delta has only ada part and expected
--   delta /= realDelta and realDelta is divisible by some delta from
--   deltas, then we will return realDelta's ada. Which means that the test
--   will pass but without strong confidence in wallets' funds consistency.
--   For example, we expected -n, but there is n among deltas and realDelta
--   is n, it is divisible by n, then the test will pass. So please be
--   careful.
calculateDelta :: Value -> Lovelace -> Lovelace -> [Lovelace] -> Value

module Plutus.Contract.Util

-- | A monadic version of <tt>loop</tt>, where the predicate returns
--   <a>Left</a> as a seed for the next loop or <a>Right</a> to abort the
--   loop.
--   
--   
--   <a>https://hackage.haskell.org/package/extra-1.6.15/docs/src/Control.Monad.Extra.html#loopM</a>
loopM :: Monad m => (a -> m (Either a b)) -> a -> m b

-- | Repeatedly evaluate the action until it yields <a>Nothing</a>, then
--   return the aggregated result.
foldMaybe :: Monad m => (a -> b -> b) -> b -> m (Maybe a) -> m b

-- | Monadic version of <a>&lt;*</a>
finally :: Monad m => m a -> m b -> m a
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

module Plutus.Trace.Tag

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
newtype Tag
Tag :: Text -> Tag
[unTag] :: Tag -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Tag.Tag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Tag.Tag
instance Data.String.IsString Plutus.Trace.Tag.Tag
instance GHC.Generics.Generic Plutus.Trace.Tag.Tag
instance GHC.Show.Show Plutus.Trace.Tag.Tag
instance GHC.Classes.Ord Plutus.Trace.Tag.Tag
instance GHC.Classes.Eq Plutus.Trace.Tag.Tag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Tag.Tag

module Plutus.Trace.Scheduler

-- | Unique identifier of a thread.
data ThreadId
type SysCall effs systemEvent a = Either (MessageCall systemEvent) (ThreadCall effs systemEvent a)

-- | Sending messages to other threads and waiting for new messages to
--   arrive.
data MessageCall systemEvent

-- | Suspend ourselves (the caller) until we receive a message
WaitForMessage :: MessageCall systemEvent

-- | Send a message to all threads
Broadcast :: systemEvent -> MessageCall systemEvent

-- | Send a message to a specific thread
Message :: ThreadId -> systemEvent -> MessageCall systemEvent

-- | The system calls we can make to the scheduler, affecting the the
--   threads that are currently running.
data ThreadCall effs systemEvent a

-- | Start a new thread with a new thread ID.
Fork :: (ThreadId -> SuspendedThread effs systemEvent a) -> ThreadCall effs systemEvent a

-- | Unfreeze a thread.
Thaw :: ThreadId -> ThreadCall effs systemEvent a

-- | Terminate the scheduler.
Exit :: a -> ThreadCall effs systemEvent a

-- | A thread with a <a>Priority</a>.
data WithPriority t
WithPriority :: Priority -> t -> WithPriority t
[_priority] :: WithPriority t -> Priority
[_thread] :: WithPriority t -> t

-- | Priority of a thread.
data Priority

-- | Thread is ready to run
Normal :: Priority

-- | Thread is sleeping, to be resumed only after an external event happens
Sleeping :: Priority

-- | Thread is frozen, it will only be resumed after it is manually
--   unfrozen via the <a>Thaw</a> sys call.
Frozen :: Priority

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
data Tag
type EmSystemCall effs systemEvent a = WithPriority (SysCall effs systemEvent a)
type AgentSystemCall systemEvent = WithPriority (MessageCall systemEvent)
type SuspendedThread effs systemEvent a = WithPriority (EmThread effs systemEvent a)

-- | Thread that can be run by the scheduler
data EmThread effs systemEvent a
EmThread :: (Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent a) (Maybe systemEvent) ())) -> ThreadId -> Tag -> EmThread effs systemEvent a

-- | The continuation to be run when the thread is resumed.
[_continuation] :: EmThread effs systemEvent a -> Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent a) (Maybe systemEvent) ())

-- | Thread ID
[_threadId] :: EmThread effs systemEvent a -> ThreadId

-- | Tag of the thread. See note [Thread Tag]
[_tag] :: EmThread effs systemEvent a -> Tag

-- | Scheduler state
data SchedulerState effs systemEvent a
SchedulerState :: Seq (EmThread effs systemEvent a) -> Seq (EmThread effs systemEvent a) -> Seq (EmThread effs systemEvent a) -> ThreadId -> HashMap ThreadId (Seq systemEvent) -> Map Tag (HashSet ThreadId) -> SchedulerState effs systemEvent a

-- | Threads running at normal priority
[_normalPrio] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Sleeping threads (waiting for an external event)
[_sleeping] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Frozen threads (will not be resumed until they are explicitly
--   unfrozen)
[_frozen] :: SchedulerState effs systemEvent a -> Seq (EmThread effs systemEvent a)

-- | Last thread id assigned to a thread
[_lastThreadId] :: SchedulerState effs systemEvent a -> ThreadId

-- | The mailboxes of all active threads.
[_mailboxes] :: SchedulerState effs systemEvent a -> HashMap ThreadId (Seq systemEvent)

-- | Map of tags to thread IDs. See note [Thread Tag]
[_activeThreads] :: SchedulerState effs systemEvent a -> Map Tag (HashSet ThreadId)

-- | Handle the 'Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)'
--   effect using the scheduler, see note [Scheduler]. <a>runThreads</a>
--   only returns when all threads are finished, returning <a>Nothing</a>,
--   or when <a>exit</a> is called, in which case the value passed to
--   <a>exit</a> is returned.
runThreads :: forall a effs systemEvent. (Eq systemEvent, Member (LogMsg SchedulerLog) effs) => Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> Eff effs (Maybe a)

-- | Start a new thread
fork :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> Eff effs2 (Maybe systemEvent)

-- | Suspend the current thread
sleep :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Priority -> Eff effs2 (Maybe systemEvent)

-- | Stop the scheduler and let it return with the given value.
exit :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => a -> Eff effs2 (Maybe systemEvent)

-- | Make a thread with the given priority from an action. This is a
--   convenience for defining <tt>SimulatorInterpreter</tt> values.
mkThread :: Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent) : effs)) () -> ThreadId -> SuspendedThread effs systemEvent a

-- | Make a system call
mkSysCall :: forall effs systemEvent effs2 a. Member (Yield (EmSystemCall effs systemEvent a) (Maybe systemEvent)) effs2 => Priority -> SysCall effs systemEvent a -> Eff effs2 (Maybe systemEvent)

-- | Make a <a>MessageCall</a> system call for some agent
mkAgentSysCall :: forall effs systemEvent. Member (Yield (AgentSystemCall systemEvent) (Maybe systemEvent)) effs => Priority -> MessageCall systemEvent -> Eff effs (Maybe systemEvent)
data SchedulerLog
SchedulerLog :: ThreadEvent -> ThreadId -> Tag -> Priority -> SchedulerLog
[slEvent] :: SchedulerLog -> ThreadEvent
[slThread] :: SchedulerLog -> ThreadId
[slTag] :: SchedulerLog -> Tag
[slPrio] :: SchedulerLog -> Priority
data ThreadEvent
Stopped :: ThreadEvent
Resumed :: ThreadEvent
Suspended :: ThreadEvent
Started :: ThreadEvent
Thawed :: ThreadEvent
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Classes.Ord Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.SchedulerLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Generics.Generic Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Show.Show Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Classes.Eq Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Hashable.Class.Hashable Plutus.Trace.Scheduler.ThreadId
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadId
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Ord Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadId
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.Priority
instance GHC.Generics.Generic Plutus.Trace.Scheduler.Priority
instance GHC.Show.Show Plutus.Trace.Scheduler.Priority
instance GHC.Classes.Eq Plutus.Trace.Scheduler.Priority
instance GHC.Base.Functor Plutus.Trace.Scheduler.WithPriority

module Wallet.Emulator.Error

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The change when selecting coins contains less than the minimum amount
--   of Ada.
ChangeHasLessThanNAda :: Value -> Ada -> WalletAPIError

-- | The wallet doesn't have any payment key hash, which should not be
--   possible.
NoPaymentPubKeyHashError :: WalletAPIError

-- | The private key of this public key hash is not known to the wallet.
PaymentPrivateKeyNotFound :: PaymentPubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | There was an error while converting to Cardano.API format.
ToCardanoError :: ToCardanoError -> WalletAPIError

-- | There was an error while creating a payment transaction
PaymentMkTxError :: MkTxError -> WalletAPIError

-- | The called wallet effect is not yet supported in a remote wallet
--   client scenario.
RemoteClientFunctionNotYetSupported :: Text -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
instance GHC.Generics.Generic Wallet.Emulator.Error.WalletAPIError
instance GHC.Classes.Eq Wallet.Emulator.Error.WalletAPIError
instance GHC.Show.Show Wallet.Emulator.Error.WalletAPIError
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Error.WalletAPIError


-- | The log messages produced by the emulator.
module Wallet.Emulator.LogMessages
data RequestHandlerLogMsg
SlotNoticationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
StartWatchingContractAddresses :: RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
UtxoAtFailed :: Address -> RequestHandlerLogMsg
AdjustingUnbalancedTx :: [Lovelace] -> RequestHandlerLogMsg
data TxBalanceMsg
BalancingUnbalancedTx :: CardanoBuildTx -> UtxoIndex -> TxBalanceMsg
FinishedBalancing :: CardanoTx -> TxBalanceMsg
SigningTx :: CardanoTx -> TxBalanceMsg
SubmittingTx :: CardanoTx -> TxBalanceMsg
ValidationFailed :: ValidationPhase -> CardanoTx -> ValidationError -> Value -> TxBalanceMsg
_AdjustingUnbalancedTx :: Prism' RequestHandlerLogMsg [Lovelace]
_BalancingUnbalancedTx :: Prism' TxBalanceMsg (CardanoBuildTx, UtxoIndex)
_ValidationFailed :: Prism' TxBalanceMsg (ValidationPhase, CardanoTx, ValidationError, Value)
instance Prettyprinter.Internal.Pretty Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Generics.Generic Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Show.Show Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Classes.Eq Wallet.Emulator.LogMessages.RequestHandlerLogMsg

module Wallet.Error

module Wallet.Effects
data WalletEffect r
[SubmitTxn] :: CardanoTx -> WalletEffect ()
[OwnAddresses] :: WalletEffect (NonEmpty CardanoAddress)
[BalanceTx] :: UnbalancedTx -> WalletEffect (Either WalletAPIError CardanoTx)

-- | <i>Deprecated: We won't use the wallet for querying blockchain
--   information. See
--   <a>https://plutus-apps.readthedocs.io/en/latest/adr/0005-pab-indexing-solution-integration.html</a></i>
[TotalFunds] :: WalletEffect Value
[WalletAddSignature] :: CardanoTx -> WalletEffect CardanoTx

-- | Sends an unbalanced tx to be balanced, signed and submitted.
[YieldUnbalancedTx] :: UnbalancedTx -> WalletEffect ()
submitTxn :: forall effs_a2E42. Member WalletEffect effs_a2E42 => CardanoTx -> Eff effs_a2E42 ()
ownAddresses :: forall effs_a2E43. Member WalletEffect effs_a2E43 => Eff effs_a2E43 (NonEmpty CardanoAddress)
balanceTx :: forall effs_a2E44. Member WalletEffect effs_a2E44 => UnbalancedTx -> Eff effs_a2E44 (Either WalletAPIError CardanoTx)
totalFunds :: forall effs_a2E45. Member WalletEffect effs_a2E45 => Eff effs_a2E45 Value
walletAddSignature :: forall effs_a2E46. Member WalletEffect effs_a2E46 => CardanoTx -> Eff effs_a2E46 CardanoTx
yieldUnbalancedTx :: forall effs_a2E47. Member WalletEffect effs_a2E47 => UnbalancedTx -> Eff effs_a2E47 ()
data NodeClientEffect r
[PublishTx] :: CardanoTx -> NodeClientEffect ()
[GetClientSlot] :: NodeClientEffect Slot
[GetClientParams] :: NodeClientEffect Params
publishTx :: forall effs_a2E7w. Member NodeClientEffect effs_a2E7w => CardanoTx -> Eff effs_a2E7w ()
getClientSlot :: forall effs_a2E7x. Member NodeClientEffect effs_a2E7x => Eff effs_a2E7x Slot
getClientParams :: forall effs_a2E7y. Member NodeClientEffect effs_a2E7y => Eff effs_a2E7y Params

module Wallet.Emulator.NodeClient
data NodeClientEvent

-- | A transaction has been added to the pool of pending transactions. The
--   value is the fee of the transaction.
TxSubmit :: TxId -> Lovelace -> NodeClientEvent
_TxSubmit :: Iso' NodeClientEvent (TxId, Lovelace)
data NodeClientState
NodeClientState :: Slot -> AddressMap -> NodeClientState
[_clientSlot] :: NodeClientState -> Slot

-- | Full index
[_clientIndex] :: NodeClientState -> AddressMap
emptyNodeClientState :: NodeClientState
clientSlot :: Lens' NodeClientState Slot
clientIndex :: Lens' NodeClientState AddressMap
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
data NodeClientControlEffect r
[ClientNotify] :: ChainClientNotification -> NodeClientControlEffect ()
clientNotify :: forall effs_a2EEo. Member NodeClientControlEffect effs_a2EEo => ChainClientNotification -> Eff effs_a2EEo ()
type NodeClientEffs = '[ChainEffect, State NodeClientState, LogMsg NodeClientEvent]
handleNodeControl :: Members NodeClientEffs effs => Eff (NodeClientControlEffect : effs) ~> Eff effs
handleNodeClient :: Members NodeClientEffs effs => Eff (NodeClientEffect : effs) ~> Eff effs
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Show.Show Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientState
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientState
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Generics.Generic Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientEvent
instance Prettyprinter.Internal.Pretty Wallet.Emulator.NodeClient.NodeClientEvent

module Wallet.Emulator.Wallet
newtype SigningProcess
SigningProcess :: (forall effs. Member (Error WalletAPIError) effs => [PaymentPubKeyHash] -> CardanoTx -> Eff effs CardanoTx) -> SigningProcess
[unSigningProcess] :: SigningProcess -> forall effs. Member (Error WalletAPIError) effs => [PaymentPubKeyHash] -> CardanoTx -> Eff effs CardanoTx

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId
toMockWallet :: MockWallet -> Wallet
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet
fromWalletNumber :: WalletNumber -> Wallet
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[unWalletId] :: WalletId -> Digest Blake2b_160
toBase16 :: WalletId -> Text
fromBase16 :: Text -> Either String WalletId

-- | The <a>MockWallet</a> whose ID is the given wallet ID (if it exists)
walletToMockWallet :: Wallet -> Maybe MockWallet

-- | The same as <tt>walletToMockWallet</tt> but fails with an error
--   instead of returning <tt>Nothing</tt>.
walletToMockWallet' :: Wallet -> MockWallet

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress
data WalletEvent
GenericLog :: Text -> WalletEvent
CheckpointLog :: CheckpointLogMsg -> WalletEvent
RequestHandlerLog :: RequestHandlerLogMsg -> WalletEvent
TxBalanceLog :: TxBalanceMsg -> WalletEvent
_TxBalanceLog :: Prism' WalletEvent TxBalanceMsg
_RequestHandlerLog :: Prism' WalletEvent RequestHandlerLogMsg
_CheckpointLog :: Prism' WalletEvent CheckpointLogMsg
_GenericLog :: Prism' WalletEvent Text

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: MockWallet -> NodeClientState -> ChainIndexEmulatorState -> Maybe SigningProcess -> WalletState

-- | Mock wallet with the user's private key.
[_mockWallet] :: WalletState -> MockWallet

-- | The representation of the node, as known by the wallet
[_nodeClient] :: WalletState -> NodeClientState

-- | the chain index info known by the wallet
[_chainIndexEmulatorState] :: WalletState -> ChainIndexEmulatorState

-- | Override the signing process. Used for testing multi-agent use cases.
[_signingProcess] :: WalletState -> Maybe SigningProcess
signingProcess :: Lens' WalletState (Maybe SigningProcess)
nodeClient :: Lens' WalletState NodeClientState
mockWallet :: Lens' WalletState MockWallet
chainIndexEmulatorState :: Lens' WalletState ChainIndexEmulatorState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey
ownPaymentPublicKey :: WalletState -> PaymentPubKey

-- | Get the user's own payment public-key address.
ownAddress :: WalletState -> CardanoAddress

-- | An empty wallet using the given private key. for that wallet as the
--   sole watched address.
fromMockWallet :: MockWallet -> WalletState

-- | Empty wallet state for an emulator <a>Wallet</a>. Returns
--   <a>Nothing</a> if the wallet is not known in the emulator.
emptyWalletState :: Wallet -> Maybe WalletState
handleWallet :: (Member (Error WalletAPIError) effs, Member NodeClientEffect effs, Member ChainIndexQueryEffect effs, Member (State WalletState) effs, Member (LogMsg TxBalanceMsg) effs) => WalletEffect ~> Eff effs
handleBalance :: (Member NodeClientEffect effs, Member ChainIndexQueryEffect effs, Member (State WalletState) effs, Member (LogMsg TxBalanceMsg) effs, Member (Error WalletAPIError) effs) => UnbalancedTx -> Eff effs CardanoTx
handleAddSignature :: (Member (State WalletState) effs, Member (Error WalletAPIError) effs) => CardanoTx -> Eff effs CardanoTx
ownOutputs :: forall effs. (Member ChainIndexQueryEffect effs, Member (State WalletState) effs, Member NodeClientEffect effs, Member (Error WalletAPIError) effs) => Eff effs UtxoIndex

-- | The default signing process is <a>signWallet</a>
defaultSigningProcess :: MockWallet -> SigningProcess
signWithPrivateKey :: PaymentPrivateKey -> SigningProcess

-- | Sign the transaction by calling <a>signTxnWithKey</a> (throwing a
--   <tt>PrivateKeyNotFound</tt> error if called with a key other than the
--   wallet's private key)
signWallet :: MockWallet -> SigningProcess

-- | Sign the transaction with the private key of the mock wallet.
signTxnWithKey :: Member (Error WalletAPIError) r => MockWallet -> CardanoTx -> PaymentPubKeyHash -> Eff r CardanoTx

-- | Sign the transaction with the private key, if the hash is that of the
--   private key.
signTxWithPrivateKey :: Member (Error WalletAPIError) r => PaymentPrivateKey -> CardanoTx -> PaymentPubKeyHash -> Eff r CardanoTx

-- | Sign the transaction with the given private keys, ignoring the list of
--   public keys that the <a>SigningProcess</a> is passed.
signPrivateKeys :: [PaymentPrivateKey] -> SigningProcess
data SigningProcessControlEffect r
[SetSigningProcess] :: Maybe SigningProcess -> SigningProcessControlEffect ()
setSigningProcess :: forall effs_a2WiD. Member SigningProcessControlEffect effs_a2WiD => Maybe SigningProcess -> Eff effs_a2WiD ()
type SigningProcessEffs = '[State (Maybe SigningProcess), Error WalletAPIError]
handleSigningProcessControl :: Members SigningProcessEffs effs => Eff (SigningProcessControlEffect : effs) ~> Eff effs

-- | An Entity is a thing that can hold <a>Value</a>. Used in the
--   <a>balances</a> function to compute who holds for a given chain state
--   and set of wallets.
data Entity
WalletEntity :: Wallet -> Entity
PubKeyHashEntity :: PubKeyHash -> Entity
ScriptEntity :: ValidatorHash -> Entity
type WalletSet = Map Wallet WalletState

-- | Pick out all the public keys from the set of wallets and map them back
--   to their corresponding wallets.
walletPaymentPubKeyHashes :: WalletSet -> Map PaymentPubKeyHash Wallet

-- | For a set of wallets, convert them into a map of value: entity, where
--   entity is one of <a>Entity</a>.
balances :: ChainState -> WalletSet -> Map Entity Value
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Entity
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletState
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Wallet.WalletId
instance Data.Data.Data Wallet.Emulator.Wallet.WalletId
instance GHC.Generics.Generic Wallet.Emulator.Wallet.WalletId
instance GHC.Classes.Ord Wallet.Emulator.Wallet.WalletId
instance GHC.Classes.Eq Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.Wallet
instance Data.Data.Data Wallet.Emulator.Wallet.Wallet
instance GHC.Generics.Generic Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.WalletEvent
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.WalletEvent
instance GHC.Generics.Generic Wallet.Emulator.Wallet.WalletEvent
instance GHC.Classes.Eq Wallet.Emulator.Wallet.WalletEvent
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletEvent
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.WalletEvent
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Wallet
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Wallet.Wallet
instance GHC.Show.Show Wallet.Emulator.Wallet.Wallet
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.Wallet
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.WalletId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.WalletId
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Wallet.WalletId
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Wallet.WalletId
instance GHC.Show.Show Wallet.Emulator.Wallet.SigningProcess


-- | Mock wallet implementation
module Wallet.API
data WalletEffect r
submitTxn :: forall effs_a2E42. Member WalletEffect effs_a2E42 => CardanoTx -> Eff effs_a2E42 ()

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs) => Eff effs PaymentPubKeyHash
ownPaymentPubKeyHashes :: Member WalletEffect effs => Eff effs [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs) => Eff effs PaymentPubKeyHash
ownAddresses :: forall effs_a2E43. Member WalletEffect effs_a2E43 => Eff effs_a2E43 (NonEmpty CardanoAddress)
balanceTx :: forall effs_a2E44. Member WalletEffect effs_a2E44 => UnbalancedTx -> Eff effs_a2E44 (Either WalletAPIError CardanoTx)
yieldUnbalancedTx :: forall effs_a2E47. Member WalletEffect effs_a2E47 => UnbalancedTx -> Eff effs_a2E47 ()
data NodeClientEffect r
publishTx :: forall effs_a2E7w. Member NodeClientEffect effs_a2E7w => CardanoTx -> Eff effs_a2E7w ()
getClientSlot :: forall effs_a2E7x. Member NodeClientEffect effs_a2E7x => Eff effs_a2E7x Slot
getClientParams :: forall effs_a2E7y. Member NodeClientEffect effs_a2E7y => Eff effs_a2E7y Params
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes
newtype PubKeyHash
PubKeyHash :: BuiltinByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> BuiltinByteString

-- | Add the wallet's signature to the transaction and submit it. Returns
--   the transaction with the wallet's signature.
signTxAndSubmit :: Member WalletEffect effs => CardanoTx -> Eff effs CardanoTx

-- | A version of <a>signTxAndSubmit</a> that discards the result.
signTxAndSubmit_ :: Member WalletEffect effs => CardanoTx -> Eff effs ()

-- | Transfer some funds to an address, returning the transaction that was
--   submitted.
--   
--   Note: Due to a constraint in the Cardano ledger, each tx output must
--   have a minimum amount of Ada. Therefore, the funds to transfer will be
--   adjusted to satisfy that constraint. See <a>adjustUnbalancedTx</a>.
payToAddress :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> Address -> Eff effs CardanoTx

-- | Transfer some funds to an address.
payToAddress_ :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> Address -> Eff effs ()

-- | Transfer some funds to an address locked by a public key, returning
--   the transaction that was submitted.
--   
--   Note: Due to a constraint in the Cardano ledger, each tx output must
--   have a minimum amount of Ada. Therefore, the funds to transfer will be
--   adjusted to satisfy that constraint. See <a>adjustUnbalancedTx</a>.
payToPaymentPublicKeyHash :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> PaymentPubKeyHash -> Eff effs CardanoTx

-- | Transfer some funds to an address locked by a public key.
payToPaymentPublicKeyHash_ :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member (LogMsg Text) effs, Member (LogMsg RequestHandlerLogMsg) effs) => Params -> SlotRange -> Value -> PaymentPubKeyHash -> Eff effs ()
data Params
Params :: !SlotConfig -> !PParams -> !NetworkId -> Params
[pSlotConfig] :: Params -> !SlotConfig
[emulatorPParams] :: Params -> !PParams
[pNetworkId] :: Params -> !NetworkId
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a
data Slot
type SlotRange = Interval Slot
width :: SlotRange -> Maybe Integer

-- | The default slot validity range for transactions.
defaultSlotRange :: SlotRange
interval :: a -> a -> Interval a
singleton :: a -> Interval a
isEmpty :: (Enum a, Ord a) => Interval a -> Bool
always :: Interval a
member :: Ord a => a -> Interval a -> Bool
before :: Ord a => a -> Interval a -> Bool
after :: Ord a => a -> Interval a -> Bool
contains :: Ord a => Interval a -> Interval a -> Bool

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The change when selecting coins contains less than the minimum amount
--   of Ada.
ChangeHasLessThanNAda :: Value -> Ada -> WalletAPIError

-- | The wallet doesn't have any payment key hash, which should not be
--   possible.
NoPaymentPubKeyHashError :: WalletAPIError

-- | The private key of this public key hash is not known to the wallet.
PaymentPrivateKeyNotFound :: PaymentPubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | There was an error while converting to Cardano.API format.
ToCardanoError :: ToCardanoError -> WalletAPIError

-- | There was an error while creating a payment transaction
PaymentMkTxError :: MkTxError -> WalletAPIError

-- | The called wallet effect is not yet supported in a remote wallet
--   client scenario.
RemoteClientFunctionNotYetSupported :: Text -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a

module Wallet


-- | Support for visualisation of a blockchain as a graph.
module Wallet.Graph

-- | Compute the <a>FlowLink</a>s for a <a>Blockchain</a> given a set of
--   known <a>PubKey</a>s.
txnFlows :: [PubKey] -> Blockchain -> [FlowLink]

-- | Construct a graph from a list of <a>FlowLink</a>s.
graph :: [FlowLink] -> FlowGraph

-- | The flow graph, consisting of a set of nodes (<a>TxRef</a>s) and edges
--   (<a>FlowLink</a>s).
data FlowGraph

-- | A link in the flow graph.
data FlowLink

-- | A wrapper around the first 8 digits of a <a>TxId</a>.
data TxRef

-- | The owner of an unspent transaction output.
data UtxOwner

-- | The location of a transaction in a blockchain specified by two
--   indices: the index of the containing block in the chain, and the index
--   of the transaction within the block.
data UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.UtxOwner
instance GHC.Show.Show Wallet.Graph.UtxOwner
instance GHC.Classes.Ord Wallet.Graph.UtxOwner
instance GHC.Classes.Eq Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.TxRef
instance GHC.Show.Show Wallet.Graph.TxRef
instance GHC.Classes.Ord Wallet.Graph.TxRef
instance GHC.Classes.Eq Wallet.Graph.TxRef
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxoLocation
instance GHC.Generics.Generic Wallet.Graph.UtxoLocation
instance GHC.Show.Show Wallet.Graph.UtxoLocation
instance GHC.Classes.Ord Wallet.Graph.UtxoLocation
instance GHC.Classes.Eq Wallet.Graph.UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowLink
instance GHC.Generics.Generic Wallet.Graph.FlowLink
instance GHC.Show.Show Wallet.Graph.FlowLink
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowGraph
instance GHC.Generics.Generic Wallet.Graph.FlowGraph
instance GHC.Show.Show Wallet.Graph.FlowGraph
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.TxRef

module Wallet.Rollup.Types
data SequenceId
SequenceId :: Int -> Int -> SequenceId
[slotIndex] :: SequenceId -> Int
[txIndex] :: SequenceId -> Int
txIndexL :: Lens' SequenceId Int
slotIndexL :: Lens' SequenceId Int
data DereferencedInput
DereferencedInput :: TxIn -> TxOut -> DereferencedInput
[originalInput] :: DereferencedInput -> TxIn
[refersTo] :: DereferencedInput -> TxOut
InputNotFound :: TxIn -> DereferencedInput
isFound :: DereferencedInput -> Bool
data BeneficialOwner
OwnedByPaymentPubKey :: PaymentPubKeyHash -> BeneficialOwner
OwnedByScript :: ValidatorHash -> BeneficialOwner
toBeneficialOwner :: TxOut -> BeneficialOwner
data AnnotatedTx
AnnotatedTx :: SequenceId -> TxId -> CardanoTx -> [DereferencedInput] -> Map BeneficialOwner Value -> Bool -> AnnotatedTx
[sequenceId] :: AnnotatedTx -> SequenceId
[txId] :: AnnotatedTx -> TxId
[tx] :: AnnotatedTx -> CardanoTx
[dereferencedInputs] :: AnnotatedTx -> [DereferencedInput]
[balances] :: AnnotatedTx -> Map BeneficialOwner Value
[valid] :: AnnotatedTx -> Bool
data Rollup
Rollup :: Map TxIn TxOut -> Map BeneficialOwner Value -> Rollup
[_previousOutputs] :: Rollup -> Map TxIn TxOut
[_rollingBalances] :: Rollup -> Map BeneficialOwner Value
rollingBalances :: Lens' Rollup (Map BeneficialOwner Value)
previousOutputs :: Lens' Rollup (Map TxIn TxOut)
data RollupState
RollupState :: SequenceId -> Rollup -> [AnnotatedTx] -> RollupState
[_currentSequenceId] :: RollupState -> SequenceId
[_rollup] :: RollupState -> Rollup
[_annotatedTransactions] :: RollupState -> [AnnotatedTx]
rollup :: Lens' RollupState Rollup
currentSequenceId :: Lens' RollupState SequenceId
annotatedTransactions :: Lens' RollupState [AnnotatedTx]
instance GHC.Generics.Generic Wallet.Rollup.Types.Rollup
instance GHC.Classes.Eq Wallet.Rollup.Types.Rollup
instance GHC.Show.Show Wallet.Rollup.Types.Rollup
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.DereferencedInput
instance GHC.Generics.Generic Wallet.Rollup.Types.DereferencedInput
instance GHC.Show.Show Wallet.Rollup.Types.DereferencedInput
instance GHC.Classes.Eq Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.BeneficialOwner
instance GHC.Generics.Generic Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Ord Wallet.Rollup.Types.BeneficialOwner
instance GHC.Show.Show Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Eq Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.AnnotatedTx
instance GHC.Generics.Generic Wallet.Rollup.Types.AnnotatedTx
instance GHC.Show.Show Wallet.Rollup.Types.AnnotatedTx
instance GHC.Classes.Eq Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.SequenceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.SequenceId
instance GHC.Generics.Generic Wallet.Rollup.Types.SequenceId
instance GHC.Show.Show Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Ord Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Eq Wallet.Rollup.Types.SequenceId

module Wallet.Rollup
doAnnotateBlockchain :: Monad m => Blockchain -> m [[AnnotatedTx]]
initialRollup :: Rollup
annotateBlockchain :: Monad m => Blockchain -> StateT Rollup m [[AnnotatedTx]]
data Rollup
initialState :: RollupState
handleChainEvent :: RollupState -> ChainEvent -> RollupState
getAnnotatedTransactions :: RollupState -> [[AnnotatedTx]]


-- | Defines a number of types that are used in Wallet.XXX modules
module Wallet.Types

-- | Unique ID for contract instance
newtype ContractInstanceId
ContractInstanceId :: UUID -> ContractInstanceId
[unContractInstanceId] :: ContractInstanceId -> UUID

-- | A pure list of all <a>ContractInstanceId</a> values. To be used in
--   testing.
contractInstanceIDs :: [ContractInstanceId]
randomID :: IO ContractInstanceId
data ContractActivityStatus
Active :: ContractActivityStatus
Stopped :: ContractActivityStatus
Done :: ContractActivityStatus
parseContractActivityStatus :: Text -> Maybe ContractActivityStatus
data Notification
Notification :: ContractInstanceId -> EndpointDescription -> Value -> Notification
[notificationContractID] :: Notification -> ContractInstanceId
[notificationContractEndpoint] :: Notification -> EndpointDescription
[notificationContractArg] :: Notification -> Value
data NotificationError
EndpointNotAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
MoreThanOneEndpointAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
InstanceDoesNotExist :: ContractInstanceId -> NotificationError

-- | Indicates that the target contract does not have the expected schema
--   
--   TODO: SCP-2137 Not currently used. As endpoint parameter decoding
--   happends inside the Contract and a throwError is used is decoding
--   failed. However, still valuable to be used by the PAB to throw an
--   error is an endpoint could not be decoded.
NotificationJSONDecodeError :: EndpointDescription -> Value -> String -> NotificationError
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
newtype EndpointValue a
EndpointValue :: a -> EndpointValue a
[unEndpointValue] :: EndpointValue a -> a
instance Wallet.Types.AsNotificationError Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Types.ContractInstanceId
instance GHC.Generics.Generic Wallet.Types.ContractInstanceId
instance GHC.Show.Show Wallet.Types.ContractInstanceId
instance GHC.Classes.Ord Wallet.Types.ContractInstanceId
instance GHC.Classes.Eq Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractActivityStatus
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractActivityStatus
instance GHC.Generics.Generic Wallet.Types.ContractActivityStatus
instance GHC.Show.Show Wallet.Types.ContractActivityStatus
instance GHC.Classes.Eq Wallet.Types.ContractActivityStatus
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.EndpointDescription
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.EndpointDescription
instance Prettyprinter.Internal.Pretty Wallet.Types.EndpointDescription
instance Data.String.IsString Wallet.Types.EndpointDescription
instance Language.Haskell.TH.Syntax.Lift Wallet.Types.EndpointDescription
instance GHC.Show.Show Wallet.Types.EndpointDescription
instance GHC.Generics.Generic Wallet.Types.EndpointDescription
instance GHC.Classes.Ord Wallet.Types.EndpointDescription
instance GHC.Classes.Eq Wallet.Types.EndpointDescription
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Types.EndpointValue a)
instance GHC.Show.Show a => GHC.Show.Show (Wallet.Types.EndpointValue a)
instance GHC.Generics.Generic (Wallet.Types.EndpointValue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Wallet.Types.EndpointValue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.Notification
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.Notification
instance GHC.Generics.Generic Wallet.Types.Notification
instance GHC.Show.Show Wallet.Types.Notification
instance GHC.Classes.Eq Wallet.Types.Notification
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.NotificationError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.NotificationError
instance GHC.Generics.Generic Wallet.Types.NotificationError
instance GHC.Show.Show Wallet.Types.NotificationError
instance GHC.Classes.Eq Wallet.Types.NotificationError
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Wallet.Types.EndpointValue a)
instance Prettyprinter.Internal.Pretty Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.Notification

module Plutus.Trace.Effects.ContractInstanceId
data ContractInstanceIdEff r
nextId :: forall effs_a3rNw. Member ContractInstanceIdEff effs_a3rNw => Eff effs_a3rNw ContractInstanceId

-- | Handle <a>ContractInstanceIdEff</a> using the list of IDs
--   <a>contractInstanceIDs</a>.
handleDeterministicIds :: Eff (ContractInstanceIdEff : effs) ~> Eff effs

-- | Handle <a>ContractInstanceIdEff</a> using a random number generator
handleRandomIds :: (LastMember m effs, MonadIO m) => Eff (ContractInstanceIdEff : effs) ~> Eff effs

module Plutus.Contract.Effects

-- | Requests that <tt>Contract</tt>s can make
data PABReq
AdjustUnbalancedTxReq :: UnbalancedTx -> PABReq
AwaitSlotReq :: Slot -> PABReq
AwaitTimeReq :: POSIXTime -> PABReq
AwaitUtxoSpentReq :: TxIn -> PABReq
AwaitUtxoProducedReq :: CardanoAddress -> PABReq
AwaitTxStatusChangeReq :: TxId -> PABReq
AwaitTxOutStatusChangeReq :: TxIn -> PABReq
CurrentNodeClientSlotReq :: PABReq
CurrentChainIndexSlotReq :: PABReq
CurrentTimeReq :: PABReq
CurrentNodeClientTimeRangeReq :: PABReq
GetParamsReq :: PABReq
OwnContractInstanceIdReq :: PABReq
OwnAddressesReq :: PABReq
ChainIndexQueryReq :: ChainIndexQuery -> PABReq
BalanceTxReq :: UnbalancedTx -> PABReq
WriteBalancedTxReq :: CardanoTx -> PABReq
ExposeEndpointReq :: ActiveEndpoint -> PABReq
PosixTimeRangeToContainedSlotRangeReq :: POSIXTimeRange -> PABReq
YieldUnbalancedTxReq :: UnbalancedTx -> PABReq
_AdjustUnbalancedTxReq :: Prism' PABReq UnbalancedTx
_AwaitSlotReq :: Prism' PABReq Slot
_AwaitTimeReq :: Prism' PABReq POSIXTime
_AwaitUtxoSpentReq :: Prism' PABReq TxIn
_AwaitUtxoProducedReq :: Prism' PABReq CardanoAddress
_CurrentNodeClientSlotReq :: Prism' PABReq ()
_CurrentChainIndexSlotReq :: Prism' PABReq ()
_CurrentTimeReq :: Prism' PABReq ()
_CurrentNodeClientTimeRangeReq :: Prism' PABReq ()
_AwaitTxStatusChangeReq :: Prism' PABReq TxId
_AwaitTxOutStatusChangeReq :: Prism' PABReq TxIn
_GetParamsReq :: Prism' PABReq ()
_OwnContractInstanceIdReq :: Prism' PABReq ()
_OwnAddressesReq :: Prism' PABReq ()
_ChainIndexQueryReq :: Prism' PABReq ChainIndexQuery
_BalanceTxReq :: Prism' PABReq UnbalancedTx
_WriteBalancedTxReq :: Prism' PABReq CardanoTx
_ExposeEndpointReq :: Prism' PABReq ActiveEndpoint
_PosixTimeRangeToContainedSlotRangeReq :: Prism' PABReq POSIXTimeRange
_YieldUnbalancedTxReq :: Prism' PABReq UnbalancedTx
_DatumFromHash :: Prism' ChainIndexQuery DatumHash
_ValidatorFromHash :: Prism' ChainIndexQuery ValidatorHash
_MintingPolicyFromHash :: Prism' ChainIndexQuery MintingPolicyHash
_RedeemerFromHash :: Prism' ChainIndexQuery RedeemerHash
_TxOutFromRef :: Prism' ChainIndexQuery TxOutRef
_TxFromTxId :: Prism' ChainIndexQuery TxId
_UnspentTxOutFromRef :: Prism' ChainIndexQuery TxOutRef
_UtxoSetMembership :: Prism' ChainIndexQuery TxOutRef
_UtxoSetAtAddress :: Prism' ChainIndexQuery (PageQuery TxOutRef, CardanoAddress)
_UtxoSetWithCurrency :: Prism' ChainIndexQuery (PageQuery TxOutRef, AssetClass)
_TxsFromTxIds :: Prism' ChainIndexQuery [TxId]
_TxoSetAtAddress :: Prism' ChainIndexQuery (PageQuery TxOutRef, CardanoAddress)
_GetTip :: Prism' ChainIndexQuery ()

-- | Responses that <tt>Contract</tt>s receive
data PABResp
AdjustUnbalancedTxResp :: UnbalancedTx -> PABResp
AwaitSlotResp :: Slot -> PABResp
AwaitTimeResp :: POSIXTime -> PABResp
AwaitUtxoSpentResp :: ChainIndexTx -> PABResp
AwaitUtxoProducedResp :: NonEmpty ChainIndexTx -> PABResp
AwaitTxStatusChangeResp :: TxId -> TxStatus -> PABResp
AwaitTxOutStatusChangeResp :: TxIn -> TxOutStatus -> PABResp
CurrentNodeClientSlotResp :: Slot -> PABResp
CurrentChainIndexSlotResp :: Slot -> PABResp
CurrentTimeResp :: POSIXTime -> PABResp
CurrentNodeClientTimeRangeResp :: (POSIXTime, POSIXTime) -> PABResp
GetParamsResp :: Params -> PABResp
OwnContractInstanceIdResp :: ContractInstanceId -> PABResp
OwnAddressesResp :: NonEmpty CardanoAddress -> PABResp
ChainIndexQueryResp :: ChainIndexResponse -> PABResp
BalanceTxResp :: BalanceTxResponse -> PABResp
WriteBalancedTxResp :: WriteBalancedTxResponse -> PABResp
ExposeEndpointResp :: EndpointDescription -> EndpointValue Value -> PABResp
PosixTimeRangeToContainedSlotRangeResp :: Either SlotConversionError SlotRange -> PABResp
YieldUnbalancedTxResp :: () -> PABResp
_AdjustUnbalancedTxResp :: Prism' PABResp UnbalancedTx
_AwaitSlotResp :: Prism' PABResp Slot
_AwaitTimeResp :: Prism' PABResp POSIXTime
_AwaitUtxoSpentResp :: Prism' PABResp ChainIndexTx
_AwaitUtxoProducedResp :: Prism' PABResp (NonEmpty ChainIndexTx)
_CurrentNodeClientSlotResp :: Prism' PABResp Slot
_CurrentChainIndexSlotResp :: Prism' PABResp Slot
_CurrentTimeResp :: Prism' PABResp POSIXTime
_CurrentNodeClientTimeRangeResp :: Prism' PABResp (POSIXTime, POSIXTime)
_AwaitTxStatusChangeResp :: Prism' PABResp (TxId, TxStatus)
_AwaitTxStatusChangeResp' :: TxId -> Prism' PABResp TxStatus
_AwaitTxOutStatusChangeResp :: Prism' PABResp (TxIn, TxOutStatus)
_GetParamsResp :: Prism' PABResp Params
_OwnContractInstanceIdResp :: Prism' PABResp ContractInstanceId
_OwnAddressesResp :: Prism' PABResp (NonEmpty CardanoAddress)
_ChainIndexQueryResp :: Prism' PABResp ChainIndexResponse
_BalanceTxResp :: Prism' PABResp BalanceTxResponse
_WriteBalancedTxResp :: Prism' PABResp WriteBalancedTxResponse
_ExposeEndpointResp :: Prism' PABResp (EndpointDescription, EndpointValue Value)
_PosixTimeRangeToContainedSlotRangeResp :: Prism' PABResp (Either SlotConversionError SlotRange)
_YieldUnbalancedTxResp :: Prism' PABResp ()
_DatumHashResponse :: Prism' ChainIndexResponse (Maybe Datum)
_ValidatorHashResponse :: Prism' ChainIndexResponse (Maybe (Versioned Validator))
_MintingPolicyHashResponse :: Prism' ChainIndexResponse (Maybe (Versioned MintingPolicy))
_RedeemerHashResponse :: Prism' ChainIndexResponse (Maybe Redeemer)
_TxOutRefResponse :: Prism' ChainIndexResponse (Maybe DecoratedTxOut)
_UnspentTxOutResponse :: Prism' ChainIndexResponse (Maybe DecoratedTxOut)
_TxIdResponse :: Prism' ChainIndexResponse (Maybe ChainIndexTx)
_UtxoSetMembershipResponse :: Prism' ChainIndexResponse IsUtxoResponse
_UtxoSetAtResponse :: Prism' ChainIndexResponse UtxosResponse
_UtxoSetWithCurrencyResponse :: Prism' ChainIndexResponse UtxosResponse
_TxIdsResponse :: Prism' ChainIndexResponse [ChainIndexTx]
_TxoSetAtResponse :: Prism' ChainIndexResponse TxosResponse
_GetTipResponse :: Prism' ChainIndexResponse Tip
matches :: PABReq -> PABResp -> Bool

-- | Represents all possible chain index queries. Each constructor contains
--   the input(s) needed for the query. These possible queries correspond
--   to the constructors of the data type <a>ChainIndexQueryEffect</a>.
data ChainIndexQuery
DatumFromHash :: DatumHash -> ChainIndexQuery
ValidatorFromHash :: ValidatorHash -> ChainIndexQuery
MintingPolicyFromHash :: MintingPolicyHash -> ChainIndexQuery
StakeValidatorFromHash :: StakeValidatorHash -> ChainIndexQuery
RedeemerFromHash :: RedeemerHash -> ChainIndexQuery
TxOutFromRef :: TxOutRef -> ChainIndexQuery
UnspentTxOutFromRef :: TxOutRef -> ChainIndexQuery
TxFromTxId :: TxId -> ChainIndexQuery
UtxoSetMembership :: TxOutRef -> ChainIndexQuery
UtxoSetAtAddress :: PageQuery TxOutRef -> CardanoAddress -> ChainIndexQuery
UnspentTxOutSetAtAddress :: PageQuery TxOutRef -> CardanoAddress -> ChainIndexQuery
DatumsAtAddress :: PageQuery TxOutRef -> CardanoAddress -> ChainIndexQuery
UtxoSetWithCurrency :: PageQuery TxOutRef -> AssetClass -> ChainIndexQuery
TxsFromTxIds :: [TxId] -> ChainIndexQuery
TxoSetAtAddress :: PageQuery TxOutRef -> CardanoAddress -> ChainIndexQuery
GetTip :: ChainIndexQuery

-- | Represents all possible responses to chain index queries. Each
--   constructor contain the output resulting for the chain index query.
--   These possible responses come from the data type
--   <a>ChainIndexQueryEffect</a>.
data ChainIndexResponse
DatumHashResponse :: Maybe Datum -> ChainIndexResponse
ValidatorHashResponse :: Maybe (Versioned Validator) -> ChainIndexResponse
MintingPolicyHashResponse :: Maybe (Versioned MintingPolicy) -> ChainIndexResponse
StakeValidatorHashResponse :: Maybe (Versioned StakeValidator) -> ChainIndexResponse
TxOutRefResponse :: Maybe DecoratedTxOut -> ChainIndexResponse
UnspentTxOutResponse :: Maybe DecoratedTxOut -> ChainIndexResponse
RedeemerHashResponse :: Maybe Redeemer -> ChainIndexResponse
TxIdResponse :: Maybe ChainIndexTx -> ChainIndexResponse
UtxoSetMembershipResponse :: IsUtxoResponse -> ChainIndexResponse
UtxoSetAtResponse :: UtxosResponse -> ChainIndexResponse
UnspentTxOutsAtResponse :: QueryResponse [(TxOutRef, DecoratedTxOut)] -> ChainIndexResponse
DatumsAtResponse :: QueryResponse [Datum] -> ChainIndexResponse
UtxoSetWithCurrencyResponse :: UtxosResponse -> ChainIndexResponse
TxIdsResponse :: [ChainIndexTx] -> ChainIndexResponse
TxoSetAtResponse :: TxosResponse -> ChainIndexResponse
GetTipResponse :: Tip -> ChainIndexResponse
data BalanceTxResponse
BalanceTxFailed :: WalletAPIError -> BalanceTxResponse
BalanceTxSuccess :: CardanoTx -> BalanceTxResponse
balanceTxResponse :: Iso' BalanceTxResponse (Either WalletAPIError CardanoTx)
data WriteBalancedTxResponse
WriteBalancedTxFailed :: WalletAPIError -> WriteBalancedTxResponse
WriteBalancedTxSuccess :: CardanoTx -> WriteBalancedTxResponse
writeBalancedTxResponse :: Iso' WriteBalancedTxResponse (Either WalletAPIError CardanoTx)
data ActiveEndpoint
ActiveEndpoint :: EndpointDescription -> Maybe Value -> ActiveEndpoint

-- | The name of the endpoint
[aeDescription] :: ActiveEndpoint -> EndpointDescription

-- | Data that should be shown to the user
[aeMetadata] :: ActiveEndpoint -> Maybe Value
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ChainIndexQuery
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Generics.Generic Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Show.Show Plutus.Contract.Effects.ChainIndexQuery
instance GHC.Classes.Eq Plutus.Contract.Effects.ChainIndexQuery
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ChainIndexResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Show.Show Plutus.Contract.Effects.ChainIndexResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.ChainIndexResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.BalanceTxResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Show.Show Plutus.Contract.Effects.BalanceTxResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.BalanceTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.WriteBalancedTxResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Show.Show Plutus.Contract.Effects.WriteBalancedTxResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.WriteBalancedTxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.PABResp
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.PABResp
instance GHC.Generics.Generic Plutus.Contract.Effects.PABResp
instance GHC.Show.Show Plutus.Contract.Effects.PABResp
instance GHC.Classes.Eq Plutus.Contract.Effects.PABResp
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ActiveEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Generics.Generic Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Show.Show Plutus.Contract.Effects.ActiveEndpoint
instance GHC.Classes.Eq Plutus.Contract.Effects.ActiveEndpoint
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.PABReq
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.PABReq
instance GHC.Generics.Generic Plutus.Contract.Effects.PABReq
instance GHC.Show.Show Plutus.Contract.Effects.PABReq
instance GHC.Classes.Eq Plutus.Contract.Effects.PABReq
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.PABReq
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ActiveEndpoint
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.PABResp
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.WriteBalancedTxResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.BalanceTxResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ChainIndexResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ChainIndexQuery

module Plutus.Contract.Trace.RequestHandler

-- | Request handlers that can choose whether to handle an effect (using
--   <a>Alternative</a>). This is useful if <tt>req</tt> is a sum type.
newtype RequestHandler effs req resp
RequestHandler :: (req -> Eff (NonDet : effs) resp) -> RequestHandler effs req resp
[unRequestHandler] :: RequestHandler effs req resp -> req -> Eff (NonDet : effs) resp
data RequestHandlerLogMsg
SlotNoticationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
AdjustingUnbalancedTx :: [Lovelace] -> RequestHandlerLogMsg
tryHandler :: forall effs req resp. RequestHandler effs req resp -> [req] -> Eff effs (Maybe resp)
tryHandler' :: forall f effs req resp. (Alternative f, Monad f) => RequestHandler effs req (f resp) -> [req] -> Eff effs (f resp)
wrapHandler :: RequestHandler effs req resp -> RequestHandler effs (Request req) (Response resp)
extract :: Alternative f => Prism' a b -> a -> f b
maybeToHandler :: (req -> Maybe resp) -> RequestHandler effs req resp

-- | Generalise a request handler
generalise :: forall effs req req' resp resp'. (req' -> Maybe req) -> (resp -> resp') -> RequestHandler effs req resp -> RequestHandler effs req' resp'
handleAdjustUnbalancedTx :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs UnbalancedTx UnbalancedTx
handleOwnAddresses :: forall a effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a (NonEmpty CardanoAddress)
handleSlotNotifications :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs Slot Slot
handleCurrentNodeClientSlot :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a Slot
handleCurrentChainIndexSlot :: forall effs a. (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs a Slot
handleTimeNotifications :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs POSIXTime POSIXTime
handleCurrentTime :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a POSIXTime
handleCurrentNodeClientTimeRange :: forall effs a. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a (POSIXTime, POSIXTime)
handleTimeToSlotConversions :: forall effs. (Member NodeClientEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs POSIXTimeRange SlotRange
handleUnbalancedTransactions :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs UnbalancedTx (Either WalletAPIError CardanoTx)
handlePendingTransactions :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs CardanoTx (Either WalletAPIError CardanoTx)
handleChainIndexQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs ChainIndexQuery ChainIndexResponse
handleOwnInstanceIdQueries :: forall effs a. (Member (LogObserve (LogMessage Text)) effs, Member (Reader ContractInstanceId) effs) => RequestHandler effs a ContractInstanceId
handleYieldedUnbalancedTx :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs UnbalancedTx ()
handleGetParams :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs () Params
instance GHC.Base.Monoid (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance GHC.Base.Semigroup (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance Control.Arrow.Arrow (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Control.Category.Category (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Data.Profunctor.Unsafe.Profunctor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance GHC.Base.Functor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req)

module Plutus.Contract.Error
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
ToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4ePX
_ContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ContractError
_WalletContractError :: AsContractError r_a4ePX => Prism' r_a4ePX WalletAPIError
_ChainIndexContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (Text, ChainIndexResponse)
_ConstraintResolutionContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MkTxError
_ToCardanoConvertContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ToCardanoError
_ResumableContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MatchingError
_CCheckpointContractError :: AsContractError r_a4ePX => Prism' r_a4ePX CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4ePX => Prism' r_a4ePX Text

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text
class AsMatchingError r_a4egB
_MatchingError :: AsMatchingError r_a4egB => Prism' r_a4egB MatchingError
_WrongVariantError :: AsMatchingError r_a4egB => Prism' r_a4egB Text

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a4eo7
_AssertionError :: AsAssertionError r_a4eo7 => Prism' r_a4eo7 AssertionError
_GenericAssertion :: AsAssertionError r_a4eo7 => Prism' r_a4eo7 Text
instance Plutus.Contract.Error.AsContractError Plutus.Contract.Error.ContractError
instance Plutus.Contract.Error.AsContractError Data.Text.Internal.Text
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contract.Error.ContractError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.ContractError
instance Data.String.IsString Plutus.Contract.Error.ContractError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.ContractError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.ContractError
instance GHC.Generics.Generic Plutus.Contract.Error.ContractError
instance GHC.Classes.Eq Plutus.Contract.Error.ContractError
instance GHC.Show.Show Plutus.Contract.Error.ContractError
instance Plutus.Contract.Error.AsAssertionError Plutus.Contract.Error.AssertionError
instance Plutus.Contract.Error.AsAssertionError Data.Text.Internal.Text
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.AssertionError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.AssertionError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.AssertionError
instance GHC.Generics.Generic Plutus.Contract.Error.AssertionError
instance GHC.Classes.Eq Plutus.Contract.Error.AssertionError
instance GHC.Show.Show Plutus.Contract.Error.AssertionError
instance Plutus.Contract.Error.AsMatchingError Plutus.Contract.Error.MatchingError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Error.MatchingError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Error.MatchingError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Error.MatchingError
instance GHC.Generics.Generic Plutus.Contract.Error.MatchingError
instance GHC.Show.Show Plutus.Contract.Error.MatchingError
instance GHC.Classes.Ord Plutus.Contract.Error.MatchingError
instance GHC.Classes.Eq Plutus.Contract.Error.MatchingError

module Plutus.Contract.Types

-- | Effects that are available to contracts.
type ContractEffs w e = '[Error e, LogMsg Value, Writer w, Checkpoint, Resumable PABResp PABReq]
handleContractEffs :: forall w e effs a. (Member (Error e) effs, Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (State (AccumState w)) effs, Member (LogMsg CheckpointLogMsg) effs, Member (LogMsg Value) effs, Monoid w) => Eff (ContractEffs w e) a -> Eff effs (Maybe (MultiRequestContStatus PABResp PABReq effs a))

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w (s :: Row *) e a
Contract :: Eff (ContractEffs w e) a -> Contract w (s :: Row *) e a
[unContract] :: Contract w (s :: Row *) e a -> Eff (ContractEffs w e) a

-- | Class of types that can be trivially converted to a <a>Contract</a>.
--   For use with functions where it is convenient to accept both
--   <a>Contract</a> and <a>Promise</a> types.
class IsContract c
toContract :: IsContract c => c w s e a -> Contract w s e a

-- | A wrapper indicating that this contract starts with a waiting action.
--   For use with <tt>select</tt>.
newtype Promise w (s :: Row *) e a
Promise :: Contract w s e a -> Promise w (s :: Row *) e a
[awaitPromise] :: Promise w (s :: Row *) e a -> Contract w s e a

-- | Run more <a>Contract</a> code after the <a>Promise</a>.
promiseBind :: Promise w s e a -> (a -> Contract w s e b) -> Promise w s e b

-- | Lift a mapping function for <a>Contract</a> to a mapping function for
--   <a>Promise</a>.
promiseMap :: (Contract w1 s1 e1 a1 -> Contract w2 s2 e2 a2) -> Promise w1 s1 e1 a1 -> Promise w2 s2 e2 a2

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
--   
--   However, note that if multiples promises are chained together like
--   <tt>P1 <a>select</a> P2 <a>select</a> P3</tt> and all three can make
--   progress at the same moment, then <tt>select</tt> will prioritize the
--   promises starting from the right (first <tt>P3</tt> then <tt>P2</tt>
--   then <tt>P1</tt>).
select :: forall w s e a. Promise w s e a -> Promise w s e a -> Promise w s e a

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Promise w s e a -> Promise w s e b -> Promise w s e (Either a b)

-- | <a>selectList</a> returns the contract that makes progress first,
--   discarding the other ones.
--   
--   However, if multiple contracts can make progress, <a>selectList</a>
--   prioritizes the ones appearing first in the input list. Therefore, the
--   order of the list of promises is important.
selectList :: [Promise w s e a] -> Contract w s e a

-- | A <a>Promise</a> that is never fulfilled. This is the identity of
--   <a>select</a>.
never :: Promise w s e a
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
ToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4ePX
_ContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ContractError
_WalletContractError :: AsContractError r_a4ePX => Prism' r_a4ePX WalletAPIError
_ChainIndexContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (Text, ChainIndexResponse)
_ConstraintResolutionContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MkTxError
_ToCardanoConvertContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ToCardanoError
_ResumableContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MatchingError
_CCheckpointContractError :: AsContractError r_a4ePX => Prism' r_a4ePX CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4ePX => Prism' r_a4ePX Text

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a
throwError :: MonadError e m => e -> m a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with any error type (ie. throwing no errors) that returns
--   'Either e a'
runError :: forall w s e e0 a. Contract w s e a -> Contract w s e0 (Either e a)

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a
class AsCheckpointError r_ah4E
_CheckpointError :: AsCheckpointError r_ah4E => Prism' r_ah4E CheckpointError
data CheckpointError
JSONDecodeError :: Text -> CheckpointError

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
runResumable :: Monoid w => [Response PABResp] -> CheckpointStore -> Eff (ContractEffs w e) a -> ResumableResult w e PABResp PABReq a
insertAndUpdate :: forall w e a. Monoid w => Eff (ContractEffs w e) a -> CheckpointStore -> Responses (CheckpointKey, PABResp) -> Response PABResp -> ResumableResult w e PABResp PABReq a
runWithRecord :: forall w e a. Monoid w => Eff (ContractEffs w e) a -> CheckpointStore -> Responses PABResp -> ResumableResult w e PABResp PABReq a

-- | The result of running a <a>Resumable</a>
data ResumableResult w e i o a
ResumableResult :: Responses (CheckpointKey, i) -> Requests o -> Either e (Maybe a) -> Seq (LogMessage Value) -> Seq (LogMessage Value) -> CheckpointStore -> w -> w -> ResumableResult w e i o a
[_responses] :: ResumableResult w e i o a -> Responses (CheckpointKey, i)
[_requests] :: ResumableResult w e i o a -> Requests o
[_finalState] :: ResumableResult w e i o a -> Either e (Maybe a)
[_logs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_lastLogs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_checkpointStore] :: ResumableResult w e i o a -> CheckpointStore

-- | Accumulated, observable state of the contract
[_observableState] :: ResumableResult w e i o a -> w

-- | Last accumulated state
[_lastState] :: ResumableResult w e i o a -> w
responses :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw i_a4o0v. Lens (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) (ResumableResult w_a4mEs e_a4mEt i_a4o0v o_a4mEv a_a4mEw) (Responses (CheckpointKey, i_a4mEu)) (Responses (CheckpointKey, i_a4o0v))
requests :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw o_a4o0u. Lens (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4o0u a_a4mEw) (Requests o_a4mEv) (Requests o_a4o0u)
finalState :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw e_a4o0s a_a4o0t. Lens (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) (ResumableResult w_a4mEs e_a4o0s i_a4mEu o_a4mEv a_a4o0t) (Either e_a4mEt (Maybe a_a4mEw)) (Either e_a4o0s (Maybe a_a4o0t))
logs :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw. Lens' (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) (Seq (LogMessage Value))
lastState :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw. Lens' (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) w_a4mEs
checkpointStore :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw. Lens' (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) CheckpointStore
observableState :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw. Lens' (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) w_a4mEs

-- | Shrink the <a>ResumableResult</a> by deleting everything that's not
--   needed to restore the state of the contract instance.
shrinkResumableResult :: ResumableResult w e i o a -> ResumableResult w e i o a
data SuspendedContract w e i o a
SuspendedContract :: ResumableResult w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e) a) -> CheckpointKey -> SuspendedContract w e i o a
[_resumableResult] :: SuspendedContract w e i o a -> ResumableResult w e i o a
[_continuations] :: SuspendedContract w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e) a)
[_checkpointKey] :: SuspendedContract w e i o a -> CheckpointKey
resumableResult :: forall w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26. Lens' (SuspendedContract w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26) (ResumableResult w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26)
continuations :: forall w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26. Lens' (SuspendedContract w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26) (Maybe (MultiRequestContStatus i_a4o24 o_a4o25 (SuspendedContractEffects w_a4o22 e_a4o23) a_a4o26))
checkpointKey :: forall w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26. Lens' (SuspendedContract w_a4o22 e_a4o23 i_a4o24 o_a4o25 a_a4o26) CheckpointKey

-- | Run an action of <tt>ContractEffs</tt> until it requests input for the
--   first time, returning the <a>SuspendedContract</a>
suspend :: forall w e a. Monoid w => CheckpointStore -> Eff (ContractEffs w e) a -> SuspendedContract w e PABResp PABReq a

-- | Feed a <a>Response</a> to a <a>SuspendedContract</a>.
runStep :: forall w e a. Monoid w => SuspendedContract w e PABResp PABReq a -> Response PABResp -> Maybe (SuspendedContract w e PABResp PABReq a)
lastLogs :: forall w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw. Lens' (ResumableResult w_a4mEs e_a4mEt i_a4mEu o_a4mEv a_a4mEw) (Seq (LogMessage Value))
instance Data.Aeson.Types.FromJSON.FromJSON w => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.AccumState w)
instance Data.Aeson.Types.ToJSON.ToJSON w => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monoid w => GHC.Base.Monoid (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Semigroup w => GHC.Base.Semigroup (Plutus.Contract.Types.AccumState w)
instance GHC.Show.Show w => GHC.Show.Show (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Ord w => GHC.Classes.Ord (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Eq w => GHC.Classes.Eq (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monad (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Applicative (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Functor (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Plutus.Contract.Types.Promise w s e a)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.Types.Promise w s)
instance GHC.Base.Functor (Plutus.Contract.Types.Promise w s e)
instance (Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.FromJSON.FromJSON o, Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON o, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (GHC.Show.Show i, GHC.Show.Show o, GHC.Show.Show e, GHC.Show.Show a, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.Types.ResumableResult w e i o a)
instance GHC.Generics.Generic (Plutus.Contract.Types.ResumableResult w e i o a)
instance Plutus.Contract.Types.IsContract Plutus.Contract.Types.Contract
instance Plutus.Contract.Types.IsContract Plutus.Contract.Types.Promise
instance Data.Functor.Bind.Class.Apply (Plutus.Contract.Types.Promise w s e)
instance Control.Monad.Error.Class.MonadError e (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Functor.Functor (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Applicative.Applicative (Plutus.Contract.Types.Contract w s e)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.Types.Contract w s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Plutus.Contract.Types.Contract w s e a)

module Plutus.Contract.State

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
data Contract w (s :: Row *) e a

-- | The state of a <a>Contract</a>, containing all responses that have
--   been fed to it, and checkpoints that it produced.
data State w e
State :: Responses e -> CheckpointStore -> w -> State w e
[record] :: State w e -> Responses e
[checkpoints] :: State w e -> CheckpointStore
[observableState] :: State w e -> w

-- | A request sent to a contract instance. It contains the previous
--   <a>State</a> of the instance, and a <a>Response</a> to one of the
--   requests of the instance.
data ContractRequest w s
ContractRequest :: State w (CheckpointKey, s) -> Response s -> ContractRequest w s
[oldState] :: ContractRequest w s -> State w (CheckpointKey, s)
[event] :: ContractRequest w s -> Response s

-- | A response produced by a contract instance. It contains the new
--   <a>State</a>, the list of endpoints that can be called, logs produced
--   by the contract, possibly an error message, and the accumulated
--   observable state.
data ContractResponse w e s h
ContractResponse :: State w (CheckpointKey, s) -> [Request h] -> [LogMessage Value] -> [LogMessage Value] -> Maybe e -> w -> ContractResponse w e s h

-- | Serialised state of the contract (internal)
[newState] :: ContractResponse w e s h -> State w (CheckpointKey, s)

-- | Open requests that can be handled
[hooks] :: ContractResponse w e s h -> [Request h]

-- | Logs produced by the contract
[logs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Logs produced in the last step
[lastLogs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Error that happened during contract execution
[err] :: ContractResponse w e s h -> Maybe e

-- | Observable state produced in the last step
[lastState] :: ContractResponse w e s h -> w
mapE :: forall e f w s h. (e -> f) -> ContractResponse w e s h -> ContractResponse w f s h
mapW :: forall w q e s h. (w -> q) -> ContractResponse w e s h -> ContractResponse q e s h

-- | Run one step of the contract by restoring it to its previous state and
--   feeding it a single new <a>Response</a> event.
insertAndUpdateContract :: forall w s e a. Monoid w => Contract w s e a -> ContractRequest w PABResp -> ContractResponse w e PABResp PABReq

-- | The <a>ContractResponse</a> with the initial state of the contract.
initialiseContract :: forall w s e a. Monoid w => Contract w s e a -> ContractResponse w e PABResp PABReq
mkResponse :: forall w e s h a. Monoid w => w -> ResumableResult w e s h a -> ContractResponse w e s h
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.State w e)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON e) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.State w e)
instance Data.Traversable.Traversable (Plutus.Contract.State.State w)
instance Data.Foldable.Foldable (Plutus.Contract.State.State w)
instance GHC.Base.Functor (Plutus.Contract.State.State w)
instance (GHC.Show.Show e, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.State w e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.State w e)
instance GHC.Generics.Generic (Plutus.Contract.State.State w e)
instance (GHC.Show.Show s, GHC.Show.Show w) => Prettyprinter.Internal.Pretty (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractRequest w s)
instance Data.Traversable.Traversable (Plutus.Contract.State.ContractRequest w)
instance Data.Foldable.Foldable (Plutus.Contract.State.ContractRequest w)
instance GHC.Base.Functor (Plutus.Contract.State.ContractRequest w)
instance (GHC.Show.Show s, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.ContractRequest w s)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.ContractRequest w s)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w, Data.Aeson.Types.FromJSON.FromJSON h, Data.Aeson.Types.FromJSON.FromJSON e) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractResponse w e s h)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON h, Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Base.Functor (Plutus.Contract.State.ContractResponse w e s)
instance (GHC.Show.Show s, GHC.Show.Show w, GHC.Show.Show h, GHC.Show.Show e) => GHC.Show.Show (Plutus.Contract.State.ContractResponse w e s h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w, GHC.Classes.Eq h, GHC.Classes.Eq e) => GHC.Classes.Eq (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractResponse w e s h)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.State.ContractResponse w e)
instance Data.Bifunctor.Bifunctor Plutus.Contract.State.State

module Plutus.Contract.Logging

-- | Log a message at the <tt>Debug</tt> level
logDebug :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Info</tt> level
logInfo :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Warning</tt> level
logWarn :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Error</tt> level
logError :: ToJSON a => a -> Contract w s e ()

module Plutus.Contract.Request

-- | Wait until the slot
awaitSlot :: forall w s e. AsContractError e => Slot -> Contract w s e Slot

-- | Wait until the slot
isSlot :: forall w s e. AsContractError e => Slot -> Promise w s e Slot

-- | Get the current slot number

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of PAB

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentPABSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of the node client (the local or remote
--   node) that the application is connected to.
currentNodeClientSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current node slot number querying slot number from plutus
--   chain index to be aligned with slot at local running node
currentChainIndexSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Wait for a number of slots to pass
waitNSlots :: forall w s e. AsContractError e => Natural -> Contract w s e Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
--   
--   Example: if starting time is 0 and slot length is 3s, then `awaitTime
--   4` waits until slot 2 and returns the value `POSIXTime 5`.
awaitTime :: forall w s e. AsContractError e => POSIXTime -> Contract w s e POSIXTime

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
isTime :: forall w s e. AsContractError e => POSIXTime -> Promise w s e POSIXTime

-- | Get the latest time of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <a>currentTime</a> returns the value `POSIXTime 5`

-- | <i>Deprecated: Use currentNodeClientTimeRange instead</i>
currentTime :: forall w s e. AsContractError e => Contract w s e POSIXTime

-- | Get the <a>POSIXTime</a> range of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <tt>currentTimeRange</tt> returns the time interval <tt>[3, 5[</tt>.
currentNodeClientTimeRange :: forall w s e. AsContractError e => Contract w s e (POSIXTime, POSIXTime)

-- | Wait for a number of milliseconds starting at the ending time of the
--   current slot, and return the latest time we know has passed.
--   
--   Example: if starting time is 0, slot length is 3000ms and current slot
--   is 0, then `waitNMilliSeconds 0` returns the value `POSIXTime 2000`
--   and `waitNMilliSeconds 1000` returns the value `POSIXTime 5`.
waitNMilliSeconds :: forall w s e. AsContractError e => DiffMilliSeconds -> Contract w s e POSIXTime
datumFromHash :: forall w s e. AsContractError e => DatumHash -> Contract w s e (Maybe Datum)

-- | Get the all datums at an address whether or not the corresponding utxo
--   have been consumed or not.
datumsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [Datum]
validatorFromHash :: forall w s e. AsContractError e => ValidatorHash -> Contract w s e (Maybe (Versioned Validator))
mintingPolicyFromHash :: forall w s e. AsContractError e => MintingPolicyHash -> Contract w s e (Maybe (Versioned MintingPolicy))
stakeValidatorFromHash :: forall w s e. AsContractError e => StakeValidatorHash -> Contract w s e (Maybe (Versioned StakeValidator))
redeemerFromHash :: forall w s e. AsContractError e => RedeemerHash -> Contract w s e (Maybe Redeemer)
txOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
txFromTxId :: forall w s e. AsContractError e => TxId -> Contract w s e (Maybe ChainIndexTx)

-- | Find the reference to an utxo containing a reference script by its the
--   script hash, amongst the utxos at a given address
findReferenceValidatorScripByHash :: forall w s e. AsContractError e => ValidatorHash -> CardanoAddress -> Contract w s e TxOutRef
unspentTxOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
utxoRefMembership :: forall w s e. AsContractError e => TxOutRef -> Contract w s e IsUtxoResponse

-- | Get the unspent transaction output references at an address.
utxoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e UtxosResponse

-- | Get the unspent transaction output references with a specific
--   currrency (<a>AssetClass</a>).
utxoRefsWithCurrency :: forall w s e. AsContractError e => PageQuery TxOutRef -> AssetClass -> Contract w s e UtxosResponse

-- | Get the unspent transaction outputs at an address.
utxosAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Get the unspent transaction outputs from a <a>ChainIndexTx</a>.
utxosTxOutTxFromTx :: AsContractError e => ChainIndexTx -> Contract w s e [(TxOutRef, (DecoratedTxOut, ChainIndexTx))]

-- | Get unspent transaction outputs with transaction from address.
utxosTxOutTxAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef (DecoratedTxOut, ChainIndexTx))

-- | Get the transactions for a list of transaction ids.
txsFromTxIds :: forall w s e. AsContractError e => [TxId] -> Contract w s e [ChainIndexTx]

-- | Get the transaction outputs at an address.
txoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e TxosResponse

-- | Get the transactions at an address.
txsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [ChainIndexTx]
getTip :: forall w s e. AsContractError e => Contract w s e Tip
collectQueryResponse :: Monad m => (PageQuery TxOutRef -> m (QueryResponse a)) -> m [a]

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)
fundsAtAddressCondition :: forall w s e. AsContractError e => (Value -> Bool) -> CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target slot and get the unspent transaction outputs at
--   an address.
watchAddressUntilSlot :: forall w s e. AsContractError e => CardanoAddress -> Slot -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target time and get the unspent transaction outputs at
--   an address.
watchAddressUntilTime :: forall w s e. AsContractError e => CardanoAddress -> POSIXTime -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
awaitUtxoSpent :: forall w s e. AsContractError e => TxOutRef -> Contract w s e ChainIndexTx

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
utxoIsSpent :: forall w s e. AsContractError e => TxOutRef -> Promise w s e ChainIndexTx

-- | Wait until one or more unspent outputs are produced at an address.
awaitUtxoProduced :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (NonEmpty ChainIndexTx)

-- | Wait until one or more unspent outputs are produced at an address.
utxoIsProduced :: forall w s e. AsContractError e => CardanoAddress -> Promise w s e (NonEmpty ChainIndexTx)
data RollbackState a
Unknown :: RollbackState a
type TxStatus = RollbackState ()

-- | Wait for the status of a transaction to change
awaitTxStatusChange :: forall w s e. AsContractError e => TxId -> Contract w s e TxStatus

-- | Wait until a transaction is confirmed (added to the ledger). If the
--   transaction is never added to the ledger then <a>awaitTxConfirmed</a>
--   never returns
awaitTxConfirmed :: forall w s e. AsContractError e => TxId -> Contract w s e ()

-- | Wait until a transaction is confirmed (added to the ledger).
isTxConfirmed :: forall w s e. AsContractError e => TxId -> Promise w s e ()
type TxOutStatus = RollbackState TxOutState

-- | Wait for the status of a transaction output to change.
awaitTxOutStatusChange :: forall w s e. AsContractError e => TxOutRef -> Contract w s e TxOutStatus

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. AsContractError e => Contract w s e ContractInstanceId
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, FromJSON a) => (a -> Contract w s e b) -> Promise w s e b
handleEndpoint :: forall l a w s e1 e2 b. (HasEndpoint l a s, AsContractError e1, FromJSON a) => (Either e1 a -> Contract w s e2 b) -> Promise w s e2 b

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e meta b. (HasEndpoint l a s, AsContractError e, ToJSON meta, FromJSON a) => meta -> (a -> Contract w s e b) -> Promise w s e b
endpointDescription :: forall l. KnownSymbol l => Proxy l -> EndpointDescription
endpointReq :: forall l a s. HasEndpoint l a s => ActiveEndpoint
endpointResp :: forall l a s. (HasEndpoint l a s, ToJSON a) => a -> PABResp

-- | Get the hash of a public key belonging to the wallet that runs this
--   contract. * Any funds paid to this public key hash will be treated as
--   the wallet's own funds * The wallet is able to sign transactions with
--   the private key of this public key, for example, if the public key is
--   added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There
--   is a 1-n relationship between wallets and public keys (although in the
--   mockchain n=1)

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash
ownPaymentPubKeyHashes :: forall w s e. AsContractError e => Contract w s e [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash

-- | Get the addresses belonging to the wallet that runs this contract. *
--   Any funds paid to one of these addresses will be treated as the
--   wallet's own funds * The wallet is able to sign transactions with the
--   private key of one of its public key, for example, if the public key
--   is added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. *
--   There is a 1-n relationship between wallets and addresses (although in
--   the mockchain n=1)
ownAddresses :: forall w s e. AsContractError e => Contract w s e (NonEmpty CardanoAddress)

-- | Get the first address of the wallet that runs this contract.
ownAddress :: forall w s e. AsContractError e => Contract w s e CardanoAddress

-- | Get all utxos belonging to the wallet that runs this contract.
ownUtxos :: forall w s e. AsContractError e => Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Get an unspent output belonging to the wallet.
getUnspentOutput :: AsContractError e => Contract w s e TxOutRef

-- | Adjust the unbalanced tx
adjustUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e UnbalancedTx

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Send an balanced transaction to be signed. Returns the ID of the final
--   transaction when the transaction was submitted. Throws an error if
--   signing failed.
submitBalancedTx :: forall w s e. AsContractError e => CardanoTx -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced. Returns the balanced
--   transaction. Throws an error if balancing failed.
balanceTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. AsContractError e => TxConstraints Void Void -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> Map TxOutRef DecoratedTxOut -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Build a transaction that satisfies the constraints
mkTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e UnbalancedTx

-- | Take an <a>UnbalancedTx</a> then balance, sign and submit it to the
--   blockchain without returning any results.
yieldUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Get the configured parameter set.
getParams :: forall w s e. AsContractError e => Contract w s e Params

-- | Constraints on the contract schema, ensuring that the labels of the
--   schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))
pabReq :: forall w s e a. AsContractError e => PABReq -> Prism' PABResp a -> Contract w s e a

-- | Arguments and result of a call to <tt>mkTx</tt>
data MkTxLog
MkTxLog :: ScriptLookups Any -> TxConstraints BuiltinData BuiltinData -> Either MkTxError UnbalancedTx -> MkTxLog
[mkTxLogLookups] :: MkTxLog -> ScriptLookups Any
[mkTxLogTxConstraints] :: MkTxLog -> TxConstraints BuiltinData BuiltinData
[mkTxLogResult] :: MkTxLog -> Either MkTxError UnbalancedTx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Request.MkTxLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Request.MkTxLog
instance GHC.Generics.Generic Plutus.Contract.Request.MkTxLog
instance GHC.Show.Show Plutus.Contract.Request.MkTxLog

module Plutus.Contract

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w (s :: Row *) e a
Contract :: Eff (ContractEffs w e) a -> Contract w (s :: Row *) e a
[unContract] :: Contract w (s :: Row *) e a -> Eff (ContractEffs w e) a
data ContractError
WalletContractError :: WalletAPIError -> ContractError
ChainIndexContractError :: Text -> ChainIndexResponse -> ContractError
ConstraintResolutionContractError :: MkTxError -> ContractError
ToCardanoConvertContractError :: ToCardanoError -> ContractError
ResumableContractError :: MatchingError -> ContractError
CCheckpointContractError :: CheckpointError -> ContractError
EndpointDecodeContractError :: EndpointDescription -> EndpointValue Value -> Text -> ContractError

-- | The endpoint description which the decoding error occurred from
[eeEndpointDescription] :: ContractError -> EndpointDescription

-- | The endpoint value that was used as an endpoint parameter
[eeEndpointValue] :: ContractError -> EndpointValue Value

-- | JSON decoding error message
[eeErrorMessage] :: ContractError -> Text
OtherContractError :: Text -> ContractError
class AsContractError r_a4ePX
_ContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ContractError
_WalletContractError :: AsContractError r_a4ePX => Prism' r_a4ePX WalletAPIError
_ChainIndexContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (Text, ChainIndexResponse)
_ConstraintResolutionContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MkTxError
_ToCardanoConvertContractError :: AsContractError r_a4ePX => Prism' r_a4ePX ToCardanoError
_ResumableContractError :: AsContractError r_a4ePX => Prism' r_a4ePX MatchingError
_CCheckpointContractError :: AsContractError r_a4ePX => Prism' r_a4ePX CheckpointError
_EndpointDecodeContractError :: AsContractError r_a4ePX => Prism' r_a4ePX (EndpointDescription, EndpointValue Value, Text)
_OtherContractError :: AsContractError r_a4ePX => Prism' r_a4ePX Text

-- | Class of types that can be trivially converted to a <a>Contract</a>.
--   For use with functions where it is convenient to accept both
--   <a>Contract</a> and <a>Promise</a> types.
class IsContract c
toContract :: IsContract c => c w s e a -> Contract w s e a

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>
throwError :: MonadError e m => e -> m a

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with any error type (ie. throwing no errors) that returns
--   'Either e a'
runError :: forall w s e e0 a. Contract w s e a -> Contract w s e0 (Either e a)

-- | A wrapper indicating that this contract starts with a waiting action.
--   For use with <tt>select</tt>.
data Promise w (s :: Row *) e a
awaitPromise :: Promise w s e a -> Contract w s e a

-- | Lift a mapping function for <a>Contract</a> to a mapping function for
--   <a>Promise</a>.
promiseMap :: (Contract w1 s1 e1 a1 -> Contract w2 s2 e2 a2) -> Promise w1 s1 e1 a1 -> Promise w2 s2 e2 a2

-- | Run more <a>Contract</a> code after the <a>Promise</a>.
promiseBind :: Promise w s e a -> (a -> Contract w s e b) -> Promise w s e b

-- | Execute both contracts in any order
both :: Promise w s e a -> Promise w s e b -> Promise w s e (a, b)

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Promise w s e a -> Promise w s e b -> Promise w s e (Either a b)

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
--   
--   However, note that if multiples promises are chained together like
--   <tt>P1 <a>select</a> P2 <a>select</a> P3</tt> and all three can make
--   progress at the same moment, then <tt>select</tt> will prioritize the
--   promises starting from the right (first <tt>P3</tt> then <tt>P2</tt>
--   then <tt>P1</tt>).
select :: forall w s e a. Promise w s e a -> Promise w s e a -> Promise w s e a

-- | <a>selectList</a> returns the contract that makes progress first,
--   discarding the other ones.
--   
--   However, if multiple contracts can make progress, <a>selectList</a>
--   prioritizes the ones appearing first in the input list. Therefore, the
--   order of the list of promises is important.
selectList :: [Promise w s e a] -> Contract w s e a

-- | A <a>Promise</a> that is never fulfilled. This is the identity of
--   <a>select</a>.
never :: Promise w s e a

-- | Wait until the slot
awaitSlot :: forall w s e. AsContractError e => Slot -> Contract w s e Slot

-- | Wait until the slot
isSlot :: forall w s e. AsContractError e => Slot -> Promise w s e Slot

-- | Get the current slot number

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of PAB

-- | <i>Deprecated: Use currentNodeClientSlot instead</i>
currentPABSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current slot number of the node client (the local or remote
--   node) that the application is connected to.
currentNodeClientSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Get the current node slot number querying slot number from plutus
--   chain index to be aligned with slot at local running node
currentChainIndexSlot :: forall w s e. AsContractError e => Contract w s e Slot

-- | Wait for a number of slots to pass
waitNSlots :: forall w s e. AsContractError e => Natural -> Contract w s e Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
--   
--   Example: if starting time is 0 and slot length is 3s, then `awaitTime
--   4` waits until slot 2 and returns the value `POSIXTime 5`.
awaitTime :: forall w s e. AsContractError e => POSIXTime -> Contract w s e POSIXTime

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
isTime :: forall w s e. AsContractError e => POSIXTime -> Promise w s e POSIXTime

-- | Get the latest time of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <a>currentTime</a> returns the value `POSIXTime 5`

-- | <i>Deprecated: Use currentNodeClientTimeRange instead</i>
currentTime :: forall w s e. AsContractError e => Contract w s e POSIXTime

-- | Get the <a>POSIXTime</a> range of the current slot.
--   
--   Example: if slot length is 3s and current slot is 2, then
--   <tt>currentTimeRange</tt> returns the time interval <tt>[3, 5[</tt>.
currentNodeClientTimeRange :: forall w s e. AsContractError e => Contract w s e (POSIXTime, POSIXTime)

-- | Wait for a number of milliseconds starting at the ending time of the
--   current slot, and return the latest time we know has passed.
--   
--   Example: if starting time is 0, slot length is 3000ms and current slot
--   is 0, then `waitNMilliSeconds 0` returns the value `POSIXTime 2000`
--   and `waitNMilliSeconds 1000` returns the value `POSIXTime 5`.
waitNMilliSeconds :: forall w s e. AsContractError e => DiffMilliSeconds -> Contract w s e POSIXTime
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, FromJSON a) => (a -> Contract w s e b) -> Promise w s e b
handleEndpoint :: forall l a w s e1 e2 b. (HasEndpoint l a s, AsContractError e1, FromJSON a) => (Either e1 a -> Contract w s e2 b) -> Promise w s e2 b

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e meta b. (HasEndpoint l a s, AsContractError e, ToJSON meta, FromJSON a) => meta -> (a -> Contract w s e b) -> Promise w s e b
type EmptySchema = Empty

-- | Wait until the target slot and get the unspent transaction outputs at
--   an address.
watchAddressUntilSlot :: forall w s e. AsContractError e => CardanoAddress -> Slot -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the target time and get the unspent transaction outputs at
--   an address.
watchAddressUntilTime :: forall w s e. AsContractError e => CardanoAddress -> POSIXTime -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. AsContractError e => CardanoAddress -> Value -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
awaitUtxoSpent :: forall w s e. AsContractError e => TxOutRef -> Contract w s e ChainIndexTx

-- | Wait until the UTXO has been spent, returning the transaction that
--   spends it.
utxoIsSpent :: forall w s e. AsContractError e => TxOutRef -> Promise w s e ChainIndexTx

-- | Wait until one or more unspent outputs are produced at an address.
awaitUtxoProduced :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (NonEmpty ChainIndexTx)

-- | Wait until one or more unspent outputs are produced at an address.
utxoIsProduced :: forall w s e. AsContractError e => CardanoAddress -> Promise w s e (NonEmpty ChainIndexTx)
datumFromHash :: forall w s e. AsContractError e => DatumHash -> Contract w s e (Maybe Datum)

-- | Get the all datums at an address whether or not the corresponding utxo
--   have been consumed or not.
datumsAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e [Datum]

-- | Find the reference to an utxo containing a reference script by its the
--   script hash, amongst the utxos at a given address
findReferenceValidatorScripByHash :: forall w s e. AsContractError e => ValidatorHash -> CardanoAddress -> Contract w s e TxOutRef
validatorFromHash :: forall w s e. AsContractError e => ValidatorHash -> Contract w s e (Maybe (Versioned Validator))
mintingPolicyFromHash :: forall w s e. AsContractError e => MintingPolicyHash -> Contract w s e (Maybe (Versioned MintingPolicy))
stakeValidatorFromHash :: forall w s e. AsContractError e => StakeValidatorHash -> Contract w s e (Maybe (Versioned StakeValidator))
txOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
unspentTxOutFromRef :: forall w s e. AsContractError e => TxOutRef -> Contract w s e (Maybe DecoratedTxOut)
txFromTxId :: forall w s e. AsContractError e => TxId -> Contract w s e (Maybe ChainIndexTx)
utxoRefMembership :: forall w s e. AsContractError e => TxOutRef -> Contract w s e IsUtxoResponse

-- | Get the unspent transaction output references at an address.
utxoRefsAt :: forall w s e. AsContractError e => PageQuery TxOutRef -> CardanoAddress -> Contract w s e UtxosResponse

-- | Get the unspent transaction output references with a specific
--   currrency (<a>AssetClass</a>).
utxoRefsWithCurrency :: forall w s e. AsContractError e => PageQuery TxOutRef -> AssetClass -> Contract w s e UtxosResponse

-- | Get the unspent transaction outputs at an address.
utxosAt :: forall w s e. AsContractError e => CardanoAddress -> Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Get the unspent transaction outputs from a <a>ChainIndexTx</a>.
utxosTxOutTxFromTx :: AsContractError e => ChainIndexTx -> Contract w s e [(TxOutRef, (DecoratedTxOut, ChainIndexTx))]
getTip :: forall w s e. AsContractError e => Contract w s e Tip

-- | Get the hash of a public key belonging to the wallet that runs this
--   contract. * Any funds paid to this public key hash will be treated as
--   the wallet's own funds * The wallet is able to sign transactions with
--   the private key of this public key, for example, if the public key is
--   added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There
--   is a 1-n relationship between wallets and public keys (although in the
--   mockchain n=1)

-- | <i>Deprecated: Use ownFirstPaymentPubKeyHash, ownPaymentPubKeyHashes
--   or ownAddresses instead</i>
ownPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash
ownPaymentPubKeyHashes :: forall w s e. AsContractError e => Contract w s e [PaymentPubKeyHash]
ownFirstPaymentPubKeyHash :: forall w s e. AsContractError e => Contract w s e PaymentPubKeyHash

-- | Get the addresses belonging to the wallet that runs this contract. *
--   Any funds paid to one of these addresses will be treated as the
--   wallet's own funds * The wallet is able to sign transactions with the
--   private key of one of its public key, for example, if the public key
--   is added to the <tt>requiredSignatures</tt> field of <tt>Tx</tt>. *
--   There is a 1-n relationship between wallets and addresses (although in
--   the mockchain n=1)
ownAddresses :: forall w s e. AsContractError e => Contract w s e (NonEmpty CardanoAddress)

-- | Get the first address of the wallet that runs this contract.
ownAddress :: forall w s e. AsContractError e => Contract w s e CardanoAddress

-- | Get all utxos belonging to the wallet that runs this contract.
ownUtxos :: forall w s e. AsContractError e => Contract w s e (Map TxOutRef DecoratedTxOut)

-- | Unique ID for contract instance
data ContractInstanceId

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. AsContractError e => Contract w s e ContractInstanceId

-- | Update the contract's accumulating state <tt>w</tt>
tell :: w -> Contract w s e ()

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | Adjust the unbalanced tx
adjustUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e UnbalancedTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. AsContractError e => TxConstraints Void Void -> Contract w s e CardanoTx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => TypedValidator a -> Map TxOutRef DecoratedTxOut -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Send an balanced transaction to be signed. Returns the ID of the final
--   transaction when the transaction was submitted. Throws an error if
--   signing failed.
submitBalancedTx :: forall w s e. AsContractError e => CardanoTx -> Contract w s e CardanoTx

-- | Send an unbalanced transaction to be balanced. Returns the balanced
--   transaction. Throws an error if balancing failed.
balanceTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e CardanoTx

-- | Build a transaction that satisfies the constraints
mkTxConstraints :: forall a w s e. (ToData (RedeemerType a), FromData (DatumType a), ToData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e UnbalancedTx

-- | Take an <a>UnbalancedTx</a> then balance, sign and submit it to the
--   blockchain without returning any results.
yieldUnbalancedTx :: forall w s e. AsContractError e => UnbalancedTx -> Contract w s e ()

-- | Wait until a transaction is confirmed (added to the ledger). If the
--   transaction is never added to the ledger then <a>awaitTxConfirmed</a>
--   never returns
awaitTxConfirmed :: forall w s e. AsContractError e => TxId -> Contract w s e ()

-- | Wait for the status of a transaction to change
awaitTxStatusChange :: forall w s e. AsContractError e => TxId -> Contract w s e TxStatus

-- | Wait until a transaction is confirmed (added to the ledger).
isTxConfirmed :: forall w s e. AsContractError e => TxId -> Promise w s e ()

-- | Wait for the status of a transaction output to change.
awaitTxOutStatusChange :: forall w s e. AsContractError e => TxOutRef -> Contract w s e TxOutStatus

-- | Get the configured parameter set.
getParams :: forall w s e. AsContractError e => Contract w s e Params

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
class AsCheckpointError r_ah4E
_CheckpointError :: AsCheckpointError r_ah4E => Prism' r_ah4E CheckpointError
data CheckpointError
JSONDecodeError :: Text -> CheckpointError
class r .! l ≈ a => HasType (l :: Symbol) (a :: k) (r :: Row k)

-- | Constraints on the contract schema, ensuring that the labels of the
--   schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))
type family (l :: Row k) .\/ (r :: Row k) :: Row k
type Empty = 'R '[] :: [LT a]

module Plutus.Trace.Emulator.Types

-- | Messages sent to, and received by, threads in the emulator.
data EmulatorMessage

-- | A new slot has begun and some blocks were added.
NewSlot :: [Block] -> Slot -> EmulatorMessage

-- | Call to an endpoint
EndpointCall :: ThreadId -> EndpointDescription -> Value -> EmulatorMessage

-- | Tell the contract instance to freeze itself (see note [Freeze and
--   Thaw])
Freeze :: EmulatorMessage

-- | Request for the current state of a contract instance
ContractInstanceStateRequest :: ThreadId -> EmulatorMessage

-- | Response to a contract instance state request
ContractInstanceStateResponse :: Value -> EmulatorMessage

-- | A map of contract instance ID to thread ID
newtype EmulatorThreads
EmulatorThreads :: Map ContractInstanceId ThreadId -> EmulatorThreads
[_instanceIdThreads] :: EmulatorThreads -> Map ContractInstanceId ThreadId
instanceIdThreads :: Iso' EmulatorThreads (Map ContractInstanceId ThreadId)

-- | Effects available to emulator agent threads. Includes emulated wallet
--   effects and effects related to threading / waiting for messages.
type EmulatorAgentThreadEffs effs = LogMsg ContractInstanceLog : EmulatedWalletEffects' (Yield (AgentSystemCall EmulatorMessage) (Maybe EmulatorMessage) : Reader ThreadId : effs)
type EmulatedWalletEffects = EmulatedWalletEffects' '[]

-- | Effects that are used to handle requests by contract instances. In the
--   emulator these effects are handled by <a>MultiAgent</a>. In the PAB
--   they are handled by the actual wallet<i>node</i>chain index, mediated
--   by the PAB runtime.
type EmulatedWalletEffects' effs = WalletEffect : Error WalletAPIError : NodeClientEffect : ChainIndexQueryEffect : LogObserve (LogMessage Text) : LogMsg RequestHandlerLogMsg : LogMsg TxBalanceMsg : LogMsg Text : effs

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
ContractInstanceTag :: Text -> Text -> ContractInstanceTag
[unContractInstanceTag] :: ContractInstanceTag -> Text
[shortContractInstanceTag] :: ContractInstanceTag -> Text

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> NetworkId -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag
[chNetworkId] :: ContractHandle w s e -> NetworkId
data Emulator
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w (s :: Row *) e a
ContractInstanceState :: ResumableResult w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceState w (s :: Row *) e a
[instContractState] :: ContractInstanceState w (s :: Row *) e a -> ResumableResult w e PABResp PABReq a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w (s :: Row *) e a -> Seq (Response PABResp)

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w (s :: Row *) e a -> Seq [Request PABReq]

-- | State of the contract instance, internal to the contract instance
--   thread. It contains both the serialisable state of the contract
--   instance and the non-serialisable continuations in
--   <a>SuspendedContract</a>.
data ContractInstanceStateInternal w (s :: Row *) e a
ContractInstanceStateInternal :: SuspendedContract w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceStateInternal w (s :: Row *) e a
[cisiSuspState] :: ContractInstanceStateInternal w (s :: Row *) e a -> SuspendedContract w e PABResp PABReq a
[cisiEvents] :: ContractInstanceStateInternal w (s :: Row *) e a -> Seq (Response PABResp)
[cisiHandlersHistory] :: ContractInstanceStateInternal w (s :: Row *) e a -> Seq [Request PABReq]
emptyInstanceState :: forall w (s :: Row *) e a. Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response PABResp -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)

-- | Extract the serialisable <a>ContractInstanceState</a> from the
--   <a>ContractInstanceStateInternal</a>. We need to do this when we want
--   to send the instance state to another thread.
toInstanceState :: ContractInstanceStateInternal w (s :: Row *) e a -> ContractInstanceState w s e a
data ContractInstanceLog
ContractInstanceLog :: ContractInstanceMsg -> ContractInstanceId -> ContractInstanceTag -> ContractInstanceLog
[_cilMessage] :: ContractInstanceLog -> ContractInstanceMsg
[_cilId] :: ContractInstanceLog -> ContractInstanceId
[_cilTag] :: ContractInstanceLog -> ContractInstanceTag
cilId :: Lens' ContractInstanceLog ContractInstanceId
cilMessage :: Lens' ContractInstanceLog ContractInstanceMsg
cilTag :: Lens' ContractInstanceLog ContractInstanceTag
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
EmulatorJSONDecodingError :: String -> Value -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError
EmulatedWalletError :: WalletAPIError -> EmulatorRuntimeError
AssertionError :: String -> EmulatorRuntimeError

-- | Log messages produced by contract instances
data ContractInstanceMsg
Started :: ContractInstanceMsg
StoppedNoError :: ContractInstanceMsg
StoppedWithError :: String -> ContractInstanceMsg
ReceiveEndpointCall :: EndpointDescription -> Value -> ContractInstanceMsg
ReceiveEndpointCallSuccess :: ContractInstanceMsg
ReceiveEndpointCallFailure :: NotificationError -> ContractInstanceMsg
NoRequestsHandled :: ContractInstanceMsg
HandledRequest :: Response Value -> ContractInstanceMsg
CurrentRequests :: [Request Value] -> ContractInstanceMsg
InstErr :: EmulatorRuntimeError -> ContractInstanceMsg
ContractLog :: Value -> ContractInstanceMsg
SendingNotification :: Notification -> ContractInstanceMsg
NotificationSuccess :: Notification -> ContractInstanceMsg
NotificationFailure :: NotificationError -> ContractInstanceMsg
SendingContractState :: ThreadId -> ContractInstanceMsg
Freezing :: ContractInstanceMsg
_Started :: Prism' ContractInstanceMsg ()
_StoppedNoError :: Prism' ContractInstanceMsg ()
_StoppedWithError :: Prism' ContractInstanceMsg String
_ReceiveEndpointCall :: Prism' ContractInstanceMsg (EndpointDescription, Value)
_NoRequestsHandled :: Prism' ContractInstanceMsg ()
_HandledRequest :: Prism' ContractInstanceMsg (Response Value)
_CurrentRequests :: Prism' ContractInstanceMsg [Request Value]
_InstErr :: Prism' ContractInstanceMsg EmulatorRuntimeError
_ContractLog :: Prism' ContractInstanceMsg Value

-- | Log message produced by the user (main) thread
data UserThreadMsg
UserThreadErr :: EmulatorRuntimeError -> UserThreadMsg
UserLog :: String -> UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.UserThreadMsg
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.String.IsString Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Base.Monoid Plutus.Trace.Emulator.Types.EmulatorThreads
instance GHC.Base.Semigroup Plutus.Trace.Emulator.Types.EmulatorThreads

module Wallet.Emulator.MultiAgent

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e
eteEvent :: forall e_a52TM e_a538A. Lens (EmulatorTimeEvent e_a52TM) (EmulatorTimeEvent e_a538A) e_a52TM e_a538A
eteEmulatorTime :: forall e_a52TM. Lens' (EmulatorTimeEvent e_a52TM) Slot
emulatorTimeEvent :: Slot -> Prism' (EmulatorTimeEvent e) e

-- | Events produced by the blockchain emulator.
data EmulatorEvent'
ChainEvent :: ChainEvent -> EmulatorEvent'
ClientEvent :: Wallet -> NodeClientEvent -> EmulatorEvent'
WalletEvent :: Wallet -> WalletEvent -> EmulatorEvent'
ChainIndexEvent :: Wallet -> ChainIndexLog -> EmulatorEvent'
SchedulerEvent :: SchedulerLog -> EmulatorEvent'
InstanceEvent :: ContractInstanceLog -> EmulatorEvent'
UserThreadEvent :: UserThreadMsg -> EmulatorEvent'
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'
chainEvent :: Prism' EmulatorEvent' ChainEvent
walletClientEvent :: Wallet -> Prism' EmulatorEvent' NodeClientEvent
walletEvent :: Wallet -> Prism' EmulatorEvent' WalletEvent
walletEvent' :: Prism' EmulatorEvent' (Wallet, WalletEvent)
chainIndexEvent :: Wallet -> Prism' EmulatorEvent' ChainIndexLog
schedulerEvent :: Prism' EmulatorEvent' SchedulerLog
instanceEvent :: Prism' EmulatorEvent' ContractInstanceLog
userThreadEvent :: Prism' EmulatorEvent' UserThreadMsg
type EmulatedWalletControlEffects = '[NodeClientControlEffect, ChainIndexControlEffect, SigningProcessControlEffect, LogObserve (LogMessage Text), LogMsg Text]

-- | The type of actions in the emulator.
data MultiAgentEffect r

-- | A direct action performed by a wallet. Usually represents a "user
--   action", as it is triggered externally.
[WalletAction] :: Wallet -> Eff EmulatedWalletEffects r -> MultiAgentEffect r
data MultiAgentControlEffect r

-- | An action affecting the emulated parts of a wallet (only available in
--   emulator - see note [Control effects].)
[WalletControlAction] :: Wallet -> Eff EmulatedWalletControlEffects r -> MultiAgentControlEffect r

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r
handleMultiAgentEffects :: forall effs. Member MultiAgentEffect effs => Wallet -> Eff (EmulatedWalletEffects' effs) ~> Eff effs
raiseWallet :: forall f effs. (Member f EmulatedWalletEffects, Member MultiAgentEffect effs) => Wallet -> f ~> Eff effs

-- | Run a control action in the context of a wallet
walletControlAction :: Member MultiAgentControlEffect effs => Wallet -> Eff EmulatedWalletControlEffects r -> Eff effs r

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
emulatorLog :: Lens' EmulatorState [LogMessage EmulatorEvent]
chainState :: Lens' EmulatorState ChainState
walletState :: Wallet -> Lens' EmulatorState WalletState

-- | Get the blockchain as a list of blocks, starting with the oldest
--   (genesis) block.
chainOldestFirst :: Lens' EmulatorState Blockchain
chainUtxo :: Getter EmulatorState AddressMap

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Params -> Map PaymentPubKeyHash Value -> Either ToCardanoError EmulatorState
type MultiAgentEffs = '[State EmulatorState, LogMsg EmulatorEvent', Error WalletAPIError, Error ChainIndexError, ChainEffect, ChainControlEffect]
handleMultiAgentControl :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentControlEffect : effs) ~> Eff effs
handleMultiAgent :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentEffect : effs) ~> Eff effs
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Generics.Generic Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Classes.Eq Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorState
instance Prettyprinter.Internal.Pretty Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Prettyprinter.Internal.Pretty e => Prettyprinter.Internal.Pretty (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.FromJSON.FromJSON e => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.ToJSON.ToJSON e => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Traversable.Traversable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance Data.Foldable.Foldable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Base.Functor Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Generics.Generic (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Show.Show e => GHC.Show.Show (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)

module Wallet.Emulator.Types

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[unWalletId] :: WalletId -> Digest Blake2b_160
data XPrv
data XPub

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet
newtype WalletNumber
WalletNumber :: Integer -> WalletNumber
[getWallet] :: WalletNumber -> Integer
toWalletNumber :: MockWallet -> WalletNumber
fromWalletNumber :: WalletNumber -> Wallet
data MockWallet
MockWallet :: Digest Blake2b_160 -> MockPrivateKey -> Maybe MockPrivateKey -> Maybe String -> MockWallet
[mwWalletId] :: MockWallet -> Digest Blake2b_160
[mwPaymentKey] :: MockWallet -> MockPrivateKey
[mwStakeKey] :: MockWallet -> Maybe MockPrivateKey
[mwPrintAs] :: MockWallet -> Maybe String
type TxPool = [CardanoTx]
type EmulatorEffs = '[MultiAgentEffect, ChainEffect, ChainControlEffect]

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a4eo7
_AssertionError :: AsAssertionError r_a4eo7 => Prism' r_a4eo7 AssertionError
_GenericAssertion :: AsAssertionError r_a4eo7 => Prism' r_a4eo7 Text
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'

-- | Events produced by the blockchain emulator.
data EmulatorEvent'

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: MockWallet -> NodeClientState -> ChainIndexEmulatorState -> Maybe SigningProcess -> WalletState

-- | Mock wallet with the user's private key.
[_mockWallet] :: WalletState -> MockWallet

-- | The representation of the node, as known by the wallet
[_nodeClient] :: WalletState -> NodeClientState

-- | the chain index info known by the wallet
[_chainIndexEmulatorState] :: WalletState -> ChainIndexEmulatorState

-- | Override the signing process. Used for testing multi-agent use cases.
[_signingProcess] :: WalletState -> Maybe SigningProcess

-- | Empty wallet state for an emulator <a>Wallet</a>. Returns
--   <a>Nothing</a> if the wallet is not known in the emulator.
emptyWalletState :: Wallet -> Maybe WalletState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey

-- | Get the user's own payment public-key address.
ownAddress :: WalletState -> CardanoAddress

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Params -> Map PaymentPubKeyHash Value -> Either ToCardanoError EmulatorState
txPool :: Lens' ChainState TxPool
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
index :: Lens' ChainState UtxoIndex
chainState :: Lens' EmulatorState ChainState
chainCurrentSlot :: Lens' ChainState Slot
processEmulated :: forall effs. (Member (Error WalletAPIError) effs, Member (Error ChainIndexError) effs, Member (State EmulatorState) effs, Member (LogMsg EmulatorEvent') effs) => Params -> Eff (MultiAgentEffect : (MultiAgentControlEffect : (ChainEffect : (ChainControlEffect : effs)))) ~> Eff effs

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]

module Wallet.Emulator


-- | A trace is a sequence of actions by simulated wallets that can be run
--   on the mockchain. This module contains the functions needed to build
--   traces.
module Plutus.Contract.Trace

-- | Error produced while running a trace. Either a contract-specific error
--   (of type <tt>e</tt>), or an <a>AssertionError</a> from the emulator.
data TraceError e
TraceAssertionError :: AssertionError -> TraceError e
TContractError :: e -> TraceError e
HookError :: EndpointError -> TraceError e
data EndpointError
EndpointNotActive :: Maybe Wallet -> EndpointDescription -> EndpointError
class AsTraceError r_a5je2 e_a5iSB | r_a5je2 -> e_a5iSB
_TraceError :: AsTraceError r_a5je2 e_a5iSB => Prism' r_a5je2 (TraceError e_a5iSB)
_TraceAssertionError :: AsTraceError r_a5je2 e_a5iSB => Prism' r_a5je2 AssertionError
_TContractError :: AsTraceError r_a5je2 e_a5iSB => Prism' r_a5je2 e_a5iSB
_HookError :: AsTraceError r_a5je2 e_a5iSB => Prism' r_a5je2 EndpointError
toNotifyError :: ContractInstanceId -> EndpointError -> NotificationError
handleAdjustUnbalancedTx :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleSlotNotifications :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleTimeNotifications :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleOwnAddressesQueries :: (Member (LogObserve (LogMessage Text)) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentNodeClientSlotQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentChainIndexSlotQueries :: (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentTimeQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleCurrentNodeClientTimeRangeQueries :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleTimeToSlotConversions :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
handleUnbalancedTransactions :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp

-- | Submit the wallet's pending transactions to the blockchain.
handlePendingTransactions :: (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleChainIndexQueries :: (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexQueryEffect effs) => RequestHandler effs PABReq PABResp
handleOwnInstanceIdQueries :: (Member (LogObserve (LogMessage Text)) effs, Member (Reader ContractInstanceId) effs) => RequestHandler effs PABReq PABResp
handleYieldedUnbalancedTx :: (Member (LogObserve (LogMessage Text)) effs, Member WalletEffect effs) => RequestHandler effs PABReq PABResp
handleGetParams :: (Member (LogObserve (LogMessage Text)) effs, Member NodeClientEffect effs) => RequestHandler effs PABReq PABResp
type InitialDistribution = Map Wallet Value
defaultDist :: InitialDistribution
defaultDistFor :: [Wallet] -> InitialDistribution

-- | A wallet identifier
data Wallet
Wallet :: Maybe String -> WalletId -> Wallet
[prettyWalletName] :: Wallet -> Maybe String
[getWalletId] :: Wallet -> WalletId

-- | Get the cardano address of a mock wallet. (Fails if the wallet is not
--   a mock wallet).
mockWalletAddress :: Wallet -> CardanoAddress

-- | The public key of a mock wallet. (Fails if the wallet is not a mock
--   wallet).
mockWalletPaymentPubKey :: Wallet -> PaymentPubKey

-- | The payment public key hash of a mock wallet. (Fails if the wallet is
--   not a mock wallet).
mockWalletPaymentPubKeyHash :: Wallet -> PaymentPubKeyHash
knownWallets :: [Wallet]
knownWallet :: Integer -> Wallet
instance Plutus.Contract.Trace.AsTraceError (Plutus.Contract.Trace.TraceError e) e
instance Plutus.Contract.Error.AsAssertionError (Plutus.Contract.Trace.TraceError e)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Trace.EndpointError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Trace.EndpointError
instance GHC.Generics.Generic Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show Plutus.Contract.Trace.EndpointError
instance GHC.Classes.Eq Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show e => GHC.Show.Show (Plutus.Contract.Trace.TraceError e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Plutus.Contract.Trace.TraceError e)
instance Prettyprinter.Internal.Pretty Plutus.Contract.Trace.EndpointError


-- | Interfacing with the wallet (for making payments)
module Plutus.Trace.Effects.EmulatedWalletAPI
data EmulatedWalletAPI r
[LiftWallet] :: Wallet -> Eff '[WalletEffect, Error WalletAPIError, LogMsg Text, LogMsg RequestHandlerLogMsg] a -> EmulatedWalletAPI a
liftWallet :: forall a_a5lnF. forall effs_a5loe. Member EmulatedWalletAPI effs_a5loe => Wallet -> Eff ('(:) WalletEffect ('(:) (Error WalletAPIError) ('(:) (LogMsg Text) ('(:) (LogMsg RequestHandlerLogMsg) ('[] :: [Type -> Type]))))) a_a5lnF -> Eff effs_a5loe a_a5lnF

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Handle the <a>EmulatedWalletAPI</a> effect using the emulator's
--   <tt>MultiAgent</tt> effect.
handleEmulatedWalletAPI :: Member MultiAgentEffect effs => EmulatedWalletAPI ~> Eff effs

module Plutus.Trace.Emulator.System

-- | Start the system threads.
launchSystemThreads :: forall effs a. (Member ChainControlEffect effs, Member MultiAgentEffect effs, Member MultiAgentControlEffect effs) => [Wallet] -> Eff (Yield (EmSystemCall effs EmulatorMessage a) (Maybe EmulatorMessage) : effs) ()

-- | Append a block to the chain index for a specific slot.
appendNewTipBlock :: Member ChainIndexControlEffect effs => Tip -> Block -> Slot -> Eff effs ()


-- | Waiting for things to happen
module Plutus.Trace.Effects.Waiting
data Waiting r
[WaitUntilSlot] :: Slot -> Waiting Slot
[GetSlotConfig] :: Waiting SlotConfig
waitUntilSlot :: forall effs_a5n1u. Member Waiting effs_a5n1u => Slot -> Eff effs_a5n1u Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
waitUntilTime :: Member Waiting effs => POSIXTime -> Eff effs POSIXTime

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Convert the given <tt>n</tt> milliseconds to a number of slots to
--   wait.
--   
--   Note: Currently, if n &lt; length of a slot, then
--   <a>waitNMilliSeconds</a> has no effect.
waitNMilliSeconds :: forall effs. Member Waiting effs => DiffMilliSeconds -> Eff effs Slot
handleWaiting :: forall effs effs2 a. Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs => SlotConfig -> Waiting ~> Eff effs

module Plutus.Trace.Effects.Assert
data Assert r
[Assert] :: String -> (EmulatorState -> Bool) -> Assert ()
assert :: forall effs_a5nrh. Member Assert effs_a5nrh => String -> (EmulatorState -> Bool) -> Eff effs_a5nrh ()

-- | Pass <a>EmulatorState</a> to the provided predicate and throw error
--   unless it's true.
handleAssert :: forall effs effs2 a. (Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (Error EmulatorRuntimeError) effs, Member (State EmulatorState) effs) => Assert ~> Eff effs

module Plutus.Contract.Test.Coverage

-- | Get every endpoint name that has been invoked in the emulator events
--   in <tt>es</tt> indexed by <a>ContractInstanceTag</a>
getInvokedEndpoints :: [EmulatorEvent] -> Map ContractInstanceTag (Set String)

-- | Collect every executed coverage annotation in the validators executed
--   in <tt>es</tt>
getCoverageData :: [EmulatorEvent] -> CoverageData
newtype CoverageRef
CoverageRef :: IORef CoverageData -> CoverageRef
newCoverageRef :: IO CoverageRef
readCoverageRef :: CoverageRef -> IO CoverageData

-- | Write a coverage report to name.html for the given index.
writeCoverageReport :: String -> CoverageReport -> IO ()

module Plutus.Trace.Emulator.ContractInstance

-- | Start a new thread for a contract. Most of the work happens in
--   <a>runInstance</a>.
contractThread :: forall w s e effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => ContractHandle w s e -> Eff (EmulatorAgentThreadEffs effs) ()
getThread :: forall effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs) => ContractInstanceId -> Eff effs ThreadId
data EmulatorRuntimeError

-- | Run an instance of a contract
runInstance :: forall w s e effs. (ContractConstraints s, Member (Error EmulatorRuntimeError) effs, Show e, ToJSON e, ToJSON w, Monoid w) => NetworkId -> Contract w s e () -> Maybe EmulatorMessage -> Eff (ContractInstanceThreadEffs w s e effs) ()

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w (s :: Row *) e a
ContractInstanceState :: ResumableResult w e PABResp PABReq a -> Seq (Response PABResp) -> Seq [Request PABReq] -> ContractInstanceState w (s :: Row *) e a
[instContractState] :: ContractInstanceState w (s :: Row *) e a -> ResumableResult w e PABResp PABReq a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w (s :: Row *) e a -> Seq (Response PABResp)

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w (s :: Row *) e a -> Seq [Request PABReq]
emptyInstanceState :: forall w (s :: Row *) e a. Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response PABResp -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)

-- | A block of transactions, indexed by tx outputs spent and by addresses
--   on which new outputs are produced
data IndexedBlock
IndexedBlock :: Map TxIn ChainIndexTx -> Map CardanoAddress (NonEmpty ChainIndexTx) -> IndexedBlock
[ibUtxoSpent] :: IndexedBlock -> Map TxIn ChainIndexTx
[ibUtxoProduced] :: IndexedBlock -> Map CardanoAddress (NonEmpty ChainIndexTx)
indexBlock :: [ChainIndexTx] -> IndexedBlock
getHooks :: forall w s e effs. Member (State (ContractInstanceStateInternal w s e ())) effs => Eff effs [Request PABReq]

-- | Add a <a>Response</a> to the contract instance state
addResponse :: forall w s e effs. (Member (State (ContractInstanceStateInternal w s e ())) effs, Member (LogMsg ContractInstanceMsg) effs, Monoid w) => Response PABResp -> Eff effs ()
instance GHC.Base.Semigroup Plutus.Trace.Emulator.ContractInstance.IndexedBlock
instance GHC.Base.Monoid Plutus.Trace.Emulator.ContractInstance.IndexedBlock


-- | Running emulator actions that produce streams of events
module Wallet.Emulator.Stream
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
ChainIndexErr :: ChainIndexError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr
ExitWasNeverCalled :: EmulatorErr
type InitialChainState = Either InitialDistribution [CardanoTx]
initialChainState :: Lens' EmulatorConfig InitialChainState

-- | The wallets' initial funds
initialDist :: EmulatorConfig -> InitialDistribution
initialState :: EmulatorConfig -> EmulatorState
params :: Lens' EmulatorConfig Params

-- | Turn an emulator action into a <a>Stream</a> of emulator log messages,
--   returning the final state of the emulator.
runTraceStream :: forall effs a. EmulatorConfig -> Eff '[State EmulatorState, LogMsg EmulatorEvent', MultiAgentEffect, MultiAgentControlEffect, ChainEffect, ChainControlEffect, Error EmulatorRuntimeError] (Maybe a) -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)

-- | Finish the stream at the end of the given slot.
takeUntilSlot :: forall effs a. Slot -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) ()

-- | Remove from the stream all log messages whose log level is lower than
--   the the given level.
filterLogLevel :: forall effs a. LogLevel -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a

-- | Apply a fold to an effectful stream of events.
foldStreamM :: forall m a b c. Monad m => FoldM m a b -> Stream (Of a) m c -> m (Of b c)

-- | Consume an emulator event stream.
foldEmulatorStreamM :: forall effs a b. FoldM (Eff effs) EmulatorEvent b -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Eff effs (Of b a)
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Classes.Eq Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorErr
instance Data.Default.Class.Default Wallet.Emulator.Stream.EmulatorConfig

module Wallet.Emulator.Folds
type EmulatorEventFold a = Fold EmulatorEvent a

-- | A fold over emulator events that can fail with <a>EmulatorFoldErr</a>
type EmulatorEventFoldM effs a = FoldM (Eff effs) EmulatorEvent a
data EmulatorFoldErr
InstanceStateJSONDecodingError :: String -> Response Value -> EmulatorFoldErr

-- | A human-readable explanation of the error, to be included in the logs.
describeError :: EmulatorFoldErr -> String

-- | The state of a contract instance, recovered from the emulator log.
instanceState :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Maybe (ContractInstanceState w s e a))

-- | The list of open requests of the contract instance at its latest
--   iteration
instanceRequests :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Request PABReq]

-- | The reponses received by the contract instance
instanceResponses :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Response PABResp]

-- | The final state of the instance
instanceOutcome :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Outcome e a)

-- | The unbalanced transactions generated by the contract instance.
instanceTransactions :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [UnbalancedTx]
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a

-- | The log messages produced by the contract instance.
instanceLog :: ContractInstanceTag -> EmulatorEventFold [EmulatorTimeEvent ContractInstanceLog]

-- | Accumulated state of the contract instance
instanceAccumState :: forall w s e a effs. (Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs w

-- | All chain events emitted by the node
chainEvents :: EmulatorEventFold [ChainEvent]

-- | Transactions that failed to validate, in the given validation phase
--   (if specified).
failedTransactions :: Maybe ValidationPhase -> EmulatorEventFold [(CardanoTx, ValidationError, Value)]

-- | Transactions that were validated
validatedTransactions :: EmulatorEventFold [(OnChainTx, RedeemerReport)]

-- | Unspent outputs at an address
utxoAtAddress :: CardanoAddress -> EmulatorEventFold UtxoMap

-- | The total value of unspent outputs at an address
valueAtAddress :: CardanoAddress -> EmulatorEventFold Value

-- | The funds belonging to a wallet
walletFunds :: Wallet -> EmulatorEventFold Value

-- | The fees paid by a wallet
walletFees :: Wallet -> EmulatorEventFold Lovelace

-- | Unbalanced transactions that are sent to the wallet for balancing
walletTxBalanceEvents :: EmulatorEventFold [UnbalancedTx]

-- | Min lovelace of <tt>txOut</tt>s from adjusted unbalanced transactions
--   for all wallets
walletsAdjustedTxEvents :: EmulatorEventFold [Lovelace]

-- | Annotate the transactions that were validated by the node
annotatedBlockchain :: EmulatorEventFold [[AnnotatedTx]]

-- | All transactions that happened during the simulation
blockchain :: EmulatorEventFold [Block]

-- | The list of all emulator events
emulatorLog :: EmulatorEventFold [EmulatorEvent]

-- | Log and error messages produced by the main (user) thread in the
--   emulator
userLog :: EmulatorEventFold [EmulatorTimeEvent UserThreadMsg]

-- | Pretty-print each element into a new line.
renderLines :: forall a. Pretty a => Fold a Text

-- | An effectful <a>mapMaybe</a> for <a>FoldM</a>.
preMapMaybeM :: Monad m => (a -> m (Maybe b)) -> FoldM m b r -> FoldM m a r

-- | <a>mapMaybe</a> for <a>Fold</a>.
preMapMaybe :: (a -> Maybe b) -> Fold b r -> Fold a r

-- | Effectfully map the result of a <a>FoldM</a>
postMapM :: Monad m => (b -> m c) -> FoldM m a b -> FoldM m a c
mkTxLogs :: EmulatorEventFold [MkTxLog]
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Wallet.Emulator.Folds.Outcome e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Wallet.Emulator.Folds.Outcome e a)
instance GHC.Show.Show Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Ord Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Eq Wallet.Emulator.Folds.EmulatorFoldErr

module Wallet.Rollup.Render
showBlockchain :: [(PaymentPubKeyHash, Wallet)] -> Blockchain -> Either Text Text
showBlockchainFold :: [(PaymentPubKeyHash, Wallet)] -> EmulatorEventFold (Either Text Text)
instance Wallet.Rollup.Render.Render PlutusCore.Data.Data
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.Value
instance Wallet.Rollup.Render.Render Data.Text.Internal.Text
instance Wallet.Rollup.Render.Render GHC.Base.String
instance Wallet.Rollup.Render.Render GHC.Integer.Type.Integer
instance Wallet.Rollup.Render.Render GHC.Types.Word
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Address.Address
instance Wallet.Rollup.Render.Render Cardano.Api.Value.Value
instance Wallet.Rollup.Render.Render Cardano.Api.Value.Lovelace
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxId
instance Wallet.Rollup.Render.Render Cardano.Api.TxIn.TxId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.ValidatorHash
instance Prettyprinter.Internal.Pretty a => Wallet.Rollup.Render.Render (Wallet.Rollup.Render.RenderPretty a)
instance (Wallet.Rollup.Render.Render a, Wallet.Rollup.Render.Render b) => Wallet.Rollup.Render.Render (Data.Either.Either a b)
instance Wallet.Rollup.Render.Render [[Wallet.Rollup.Types.AnnotatedTx]]
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.AnnotatedTx
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.SequenceId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.CurrencySymbol
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.TokenName
instance Wallet.Rollup.Render.Render PlutusTx.Builtins.Internal.BuiltinByteString
instance Wallet.Rollup.Render.Render PlutusTx.Builtins.Internal.BuiltinData
instance (Wallet.Rollup.Render.Render k, Wallet.Rollup.Render.Render v) => Wallet.Rollup.Render.Render (PlutusTx.AssocMap.Map k v)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Wallet.Rollup.Types.BeneficialOwner Plutus.V1.Ledger.Value.Value)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Ledger.Crypto.PubKey Ledger.Crypto.Signature)
instance Wallet.Rollup.Render.Render Wallet.Emulator.Wallet.Wallet
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.BeneficialOwner
instance Wallet.Rollup.Render.Render Plutus.Script.Utils.Ada.Ada
instance Wallet.Rollup.Render.Render (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Wallet.Rollup.Render.Render Ledger.Crypto.PubKey
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Crypto.PubKeyHash
instance Wallet.Rollup.Render.Render Ledger.Address.PaymentPubKey
instance Wallet.Rollup.Render.Render Ledger.Address.PaymentPubKeyHash
instance Wallet.Rollup.Render.Render Ledger.Crypto.Signature
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Script
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Validator
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Datum
instance Wallet.Rollup.Render.Render a => Wallet.Rollup.Render.Render (Data.Set.Internal.Set a)
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.DereferencedInput
instance Wallet.Rollup.Render.Render a => Wallet.Rollup.Render.Render (Plutus.Script.Utils.Scripts.Versioned a)
instance Wallet.Rollup.Render.Render Cardano.Ledger.Alonzo.Language.Language
instance Wallet.Rollup.Render.Render Cardano.Api.TxIn.TxIn
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxOutRef
instance Wallet.Rollup.Render.Render Ledger.Tx.Internal.TxOut
instance Codec.Serialise.Class.Serialise (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.ToJSON.ToJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.FromJSON.FromJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)

module Plutus.Trace.Effects.EmulatorControl
data EmulatorControl r
[SetSigningProcess] :: Wallet -> Maybe SigningProcess -> EmulatorControl ()
[AgentState] :: Wallet -> EmulatorControl WalletState
[FreezeContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ThawContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ChainState] :: EmulatorControl ChainState
[GetParams] :: EmulatorControl Params
[GetSlotConfig] :: EmulatorControl SlotConfig
[DiscardWallets] :: (Wallet -> Bool) -> EmulatorControl ()
setSigningProcess :: forall effs_a5IMh. Member EmulatorControl effs_a5IMh => Wallet -> Maybe SigningProcess -> Eff effs_a5IMh ()
agentState :: forall effs_a5IMi. Member EmulatorControl effs_a5IMi => Wallet -> Eff effs_a5IMi WalletState
freezeContractInstance :: forall effs_a5IMj. Member EmulatorControl effs_a5IMj => ContractInstanceId -> Eff effs_a5IMj ()
thawContractInstance :: forall effs_a5IMk. Member EmulatorControl effs_a5IMk => ContractInstanceId -> Eff effs_a5IMk ()
chainState :: forall effs_a5IMl. Member EmulatorControl effs_a5IMl => Eff effs_a5IMl ChainState
getParams :: forall effs_a5IMm. Member EmulatorControl effs_a5IMm => Eff effs_a5IMm Params
discardWallets :: forall effs_a5IMo. Member EmulatorControl effs_a5IMo => (Wallet -> Bool) -> Eff effs_a5IMo ()

-- | Interpret the <a>EmulatorControl</a> effect in the
--   <tt>MultiAgentEffect</tt> and scheduler system calls.
handleEmulatorControl :: forall effs effs2 a. (Member (State EmulatorThreads) effs, Member (State EmulatorState) effs, Member (Error EmulatorRuntimeError) effs, Member MultiAgentControlEffect effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => Params -> EmulatorControl ~> Eff effs
getSlotConfig :: forall effs_a5IMn. Member EmulatorControl effs_a5IMn => Eff effs_a5IMn SlotConfig

module Plutus.Trace.Effects.RunContract

-- | Run a Plutus contract (client side)
data RunContract r
[CallEndpointP] :: forall l ep w s e. (ContractConstraints s, HasEndpoint l ep s, ToJSON ep) => Proxy l -> ContractHandle w s e -> ep -> RunContract ()
[GetContractState] :: forall w s e. (ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> RunContract (ContractInstanceState w s e ())

-- | Start a Plutus contract (client side)
data StartContract r
[ActivateContract] :: (IsContract contract, ContractConstraints s, Show e, FromJSON e, ToJSON e, ToJSON w, Monoid w, FromJSON w) => Wallet -> contract w s e a -> ContractInstanceTag -> StartContract (ContractHandle w s e)
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
activateContract :: forall (contract_X5JmE :: Type -> Row Type -> Type -> Type -> Type) (s_X5JmG :: Row Type) e_X5JmI w_X5JmK a_X5JmM. (IsContract contract_X5JmE, ContractConstraints s_X5JmG, Show e_X5JmI, FromJSON e_X5JmI, ToJSON e_X5JmI, ToJSON w_X5JmK, Monoid w_X5JmK, FromJSON w_X5JmK) => forall effs_a5JoQ. Member StartContract effs_a5JoQ => Wallet -> contract_X5JmE w_X5JmK s_X5JmG e_X5JmI a_X5JmM -> ContractInstanceTag -> Eff effs_a5JoQ (ContractHandle w_X5JmK s_X5JmG e_X5JmI)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall contract w s e effs. (IsContract contract, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member StartContract effs, Monoid w) => Wallet -> contract w s e () -> Eff effs (ContractHandle w s e)

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ToJSON ep, ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X5Jp5 (s_X5Jp7 :: Row Type) e_X5Jp9. (ContractConstraints s_X5Jp7, FromJSON e_X5Jp9, FromJSON w_X5Jp5, ToJSON w_X5Jp5) => forall effs_a5JtX. Member RunContract effs_a5JtX => ContractHandle w_X5Jp5 s_X5Jp7 e_X5Jp9 -> Eff effs_a5JtX (ContractInstanceState w_X5Jp5 s_X5Jp7 e_X5Jp9 ())

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Handle the <a>RunContract</a> effect by running each contract instance
--   in an emulator thread.
handleRunContract :: forall effs effs2 a. (Member (State EmulatorThreads) effs2, Member (Error EmulatorRuntimeError) effs2, Member (Error EmulatorRuntimeError) effs, Member (LogMsg EmulatorEvent') effs, Member (State EmulatorThreads) effs, Member (Reader ThreadId) effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => RunContract ~> Eff effs

-- | Handle the <a>StartContract</a> effect by starting each contract
--   instance in an emulator thread.
handleStartContract :: forall effs effs2 a. (Member (State EmulatorThreads) effs2, Member (Error EmulatorRuntimeError) effs2, Member MultiAgentEffect effs2, Member (LogMsg EmulatorEvent') effs2, Member ContractInstanceIdEff effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs) => NetworkId -> StartContract ~> Eff effs

-- | Start a new thread for a contract instance (given by the handle). The
--   thread runs in the context of the wallet.
startContractThread :: forall w s e effs effs2 a. (Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (Error EmulatorRuntimeError) effs2, Member (LogMsg EmulatorEvent') effs2, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => Wallet -> ContractHandle w s e -> Eff effs (Maybe EmulatorMessage)

module Plutus.Trace.Emulator
data Emulator
type EmulatorTrace = Eff EmulatorEffects
type EmulatorEffects = StartContract : BaseEmulatorEffects
type BaseEmulatorEffects = [RunContract, Assert, Waiting, EmulatorControl, EmulatedWalletAPI, LogMsg String, Error EmulatorRuntimeError]
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
ChainIndexErr :: ChainIndexError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr
ExitWasNeverCalled :: EmulatorErr

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> NetworkId -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag
[chNetworkId] :: ContractHandle w s e -> NetworkId

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
assert :: forall effs_a5nrh. Member Assert effs_a5nrh => String -> (EmulatorState -> Bool) -> Eff effs_a5nrh ()
activateContract :: forall (contract_X5JmE :: Type -> Row Type -> Type -> Type -> Type) (s_X5JmG :: Row Type) e_X5JmI w_X5JmK a_X5JmM. (IsContract contract_X5JmE, ContractConstraints s_X5JmG, Show e_X5JmI, FromJSON e_X5JmI, ToJSON e_X5JmI, ToJSON w_X5JmK, Monoid w_X5JmK, FromJSON w_X5JmK) => forall effs_a5JoQ. Member StartContract effs_a5JoQ => Wallet -> contract_X5JmE w_X5JmK s_X5JmG e_X5JmI a_X5JmM -> ContractInstanceTag -> Eff effs_a5JoQ (ContractHandle w_X5JmK s_X5JmG e_X5JmI)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall contract w s e effs. (IsContract contract, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member StartContract effs, Monoid w) => Wallet -> contract w s e () -> Eff effs (ContractHandle w s e)

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ToJSON ep, ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X5Jp5 (s_X5Jp7 :: Row Type) e_X5Jp9. (ContractConstraints s_X5Jp7, FromJSON e_X5Jp9, FromJSON w_X5Jp5, ToJSON w_X5Jp5) => forall effs_a5JtX. Member RunContract effs_a5JtX => ContractHandle w_X5Jp5 s_X5Jp7 e_X5Jp9 -> Eff effs_a5JtX (ContractInstanceState w_X5Jp5 s_X5Jp7 e_X5Jp9 ())

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]
liftWallet :: forall a_a5lnF. forall effs_a5loe. Member EmulatedWalletAPI effs_a5loe => Wallet -> Eff ('(:) WalletEffect ('(:) (Error WalletAPIError) ('(:) (LogMsg Text) ('(:) (LogMsg RequestHandlerLogMsg) ('[] :: [Type -> Type]))))) a_a5lnF -> Eff effs_a5loe a_a5lnF

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot
waitUntilSlot :: forall effs_a5n1u. Member Waiting effs_a5n1u => Slot -> Eff effs_a5n1u Slot

-- | Wait until the slot where the given time falls into and return latest
--   time we know has passed.
waitUntilTime :: Member Waiting effs => POSIXTime -> Eff effs POSIXTime

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Convert the given <tt>n</tt> milliseconds to a number of slots to
--   wait.
--   
--   Note: Currently, if n &lt; length of a slot, then
--   <a>waitNMilliSeconds</a> has no effect.
waitNMilliSeconds :: forall effs. Member Waiting effs => DiffMilliSeconds -> Eff effs Slot
freezeContractInstance :: forall effs_a5IMj. Member EmulatorControl effs_a5IMj => ContractInstanceId -> Eff effs_a5IMj ()
thawContractInstance :: forall effs_a5IMk. Member EmulatorControl effs_a5IMk => ContractInstanceId -> Eff effs_a5IMk ()
setSigningProcess :: forall effs_a5IMh. Member EmulatorControl effs_a5IMh => Wallet -> Maybe SigningProcess -> Eff effs_a5IMh ()
chainState :: forall effs_a5IMl. Member EmulatorControl effs_a5IMl => Eff effs_a5IMl ChainState
getSlotConfig :: forall effs_a5IMn. Member EmulatorControl effs_a5IMn => Eff effs_a5IMn SlotConfig
chainNewestFirst :: Lens' ChainState Blockchain
txPool :: Lens' ChainState TxPool
index :: Lens' ChainState UtxoIndex
chainCurrentSlot :: Lens' ChainState Slot
agentState :: forall effs_a5IMi. Member EmulatorControl effs_a5IMi => Wallet -> Eff effs_a5IMi WalletState
ownPaymentPrivateKey :: WalletState -> PaymentPrivateKey
nodeClient :: Lens' WalletState NodeClientState
signingProcess :: Lens' WalletState (Maybe SigningProcess)
throwError :: forall e (effs :: [Type -> Type]) a. Member (Error e) effs => e -> Eff effs a
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
EmulatorJSONDecodingError :: String -> Value -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError
EmulatedWalletError :: WalletAPIError -> EmulatorRuntimeError
AssertionError :: String -> EmulatorRuntimeError
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
initialChainState :: Lens' EmulatorConfig InitialChainState
params :: Lens' EmulatorConfig Params

-- | Run a 'Trace Emulator', streaming the log messages as they arrive
runEmulatorStream :: forall effs a. EmulatorConfig -> EmulatorTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)

-- | Options for how to set up and print the trace.
data TraceConfig
TraceConfig :: (LogMessage EmulatorEvent -> Maybe String) -> Handle -> LogLevel -> TraceConfig

-- | Function to decide how to print the particular events.
[traceConfigShowEvent] :: TraceConfig -> LogMessage EmulatorEvent -> Maybe String

-- | Where to print the outputs to. Default: <a>stdout</a>
[traceConfigOutputHandle] :: TraceConfig -> Handle
[traceConfigMinLogLevel] :: TraceConfig -> LogLevel

-- | Some example of how to configure the <a>traceConfigShowEvent</a>.
traceConfigShowEventExample :: LogMessage EmulatorEvent -> Maybe String

-- | Run an emulator trace to completion, returning a tuple of the final
--   state of the emulator, the events, and any error, if any.
runEmulatorTrace :: TraceConfig -> EmulatorConfig -> EmulatorTrace a -> ([LogMessage EmulatorEvent], Either EmulatorErr a, EmulatorState)
evalEmulatorTrace :: TraceConfig -> EmulatorConfig -> EmulatorTrace a -> Either EmulatorErr a

-- | A very simple effect for interpreting the output printing done by the
--   trace printing functions:
--   
--   <ul>
--   <li><a>runEmulatorTraceEff</a></li>
--   <li><a>runEmulatorTraceIO</a></li>
--   <li><a>runEmulatorTraceIOWithConfig</a></li>
--   </ul>
data PrintEffect r
[PrintLn] :: String -> PrintEffect ()

-- | Run the emulator trace returning an effect that can be evaluated by
--   interpreting the <a>PrintEffect</a>s.
runEmulatorTraceEff :: forall effs. Member PrintEffect effs => TraceConfig -> EmulatorConfig -> EmulatorTrace () -> Eff effs ()

-- | Runs the trace with <a>runEmulatorTrace</a>, with default
--   configuration that prints a selection of events to stdout.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; runEmulatorTraceIO (void $ Trace.waitNSlots 1)
--   </pre>
runEmulatorTraceIO :: EmulatorTrace () -> IO ()

-- | <i>Deprecated: Renamed to runEmulatorTraceIOWithConfig</i>
runEmulatorTraceIO' :: TraceConfig -> EmulatorConfig -> EmulatorTrace () -> IO ()

-- | Interpret a 'Trace Emulator' action in the multi agent and emulated
--   blockchain effects.
interpretEmulatorTrace :: forall effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, Member (State EmulatorState) effs) => EmulatorConfig -> EmulatorTrace a -> Eff effs (Maybe a)
instance Data.Default.Class.Default Plutus.Trace.Emulator.TraceConfig

module Plutus.Trace.Emulator.Extract
data ValidatorMode
FullyAppliedValidators :: ValidatorMode
UnappliedValidators :: ValidatorMode

-- | Run an emulator trace and write the applied scripts to a file in Flat
--   format using the name as a prefix.
writeScriptsTo :: ScriptsConfig -> String -> EmulatorTrace a -> EmulatorConfig -> IO (Sum Int64, ExBudget)
showStats :: Int64 -> ExBudget -> String

-- | Configuration for <a>writeScriptsTo</a>
data ScriptsConfig
ScriptsConfig :: FilePath -> Command -> ScriptsConfig

-- | Folder the extracted scripts should be written to
[scPath] :: ScriptsConfig -> FilePath

-- | Whether to write out complete transactions or just the validator
--   scripts
[scCommand] :: ScriptsConfig -> Command

-- | Command for <a>writeScriptsTo</a>
data Command

-- | Write out validator scripts only (flat encoding)
Scripts :: ValidatorMode -> Command

-- | Whether to write fully applied or unapplied validators
[unappliedValidators] :: Command -> ValidatorMode

-- | Write out partial transactions
Transactions :: NetworkId -> FilePath -> Command

-- | Network ID to use when creating addresses
[networkId] :: Command -> NetworkId

-- | Location of a JSON file with protocol parameters
[protocolParamsJSON] :: Command -> FilePath

-- | Write out the arguments and results of <tt>mkTx</tt> calls
MkTxLogs :: Command
instance GHC.Show.Show Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Ord Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Eq Plutus.Trace.Emulator.Extract.ValidatorMode
instance GHC.Classes.Eq Plutus.Trace.Emulator.Extract.Command
instance GHC.Show.Show Plutus.Trace.Emulator.Extract.Command

module Plutus.Trace
data SchedulerLog
data ThreadEvent


-- | Testing contracts with HUnit and Tasty
module Plutus.Contract.Test
newtype TracePredicateF a
TracePredicate :: (forall effs. Members TestEffects effs => FoldM (Eff effs) EmulatorEvent a) -> TracePredicateF a
type TracePredicate = TracePredicateF Bool
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
not :: TracePredicate -> TracePredicate
(.&&.) :: TracePredicate -> TracePredicate -> TracePredicate
infixl 3 .&&.
(.||.) :: TracePredicate -> TracePredicate -> TracePredicate
infixl 2 .||.
w1 :: Wallet
w2 :: Wallet
w3 :: Wallet
w4 :: Wallet
w5 :: Wallet
w6 :: Wallet
w7 :: Wallet
w8 :: Wallet
w9 :: Wallet
w10 :: Wallet
endpointAvailable :: forall (l :: Symbol) w s e a. (KnownSymbol l, Monoid w) => Contract w s e a -> ContractInstanceTag -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   finished without errors.
assertDone :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (a -> Bool) -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   is waiting for input.
assertNotDone :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   failed with an error.
assertContractError :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (e -> Bool) -> String -> TracePredicate
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a
assertOutcome :: forall contract w s e a. (Monoid w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (Outcome e a -> Bool) -> String -> TracePredicate
assertInstanceLog :: ContractInstanceTag -> ([EmulatorTimeEvent ContractInstanceLog] -> Bool) -> TracePredicate

-- | Assert that no transaction failed to validate.
assertNoFailedTransactions :: TracePredicate

-- | Assert that n transactions validated, and no transaction failed to
--   validate.
assertValidatedTransactionCount :: Int -> TracePredicate

-- | Assert that n transactions validated, and the rest failed.
assertValidatedTransactionCountOfTotal :: Int -> Int -> TracePredicate

-- | Assert that at least one transaction failed to validate, and that all
--   transactions that failed meet the predicate.
assertFailedTransaction :: (CardanoTx -> ValidationError -> Bool) -> TracePredicate

-- | Assert that at least one transaction failed to validate with an
--   EvaluationError containing the given text.
assertEvaluationError :: Text -> TracePredicate
assertHooks :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([PABReq] -> Bool) -> String -> TracePredicate

-- | Make an assertion about the responses provided to the contract
--   instance.
assertResponses :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([Response PABResp] -> Bool) -> String -> TracePredicate
assertUserLog :: ([EmulatorTimeEvent UserThreadMsg] -> Bool) -> TracePredicate

-- | An assertion about the blockchain
assertBlockchain :: ([Block] -> Bool) -> TracePredicate

-- | An assertion about the chain events
assertChainEvents :: ([ChainEvent] -> Bool) -> TracePredicate

-- | An assertion about the chain events with a custom error message
assertChainEvents' :: ([ChainEvent] -> String) -> ([ChainEvent] -> Bool) -> TracePredicate

-- | Make an assertion about the accumulated state <tt>w</tt> of a contract
--   instance.
assertAccumState :: forall contract w s e a. (Monoid w, Show w, IsContract contract) => contract w s e a -> ContractInstanceTag -> (w -> Bool) -> String -> TracePredicate
data Shrinking
DoShrink :: Shrinking
DontShrink :: Shrinking

-- | make an assertion about the <a>ContractInstanceState</a> of a contract
--   instance
assertResumableResult :: forall w s e a. (Monoid w, Show e, Show a, Show w) => Contract w s e a -> ContractInstanceTag -> Shrinking -> (ResumableResult w e PABResp PABReq a -> Bool) -> String -> TracePredicate
assertUnbalancedTx :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> (UnbalancedTx -> Bool) -> String -> TracePredicate
anyUnbalancedTx :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> TracePredicate
assertEvents :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> ([PABResp] -> Bool) -> String -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   exluding fees, using the Plutus <tt>Value</tt> type.
walletFundsChangePlutus :: Wallet -> Value -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   exluding fees.
walletFundsChange :: Wallet -> Value -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   including fees.
walletFundsExactChange :: Wallet -> Value -> TracePredicate
walletFundsAssetClassChange :: Wallet -> AssetId -> Integer -> TracePredicate
walletPaidFees :: Wallet -> Lovelace -> TracePredicate
waitingForSlot :: forall w s e a. Monoid w => Contract w s e a -> ContractInstanceTag -> Slot -> TracePredicate

-- | Check that the funds at an address meet some condition.
valueAtAddress :: CardanoAddress -> (Value -> Bool) -> TracePredicate
plutusValueAtAddress :: CardanoAddress -> (Value -> Bool) -> TracePredicate
dataAtAddress :: forall d. FromData d => CardanoAddress -> ([d] -> Bool) -> TracePredicate

-- | Assert that the size of a <tt>Validator</tt> is below the maximum.
reasonable :: Validator -> Integer -> Assertion
reasonable' :: (String -> IO ()) -> Validator -> Integer -> Assertion

-- | Check if the emulator trace meets the condition
checkPredicate :: String -> TracePredicate -> EmulatorTrace () -> TestTree
checkPredicateCoverage :: String -> CoverageRef -> TracePredicate -> EmulatorTrace () -> TestTree
checkPredicateCoverageOptions :: CheckOptions -> String -> CoverageRef -> TracePredicate -> EmulatorTrace () -> TestTree

-- | A version of <a>checkPredicate</a> with configurable
--   <a>CheckOptions</a>
checkPredicateOptions :: CheckOptions -> String -> TracePredicate -> EmulatorTrace () -> TestTree

-- | Check if the emulator trace meets the condition, using the
--   <a>GeneratorModel</a> to generate initial transactions for the
--   blockchain
checkPredicateGen :: GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | A version of <a>checkPredicateGen</a> with configurable
--   <a>CheckOptions</a>.
--   
--   Note that the <tt>InitialChainState</tt> in the <a>EmulatorConfig</a>
--   of the <a>CheckOptions</a> will be replaced with the
--   <a>mockchainInitialTxPool</a> generated by the model.
checkPredicateGenOptions :: CheckOptions -> GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | Evaluate a trace predicate on an emulator trace, printing out debug
--   information and making assertions as we go.
checkPredicateInner :: forall m a. Monad m => CheckOptions -> TracePredicate -> EmulatorTrace a -> (String -> m ()) -> (Bool -> m ()) -> (CoverageData -> m ()) -> m (Either EmulatorErr a)
checkPredicateInnerStream :: forall m a. Monad m => CheckOptions -> TracePredicate -> (forall effs. Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a)) -> (String -> m ()) -> (Bool -> m ()) -> (CoverageData -> m ()) -> m (Either EmulatorErr a)

-- | Check if the emulator trace fails with the condition
checkEmulatorFails :: String -> CheckOptions -> TracePredicate -> EmulatorTrace () -> TestTree

-- | Options for running the
data CheckOptions
CheckOptions :: LogLevel -> EmulatorConfig -> CheckOptions

-- | Minimum log level for emulator log messages to be included in the test
--   output (printed if the test fails)
[_minLogLevel] :: CheckOptions -> LogLevel
[_emulatorConfig] :: CheckOptions -> EmulatorConfig
defaultCheckOptions :: CheckOptions
minLogLevel :: Lens' CheckOptions LogLevel
emulatorConfig :: Lens' CheckOptions EmulatorConfig

-- | Modify the value assigned to the given wallet in the initial
--   distribution.
changeInitialWalletValue :: Wallet -> (Value -> Value) -> CheckOptions -> CheckOptions

-- | Set higher limits on transaction size and execution units. This can be
--   used to work around <tt>MaxTxSizeUTxO</tt> and
--   <tt>ExUnitsTooBigUTxO</tt> errors. Note that if you need this your
--   Plutus script will probably not validate on Mainnet.
increaseTransactionLimits :: CheckOptions -> CheckOptions

-- | Compare a golden PIR file to the provided <a>CompiledCode</a>.
goldenPir :: FilePath -> CompiledCode a -> TestTree
instance GHC.Show.Show Plutus.Contract.Test.Shrinking
instance GHC.Classes.Ord Plutus.Contract.Test.Shrinking
instance GHC.Classes.Eq Plutus.Contract.Test.Shrinking
instance GHC.Base.Functor Plutus.Contract.Test.TracePredicateF
instance GHC.Base.Applicative Plutus.Contract.Test.TracePredicateF


-- | A version of <a>RunContract</a> for use in the playground.
module Plutus.Trace.Effects.RunContractPlayground
data RunContractPlayground r
callEndpoint :: forall effs_a61Iq. Member RunContractPlayground effs_a61Iq => Wallet -> String -> Value -> Eff effs_a61Iq ()
launchContract :: forall effs_a61Ip. Member RunContractPlayground effs_a61Ip => Wallet -> Eff effs_a61Ip ()

-- | Handle the <a>RunContractPlayground</a> effect.
handleRunContractPlayground :: forall w s e effs effs2 a. (ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w, Member ContractInstanceIdEff effs, Member (Yield (EmSystemCall effs2 EmulatorMessage a) (Maybe EmulatorMessage)) effs, Member (LogMsg EmulatorEvent') effs2, Member (Error EmulatorRuntimeError) effs2, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (State (Map Wallet ContractInstanceId)) effs2, Member (State (Map Wallet ContractInstanceId)) effs) => NetworkId -> Contract w s e () -> RunContractPlayground ~> Eff effs

module Plutus.Trace.Playground
type PlaygroundTrace a = Eff '[RunContractPlayground, Error EmulatorRuntimeError, Waiting, EmulatedWalletAPI] a
waitUntilSlot :: forall effs_a5n1u. Member Waiting effs_a5n1u => Slot -> Eff effs_a5n1u Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId
callEndpoint :: forall effs_a61Iq. Member RunContractPlayground effs_a61Iq => Wallet -> String -> Value -> Eff effs_a61Iq ()
data EmulatorConfig
EmulatorConfig :: InitialChainState -> Params -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState

-- | Set the protocol parameters, network ID and slot configuration for the
--   emulator.
[_params] :: EmulatorConfig -> Params
initialChainState :: Lens' EmulatorConfig InitialChainState

-- | Run a 'Trace Playground', streaming the log messages as they arrive
runPlaygroundStream :: forall w s e effs a. (ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => EmulatorConfig -> Contract w s e () -> PlaygroundTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr a, EmulatorState)
interpretPlaygroundTrace :: forall w s e effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => EmulatorConfig -> Contract w s e () -> [Wallet] -> PlaygroundTrace a -> Eff effs (Maybe a)

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

module Plutus.Contract.StateMachine

-- | Client-side definition of a state machine.
data StateMachineClient s i
StateMachineClient :: StateMachineInstance s i -> ([OnChainState s i] -> Either SMContractError (OnChainState s i)) -> StateMachineClient s i

-- | The instance of the state machine, defining the machine's transitions,
--   its final states and its check function.
[scInstance] :: StateMachineClient s i -> StateMachineInstance s i

-- | A function that chooses the relevant on-chain state, given a list of
--   all potential on-chain states found at the contract address.
[scChooser] :: StateMachineClient s i -> [OnChainState s i] -> Either SMContractError (OnChainState s i)
data TxConstraints i o
data SMContractError
ChooserError :: Text -> SMContractError
UnableToExtractTransition :: SMContractError
SMCContractError :: ContractError -> SMContractError
class AsSMContractError r_a64Pp
_SMContractError :: AsSMContractError r_a64Pp => Prism' r_a64Pp SMContractError
_ChooserError :: AsSMContractError r_a64Pp => Prism' r_a64Pp Text
_UnableToExtractTransition :: AsSMContractError r_a64Pp => Prism' r_a64Pp ()
_SMCContractError :: AsSMContractError r_a64Pp => Prism' r_a64Pp ContractError

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe ThreadToken -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <tt>ThreadToken</tt> that identifies the contract instance. Make
--   one with <tt>getThreadToken</tt> and pass it on to
--   <a>mkStateMachine</a>. Initialising the machine will then mint a
--   thread token value.
[smThreadToken] :: StateMachine s i -> Maybe ThreadToken
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value

-- | Typed representation of the on-chain state of a state machine instance
newtype OnChainState s i
OnChainState :: TypedScriptTxOutRef (StateMachine s i) -> OnChainState s i

-- | Typed UTXO
[ocsTxOutRef] :: OnChainState s i -> TypedScriptTxOutRef (StateMachine s i)

-- | The outcome of <a>waitForUpdateTimeout</a>
data WaitingResult t i s

-- | The timeout happened before any change of the on-chain state was
--   detected
Timeout :: t -> WaitingResult t i s

-- | The state machine instance ended
ContractEnded :: i -> WaitingResult t i s

-- | The state machine instance transitioned to a new state
Transition :: i -> s -> WaitingResult t i s

-- | The state machine instance was initialised
InitialState :: s -> WaitingResult t i s

-- | An invalid transition
data InvalidTransition s i
InvalidTransition :: Maybe (State s) -> i -> InvalidTransition s i

-- | Current state. <a>Nothing</a> indicates that there is no current
--   state.
[tfState] :: InvalidTransition s i -> Maybe (State s)

-- | Transition that was attempted but failed
[tfInput] :: InvalidTransition s i -> i

-- | Result of an attempted transition
data TransitionResult s i

-- | The transition is not allowed
TransitionFailure :: InvalidTransition s i -> TransitionResult s i

-- | The transition is allowed and results in a new state
TransitionSuccess :: s -> TransitionResult s i
data ThreadToken
ThreadToken :: TxOutRef -> CurrencySymbol -> ThreadToken

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. ToData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe ThreadToken -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i

-- | A state machine client with the <a>defaultChooser</a> function
mkStateMachineClient :: forall state input. StateMachineInstance state input -> StateMachineClient state input

-- | A state chooser function that fails if confronted with anything other
--   than exactly one output
defaultChooser :: forall state input. [OnChainState state input] -> Either SMContractError (OnChainState state input)
getStates :: forall s i. (FromData s, ToData s) => StateMachineInstance s i -> Map TxOutRef DecoratedTxOut -> [OnChainState s i]

-- | Tries to run one step of a state machine: If the <i>guard</i> (the
--   last argument) returns <tt><a>Nothing</a></tt> when given the
--   unbalanced transaction to be submitted, the old state and the new
--   step, the step is run and <tt><a>Right</a></tt> the new state is
--   returned. If the guard returns <tt><a>Just</a> a</tt>, <tt><a>Left</a>
--   a</tt> is returned instead.
runGuardedStep :: forall w a e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => StateMachineClient state input -> input -> (UnbalancedTx -> state -> state -> Maybe a) -> Contract w schema e (Either a (TransitionResult state input))

-- | Run one step of a state machine, returning the new state.
runStep :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => StateMachineClient state input -> input -> Contract w schema e (TransitionResult state input)

-- | Initialise a state machine
runInitialise :: forall w e state schema input. (FromData state, ToData state, ToData input, AsSMContractError e) => StateMachineClient state input -> state -> Value -> Contract w schema e state

-- | The same as <a>runGuardedStep</a> but we can supply additional
--   constraints and lookups for transaction.
runGuardedStepWith :: forall w a e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> input -> (UnbalancedTx -> state -> state -> Maybe a) -> Contract w schema e (Either a (TransitionResult state input))

-- | Run one step of a state machine, returning the new state. We can
--   supply additional constraints and lookups for transaction.
runStepWith :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state, ToData input) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> input -> Contract w schema e (TransitionResult state input)

-- | Initialise a state machine and supply additional constraints and
--   lookups for transaction.
runInitialiseWith :: forall w e state schema input. (FromData state, ToData state, ToData input, AsSMContractError e) => ScriptLookups (StateMachine state input) -> TxConstraints input state -> StateMachineClient state input -> state -> Value -> Contract w schema e state

-- | Create a thread token. The thread token contains a reference to an
--   unspent output of the wallet, so it needs to used with
--   <tt>mkStateMachine</tt> immediately, and the machine must be
--   initialised, to prevent the output from getting spent in the mean
--   time.
getThreadToken :: AsSMContractError e => Contract w schema e ThreadToken

-- | Get the current on-chain state of the state machine instance. Return
--   Nothing if there is no state on chain. Throws an
--   <tt>SMContractError</tt> if the number of outputs at the machine
--   address is greater than one.
getOnChainState :: (AsSMContractError e, FromData state, ToData state) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i, Map TxOutRef DecoratedTxOut))
getStateData :: OnChainState s i -> s

-- | Wait until the on-chain state of the state machine instance has
--   changed, and return the new state, or return <a>Nothing</a> if the
--   instance has been terminated. If <a>waitForUpdate</a> is called before
--   the instance has even started then it returns the first state of the
--   instance as soon as it has started.
waitForUpdate :: forall state i w schema e. (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i))

-- | Wait for the on-chain state of the state machine instance to change
--   until timeoutSlot, and return the new state, or return
--   <a>ContractEnded</a> if the instance has been terminated. If
--   <a>waitForUpdate</a> is called before the instance has even started
--   then it returns the first state of the instance as soon as it has
--   started.
waitForUpdateUntilSlot :: (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Slot -> Contract w schema e (WaitingResult Slot i state)

-- | Same as <a>waitForUpdateUntilSlot</a>, but works with <a>POSIXTime</a>
--   instead.
waitForUpdateUntilTime :: (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> POSIXTime -> Contract w schema e (WaitingResult POSIXTime i state)

-- | Construct a <a>Promise</a> that waits for an update to the state
--   machine's on-chain state, or a user-defined timeout (whichever happens
--   first).
waitForUpdateTimeout :: forall state i t w schema e. (AsSMContractError e, AsContractError e, FromData state, ToData state, FromData i) => StateMachineClient state i -> Promise w schema e t -> Contract w schema e (Promise w schema e (WaitingResult t i (OnChainState state i)))

-- | Constraints &amp; lookups needed to transition a state machine
--   instance
data StateMachineTransition state input
StateMachineTransition :: TxConstraints input state -> State state -> State state -> ScriptLookups (StateMachine state input) -> StateMachineTransition state input
[smtConstraints] :: StateMachineTransition state input -> TxConstraints input state
[smtOldState] :: StateMachineTransition state input -> State state
[smtNewState] :: StateMachineTransition state input -> State state
[smtLookups] :: StateMachineTransition state input -> ScriptLookups (StateMachine state input)

-- | Given a state machine client and an input to apply to the client's
--   state machine instance, compute the <a>StateMachineTransition</a> that
--   can produce an actual transaction performing the transition
mkStep :: forall w e state schema input. (AsSMContractError e, FromData state, ToData state) => StateMachineClient state input -> input -> Contract w schema e (Either (InvalidTransition state input) (StateMachineTransition state input))

-- | Uninhabited data type
data Void
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON t, Data.Aeson.Types.FromJSON.FromJSON i) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.WaitingResult t i s)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.WaitingResult t i s)
instance GHC.Base.Functor (Plutus.Contract.StateMachine.WaitingResult t i)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.WaitingResult t i s)
instance (GHC.Show.Show t, GHC.Show.Show i, GHC.Show.Show s) => GHC.Show.Show (Plutus.Contract.StateMachine.WaitingResult t i s)
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contract.StateMachine.SMContractError
instance Plutus.Contract.Error.AsContractError Plutus.Contract.StateMachine.SMContractError
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON i) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON s) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Show.Show s, GHC.Show.Show i) => GHC.Show.Show (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Classes.Eq s, GHC.Classes.Eq i) => GHC.Classes.Eq (Plutus.Contract.StateMachine.InvalidTransition s i)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.StateMachine.SMContractError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.StateMachine.SMContractError
instance GHC.Generics.Generic Plutus.Contract.StateMachine.SMContractError
instance GHC.Classes.Eq Plutus.Contract.StateMachine.SMContractError
instance GHC.Show.Show Plutus.Contract.StateMachine.SMContractError
