-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Helper/utility functions for writing Plutus scripts.
--   
--   Helper/utility functions for writing Plutus scripts.
@package plutus-script-utils
@version 1.2.0.0


-- | Functions for working with <a>Ada</a> in Template Haskell.
module Plutus.Script.Utils.Ada

-- | ADA, the special currency on the Cardano blockchain. The unit of Ada
--   is Lovelace, and 1M Lovelace is one Ada. See note [Currencies] in
--   <a>TH</a>.
newtype Ada
Lovelace :: Integer -> Ada
[getLovelace] :: Ada -> Integer

-- | Get the amount of Ada (the unit of the currency Ada) in this
--   <a>Ada</a> value.
getAda :: Ada -> Micro

-- | The <a>CurrencySymbol</a> of the <a>Ada</a> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <a>Ada</a> currency.
adaToken :: TokenName

-- | Get the <a>Ada</a> in the given <a>Value</a>.
fromValue :: Value -> Ada

-- | Create a <a>Value</a> containing only the given <a>Ada</a>.
toValue :: Ada -> Value

-- | Create <a>Ada</a> representing the given quantity of Lovelace (the
--   unit of the currency Ada).
lovelaceOf :: Integer -> Ada

-- | Create <a>Ada</a> representing the given quantity of Ada (1M
--   Lovelace).
adaOf :: Micro -> Ada

-- | A <a>Value</a> with the given amount of Lovelace (the currency unit).
--   
--   <pre>
--   lovelaceValueOf == toValue . lovelaceOf
--   </pre>
lovelaceValueOf :: Integer -> Value

-- | A <a>Value</a> with the given amount of Ada (the currency unit).
--   
--   <pre>
--   adaValueOf == toValue . adaOf
--   </pre>
adaValueOf :: Micro -> Value

-- | Divide one <a>Ada</a> value by another.
divide :: Ada -> Ada -> Ada

-- | Check whether an <a>Ada</a> value is zero.
isZero :: Ada -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Script.Utils.Ada.Ada
instance Prettyprinter.Internal.Pretty Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.FromData Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.ToData Plutus.Script.Utils.Ada.Ada
instance Codec.Serialise.Class.Serialise Plutus.Script.Utils.Ada.Ada
instance GHC.Real.Real Plutus.Script.Utils.Ada.Ada
instance GHC.Real.Integral Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeMonoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeSemigroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveGroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveMonoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.Script.Utils.Ada.Ada
instance GHC.Num.Num Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Ord.Ord Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Eq.Eq Plutus.Script.Utils.Ada.Ada
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.Ada.Ada
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.Ada.Ada
instance GHC.Generics.Generic Plutus.Script.Utils.Ada.Ada
instance GHC.Show.Show Plutus.Script.Utils.Ada.Ada
instance GHC.Classes.Ord Plutus.Script.Utils.Ada.Ada
instance GHC.Classes.Eq Plutus.Script.Utils.Ada.Ada
instance GHC.Enum.Enum Plutus.Script.Utils.Ada.Ada
instance GHC.Base.Semigroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Semigroup.Semigroup Plutus.Script.Utils.Ada.Ada
instance GHC.Base.Monoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Monoid.Monoid Plutus.Script.Utils.Ada.Ada


-- | This module contains functions related to versioning scripts and
--   BuiltinData, or more specifially, <tt>Datum</tt>s and
--   <tt>Redeemer</tt>s. These functions do not depend on a particular
--   version of Plutus.
module Plutus.Script.Utils.Scripts
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language

-- | Hash a <a>Versioned</a> <tt>Script</tt>
scriptHash :: Versioned Script -> ScriptHash

-- | Hash a <a>Versioned</a> <a>Validator</a> script.
validatorHash :: Versioned Validator -> ValidatorHash

-- | Hash a <a>Versioned</a> <a>MintingPolicy</a> script.
mintingPolicyHash :: Versioned MintingPolicy -> MintingPolicyHash

-- | Hash a <a>Versioned</a> <a>StakeValidator</a> script.
stakeValidatorHash :: Versioned StakeValidator -> StakeValidatorHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: Versioned MintingPolicy -> CurrencySymbol
data Datum
data DatumHash
data Redeemer
data RedeemerHash

-- | Hash a 'PV1.Datum builtin data.
datumHash :: Datum -> DatumHash

-- | Hash a <a>Redeemer</a> builtin data.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash a <a>BuiltinData</a>
dataHash :: BuiltinData -> BuiltinByteString
instance Codec.Serialise.Class.Serialise script => Codec.Serialise.Class.Serialise (Plutus.Script.Utils.Scripts.Versioned script)
instance Data.Aeson.Types.FromJSON.FromJSON script => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Script.Utils.Scripts.Versioned script)
instance Data.Aeson.Types.ToJSON.ToJSON script => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Generics.Generic (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Base.Functor Plutus.Script.Utils.Scripts.Versioned
instance GHC.Classes.Ord script => GHC.Classes.Ord (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Classes.Eq script => GHC.Classes.Eq (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Show.Show script => GHC.Show.Show (Plutus.Script.Utils.Scripts.Versioned script)
instance Codec.Serialise.Class.Serialise Cardano.Ledger.Alonzo.Language.Language
instance Prettyprinter.Internal.Pretty script => Prettyprinter.Internal.Pretty (Plutus.Script.Utils.Scripts.Versioned script)
instance Prettyprinter.Internal.Pretty Cardano.Ledger.Alonzo.Language.Language

module Plutus.Script.Utils.V1.Contexts
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Value
[txInfoMint] :: TxInfo -> Value
[txInfoDCert] :: TxInfo -> [DCert]
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]
[txInfoId] :: TxInfo -> TxId
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId
[txOutRefIdx] :: TxOutRef -> Integer
findContinuingOutputs :: ScriptContext -> [Integer]
findDatum :: DatumHash -> TxInfo -> Maybe Datum
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findOwnInput :: ScriptContext -> Maybe TxInInfo
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo
fromSymbol :: CurrencySymbol -> ValidatorHash
getContinuingOutputs :: ScriptContext -> [TxOut]
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
ownHash :: ScriptContext -> ValidatorHash
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)
pubKeyOutput :: TxOut -> Maybe PubKeyHash
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]
spendsOutput :: TxInfo -> TxId -> Integer -> Bool
txSignedBy :: TxInfo -> PubKeyHash -> Bool
valueLockedBy :: TxInfo -> ValidatorHash -> Value
valueProduced :: TxInfo -> Value
valueSpent :: TxInfo -> Value

-- | Get the values paid to a public key address by a pending transaction.
outputsAt :: Address -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> Address -> Value


-- | This module contains functions related to the computation of script
--   hashes for PlutusV1.
module Plutus.Script.Utils.V1.Scripts
data Validator
data ValidatorHash
data MintingPolicy
data MintingPolicyHash
data StakeValidator
data StakeValidatorHash

-- | Transform a Cardano Script hash in a Plutus Script hash
fromCardanoHash :: ScriptHash -> ScriptHash

-- | Hash a <a>Validator</a> script.
validatorHash :: Validator -> ValidatorHash

-- | Hash a <a>MintingPolicy</a> script.
mintingPolicyHash :: MintingPolicy -> MintingPolicyHash

-- | Hash a <a>StakeValidator</a> script.
stakeValidatorHash :: StakeValidator -> StakeValidatorHash

-- | Hash a <tt>Script</tt>
scriptHash :: Script -> ScriptHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: MintingPolicy -> CurrencySymbol

-- | Convert a <tt>Script</tt> to a 'cardano-api' script.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts]
toCardanoApiScript :: Script -> Script PlutusScriptV1

module Plutus.Script.Utils.V1.Generators
alwaysSucceedValidator :: Validator
alwaysSucceedValidatorVersioned :: Versioned Validator
alwaysSucceedValidatorHash :: ValidatorHash
alwaysSucceedPolicy :: MintingPolicy
alwaysSucceedPolicyVersioned :: Versioned MintingPolicy
alwaysSucceedPolicyHash :: MintingPolicyHash
someTokenValue :: TokenName -> Integer -> Value

module Plutus.Script.Utils.V1.Address

-- | The address that should be used by a transaction output locked by the
--   given Plutus V1 validator script.
mkValidatorAddress :: Validator -> Address

-- | Cardano address of a <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Validator -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkMintingPolicyCardanoAddress :: NetworkId -> MintingPolicy -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkStakeValidatorCardanoAddress :: NetworkId -> StakeValidator -> AddressInEra BabbageEra

module Plutus.Script.Utils.V1.Tx

-- | Create a transaction output locked by a validator script and attach
--   the given data script.
scriptTxOut :: Validator -> Value -> Datum -> TxOut

-- | Create a transaction output locked by a validator script hash with the
--   given data script attached.
scriptAddressTxOut :: Address -> Value -> Datum -> TxOut

module Plutus.Script.Utils.V2.Contexts
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId
[txOutRefIdx] :: TxOutRef -> Integer
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo
[txInfoInputs] :: TxInfo -> [TxInInfo]
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]
[txInfoOutputs] :: TxInfo -> [TxOut]
[txInfoFee] :: TxInfo -> Value
[txInfoMint] :: TxInfo -> Value
[txInfoDCert] :: TxInfo -> [DCert]
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer
[txInfoValidRange] :: TxInfo -> POSIXTimeRange
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum
[txInfoId] :: TxInfo -> TxId
fromSymbol :: CurrencySymbol -> ValidatorHash
pubKeyOutput :: TxOut -> Maybe PubKeyHash
findContinuingOutputs :: ScriptContext -> [Integer]
findDatum :: DatumHash -> TxInfo -> Maybe Datum
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findOwnInput :: ScriptContext -> Maybe TxInInfo
getContinuingOutputs :: ScriptContext -> [TxOut]
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
ownHash :: ScriptContext -> ValidatorHash
ownHashes :: ScriptContext -> (ValidatorHash, OutputDatum)
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(OutputDatum, Value)]
spendsOutput :: TxInfo -> TxId -> Integer -> Bool
txSignedBy :: TxInfo -> PubKeyHash -> Bool
valueLockedBy :: TxInfo -> ValidatorHash -> Value
valueProduced :: TxInfo -> Value
valueSpent :: TxInfo -> Value
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo
findTxRefInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Get the values paid to a public key address by a pending transaction.
outputsAt :: Address -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> Address -> Value

module Plutus.Script.Utils.V2.Scripts
data Datum
data DatumHash
data Redeemer
data RedeemerHash

-- | Hash a 'PV1.Datum builtin data.
datumHash :: Datum -> DatumHash

-- | Hash a <a>Redeemer</a> builtin data.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash a <a>BuiltinData</a>
dataHash :: BuiltinData -> BuiltinByteString
data Validator
data ValidatorHash
data MintingPolicy
data MintingPolicyHash
data StakeValidator
data StakeValidatorHash

-- | Hash a <a>Validator</a> script.
validatorHash :: Validator -> ValidatorHash

-- | Hash a <a>MintingPolicy</a> script.
mintingPolicyHash :: MintingPolicy -> MintingPolicyHash

-- | Hash a <a>StakeValidator</a> script.
stakeValidatorHash :: StakeValidator -> StakeValidatorHash

-- | Convert a <a>BuiltinsData</a> value to a 'cardano-api' script data
--   value.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts] toCardanoAPIData ::
--   Builtins.BuiltinData -&gt; Script.ScriptData toCardanoAPIData =
--   Script.fromPlutusData . Builtins.builtinDataToData
--   
--   Hash a <tt>Script</tt>
scriptHash :: Script -> ScriptHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: MintingPolicy -> CurrencySymbol

-- | Convert a <tt>Script</tt> to a 'cardano-api' script.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts]
toCardanoApiScript :: Script -> Script PlutusScriptV2

module Plutus.Script.Utils.V2.Generators
alwaysSucceedValidator :: Validator
alwaysSucceedValidatorHash :: ValidatorHash
alwaysSucceedPolicy :: MintingPolicy
someTokenValue :: TokenName -> Integer -> Value

module Plutus.Script.Utils.V2.Address

-- | The address that should be used by a transaction output locked by the
--   given Plutus V2 validator script.
mkValidatorAddress :: Validator -> Address

-- | Cardano address of a <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Validator -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkMintingPolicyCardanoAddress :: NetworkId -> MintingPolicy -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkStakeValidatorCardanoAddress :: NetworkId -> StakeValidator -> AddressInEra BabbageEra

module Plutus.Script.Utils.Typed
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()
type UntypedMintingPolicy = BuiltinData -> BuiltinData -> ()
type UntypedStakeValidator = BuiltinData -> BuiltinData -> ()

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)
TypedValidator :: Versioned Validator -> ValidatorHash -> Versioned MintingPolicy -> MintingPolicyHash -> TypedValidator (a :: Type)
[tvValidator] :: TypedValidator (a :: Type) -> Versioned Validator
[tvValidatorHash] :: TypedValidator (a :: Type) -> ValidatorHash
[tvForwardingMPS] :: TypedValidator (a :: Type) -> Versioned MintingPolicy

-- | The hash of the minting policy that checks whether the validator is
--   run in this transaction
[tvForwardingMPSHash] :: TypedValidator (a :: Type) -> MintingPolicyHash

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorCardanoAddress :: NetworkId -> TypedValidator a -> AddressInEra BabbageEra
validatorCardanoAddressAny :: NetworkId -> TypedValidator a -> AddressAny

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any
data Any
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
class UnsafeFromData sc => IsScriptContext sc

-- | Converts a custom datum and redeemer from a validator function to an
--   untyped validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedValidator mkValidator
--   </pre>
--   
--   Here's an example using a parameterized validator:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: Int -&gt; MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ _ = True
--   
--   validator :: Int -&gt; Plutus.Validator
--   validator i = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap . mkValidator ||]) <a>applyCode</a> PlutusTx.liftCode i
--    where
--       wrap = mkUntypedValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (data, redeemer and then script context). A log trace is
--   generated after each successfully decoded parameter. Thus, if a
--   parameter can't be decoded, the culprit is the first parameter in the
--   list that doesn't appear as successfully decoded in the log trace.
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator

-- | Converts a custom redeemer from a stake validator function to an
--   untyped stake validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedStakeValidator)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkStakeValidator :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkStakeValidator _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkStakeValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedStakeValidator mkStakeValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedStakeValidator :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedStakeValidator

-- | Converts a custom redeemer from a minting policy function to an
--   untyped minting policy function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedMintingPolicy)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkMintingPolicy :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkMintingPolicy _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkMintingPolicyScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedMintingPolicy mkMintingPolicy
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedMintingPolicy :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedMintingPolicy
type ScriptContextV1 = ScriptContext
type ScriptContextV2 = ScriptContext
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.Typed.Any
instance GHC.Generics.Generic Plutus.Script.Utils.Typed.Any
instance GHC.Show.Show Plutus.Script.Utils.Typed.Any
instance GHC.Classes.Eq Plutus.Script.Utils.Typed.Any
instance GHC.Generics.Generic (Plutus.Script.Utils.Typed.TypedValidator a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.TypedValidator a)
instance GHC.Show.Show (Plutus.Script.Utils.Typed.TypedValidator a)
instance Plutus.Script.Utils.Typed.IsScriptContext Plutus.V1.Ledger.Contexts.ScriptContext
instance Plutus.Script.Utils.Typed.IsScriptContext Plutus.V2.Ledger.Contexts.ScriptContext
instance Plutus.Script.Utils.Typed.ValidatorTypes Data.Void.Void
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Script.Utils.Typed.Any

module Plutus.Script.Utils.V1.Typed.Scripts.StakeValidators

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V1.Typed.Scripts.MonetaryPolicies

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V1.Typed.Scripts.Validators
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()

-- | Converts a custom datum and redeemer from a validator function to an
--   untyped validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedValidator mkValidator
--   </pre>
--   
--   Here's an example using a parameterized validator:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: Int -&gt; MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ _ = True
--   
--   validator :: Int -&gt; Plutus.Validator
--   validator i = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap . mkValidator ||]) <a>applyCode</a> PlutusTx.liftCode i
--    where
--       wrap = mkUntypedValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (data, redeemer and then script context). A log trace is
--   generated after each successfully decoded parameter. Thus, if a
--   parameter can't be decoded, the culprit is the first parameter in the
--   list that doesn't appear as successfully decoded in the log trace.
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | The type of validators for the given connection type.
type ValidatorType (a :: Type) = DatumType a -> RedeemerType a -> ScriptContext -> Bool

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   validator script and its wrapper.
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   parameterized validator script and its wrapper.
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any
data WrongOutTypeError
ExpectedScriptGotPubkey :: WrongOutTypeError
ExpectedPubkeyGotScript :: WrongOutTypeError

-- | An error we can get while trying to type an existing transaction part.
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError

-- | Checks that the given validator hash is consistent with the actual
--   validator.
checkValidatorAddress :: forall a m. MonadError ConnectionError m => TypedValidator a -> Address -> m ()

-- | Checks that the given datum has the right type.
checkDatum :: forall a m. (FromData (DatumType a), MonadError ConnectionError m) => TypedValidator a -> Datum -> m (DatumType a)

-- | Checks that the given redeemer script has the right type.
checkRedeemer :: forall inn m. (FromData (RedeemerType inn), MonadError ConnectionError m) => TypedValidator inn -> Redeemer -> m (RedeemerType inn)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Generics.Generic Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Classes.Ord Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Classes.Eq Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Show.Show Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Generics.Generic Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Classes.Ord Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Classes.Eq Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Show.Show Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance Prettyprinter.Internal.Pretty Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError

module Plutus.Script.Utils.V1.Typed.Scripts

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
data Validator
data MintingPolicy
data StakeValidator

-- | A <a>TxOut</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOut a

-- | A <a>TxOutRef</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOutRef a

-- | Create a <a>TypedScriptTxOut</a> from a correctly-typed data script,
--   an address, and a value.
makeTypedScriptTxOut :: forall out. (ToData (DatumType out), FromData (DatumType out)) => TypedValidator out -> DatumType out -> Value -> TypedScriptTxOut out

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOut :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOut out)

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOutRef :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOutRef out)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V1.Typed.Scripts.TypedScriptTxOutRef a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V1.Typed.Scripts.TypedScriptTxOut a)

module Plutus.Script.Utils.V2.Tx

-- | Create a transaction output locked by a validator script and attach
--   the given data script.
scriptTxOut :: Validator -> Value -> OutputDatum -> HasReferenceScript -> TxOut

module Plutus.Script.Utils.V2.Typed.Scripts.MonetaryPolicies

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V2.Typed.Scripts.StakeValidators

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V2.Typed.Scripts.Validators
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | The type of validators for the given connection type.
type ValidatorType (a :: Type) = DatumType a -> RedeemerType a -> ScriptContext -> Bool

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   validator script and its wrapper.
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   parameterized validator script and its wrapper.
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any

module Plutus.Script.Utils.V2.Typed.Scripts

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
data Validator
data MintingPolicy
data StakeValidator

-- | A <a>TxOut</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOut a
TypedScriptTxOut :: TxOut -> DatumType a -> TypedScriptTxOut a
[tyTxOutTxOut] :: TypedScriptTxOut a -> TxOut
[tyTxOutData] :: TypedScriptTxOut a -> DatumType a

-- | A <a>TxOutRef</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOutRef a
TypedScriptTxOutRef :: TxOutRef -> TypedScriptTxOut a -> TypedScriptTxOutRef a
[tyTxOutRefRef] :: TypedScriptTxOutRef a -> TxOutRef
[tyTxOutRefOut] :: TypedScriptTxOutRef a -> TypedScriptTxOut a

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOut :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOut out)

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOutRef :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOutRef out)

-- | An error we can get while trying to type an existing transaction part.
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V2.Typed.Scripts.TypedScriptTxOutRef a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V2.Typed.Scripts.TypedScriptTxOut a)

module Plutus.Script.Utils.Value
adaSymbol :: CurrencySymbol
adaToken :: TokenName
assetClass :: CurrencySymbol -> TokenName -> AssetClass
assetClassValue :: AssetClass -> Integer -> Value
assetClassValueOf :: Value -> AssetClass -> Integer
currencyMPSHash :: CurrencySymbol -> MintingPolicyHash
currencySymbol :: ByteString -> CurrencySymbol
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
geq :: Value -> Value -> Bool
gt :: Value -> Value -> Bool
isZero :: Value -> Bool
leq :: Value -> Value -> Bool
lt :: Value -> Value -> Bool
mpsSymbol :: MintingPolicyHash -> CurrencySymbol
singleton :: CurrencySymbol -> TokenName -> Integer -> Value
split :: Value -> (Value, Value)
symbols :: Value -> [CurrencySymbol]
toString :: TokenName -> String
tokenName :: ByteString -> TokenName
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)
scale :: Module s v => s -> v -> v

-- | Value without any Ada.
noAdaValue :: Value -> Value

-- | Value without any non-Ada.
adaOnlyValue :: Value -> Value
isAdaOnlyValue :: Value -> Bool

-- | Get the quantities of just the given <a>CurrencySymbol</a> in the
--   <a>Value</a>. This is useful when implementing minting policies as
--   they are responsible for checking all minted/burnt tokens of their own
--   <a>CurrencySymbol</a>.
currencyValueOf :: Value -> CurrencySymbol -> Value
