-- File auto generated by purescript-bridge! --
module Wallet.Rollup.Types where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map (Map)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Ledger.Address (PaymentPubKeyHash)
import Plutus.V1.Ledger.Tx (Tx, TxIn, TxOut)
import Plutus.V1.Ledger.TxId (TxId)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype AnnotatedTx = AnnotatedTx
  { sequenceId :: SequenceId
  , txId :: TxId
  , tx :: Tx
  , dereferencedInputs :: Array DereferencedInput
  , balances :: Map BeneficialOwner Value
  , valid :: Boolean
  }

derive instance Eq AnnotatedTx

instance Show AnnotatedTx where
  show a = genericShow a

instance EncodeJson AnnotatedTx where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { sequenceId: E.value :: _ SequenceId
        , txId: E.value :: _ TxId
        , tx: E.value :: _ Tx
        , dereferencedInputs: E.value :: _ (Array DereferencedInput)
        , balances: (E.dictionary E.value E.value) :: _ (Map BeneficialOwner Value)
        , valid: E.value :: _ Boolean
        }
    )

instance DecodeJson AnnotatedTx where
  decodeJson = defer \_ -> D.decode $
    ( AnnotatedTx <$> D.record "AnnotatedTx"
        { sequenceId: D.value :: _ SequenceId
        , txId: D.value :: _ TxId
        , tx: D.value :: _ Tx
        , dereferencedInputs: D.value :: _ (Array DereferencedInput)
        , balances: (D.dictionary D.value D.value) :: _ (Map BeneficialOwner Value)
        , valid: D.value :: _ Boolean
        }
    )

derive instance Generic AnnotatedTx _

derive instance Newtype AnnotatedTx _

--------------------------------------------------------------------------------

_AnnotatedTx :: Iso' AnnotatedTx { sequenceId :: SequenceId, txId :: TxId, tx :: Tx, dereferencedInputs :: Array DereferencedInput, balances :: Map BeneficialOwner Value, valid :: Boolean }
_AnnotatedTx = _Newtype

--------------------------------------------------------------------------------

data BeneficialOwner
  = OwnedByPaymentPubKey PaymentPubKeyHash
  | OwnedByScript String

derive instance Eq BeneficialOwner

derive instance Ord BeneficialOwner

instance Show BeneficialOwner where
  show a = genericShow a

instance EncodeJson BeneficialOwner where
  encodeJson = defer \_ -> case _ of
    OwnedByPaymentPubKey a -> E.encodeTagged "OwnedByPaymentPubKey" a E.value
    OwnedByScript a -> E.encodeTagged "OwnedByScript" a E.value

instance DecodeJson BeneficialOwner where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "BeneficialOwner"
    $ Map.fromFoldable
        [ "OwnedByPaymentPubKey" /\ D.content (OwnedByPaymentPubKey <$> D.value)
        , "OwnedByScript" /\ D.content (OwnedByScript <$> D.value)
        ]

derive instance Generic BeneficialOwner _

--------------------------------------------------------------------------------

_OwnedByPaymentPubKey :: Prism' BeneficialOwner PaymentPubKeyHash
_OwnedByPaymentPubKey = prism' OwnedByPaymentPubKey case _ of
  (OwnedByPaymentPubKey a) -> Just a
  _ -> Nothing

_OwnedByScript :: Prism' BeneficialOwner String
_OwnedByScript = prism' OwnedByScript case _ of
  (OwnedByScript a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

data DereferencedInput
  = DereferencedInput
      { originalInput :: TxIn
      , refersTo :: TxOut
      }
  | InputNotFound TxKey

derive instance Eq DereferencedInput

instance Show DereferencedInput where
  show a = genericShow a

instance EncodeJson DereferencedInput where
  encodeJson = defer \_ -> case _ of
    DereferencedInput { originalInput, refersTo } -> encodeJson
      { tag: "DereferencedInput"
      , originalInput: flip E.encode originalInput E.value
      , refersTo: flip E.encode refersTo E.value
      }
    InputNotFound a -> E.encodeTagged "InputNotFound" a E.value

instance DecodeJson DereferencedInput where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "DereferencedInput"
    $ Map.fromFoldable
        [ "DereferencedInput" /\
            ( DereferencedInput <$> D.object "DereferencedInput"
                { originalInput: D.value :: _ TxIn
                , refersTo: D.value :: _ TxOut
                }
            )
        , "InputNotFound" /\ D.content (InputNotFound <$> D.value)
        ]

derive instance Generic DereferencedInput _

--------------------------------------------------------------------------------

_DereferencedInput :: Prism' DereferencedInput { originalInput :: TxIn, refersTo :: TxOut }
_DereferencedInput = prism' DereferencedInput case _ of
  (DereferencedInput a) -> Just a
  _ -> Nothing

_InputNotFound :: Prism' DereferencedInput TxKey
_InputNotFound = prism' InputNotFound case _ of
  (InputNotFound a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

newtype SequenceId = SequenceId
  { slotIndex :: Int
  , txIndex :: Int
  }

derive instance Eq SequenceId

derive instance Ord SequenceId

instance Show SequenceId where
  show a = genericShow a

instance EncodeJson SequenceId where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { slotIndex: E.value :: _ Int
        , txIndex: E.value :: _ Int
        }
    )

instance DecodeJson SequenceId where
  decodeJson = defer \_ -> D.decode $
    ( SequenceId <$> D.record "SequenceId"
        { slotIndex: D.value :: _ Int
        , txIndex: D.value :: _ Int
        }
    )

derive instance Generic SequenceId _

derive instance Newtype SequenceId _

--------------------------------------------------------------------------------

_SequenceId :: Iso' SequenceId { slotIndex :: Int, txIndex :: Int }
_SequenceId = _Newtype

--------------------------------------------------------------------------------

newtype TxKey = TxKey
  { _txKeyTxId :: TxId
  , _txKeyTxOutRefIdx :: BigInt
  }

derive instance Eq TxKey

derive instance Ord TxKey

instance Show TxKey where
  show a = genericShow a

instance EncodeJson TxKey where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { _txKeyTxId: E.value :: _ TxId
        , _txKeyTxOutRefIdx: E.value :: _ BigInt
        }
    )

instance DecodeJson TxKey where
  decodeJson = defer \_ -> D.decode $
    ( TxKey <$> D.record "TxKey"
        { _txKeyTxId: D.value :: _ TxId
        , _txKeyTxOutRefIdx: D.value :: _ BigInt
        }
    )

derive instance Generic TxKey _

derive instance Newtype TxKey _

--------------------------------------------------------------------------------

_TxKey :: Iso' TxKey { _txKeyTxId :: TxId, _txKeyTxOutRefIdx :: BigInt }
_TxKey = _Newtype

txKeyTxId :: Lens' TxKey TxId
txKeyTxId = _Newtype <<< prop (Proxy :: _ "_txKeyTxId")

txKeyTxOutRefIdx :: Lens' TxKey BigInt
txKeyTxOutRefIdx = _Newtype <<< prop (Proxy :: _ "_txKeyTxOutRefIdx")
