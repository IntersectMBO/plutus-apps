-- File auto generated by purescript-bridge! --
module Ledger.Tx.Types.TxInput where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Plutus.V1.Ledger.Scripts (DatumHash)
import Plutus.V1.Ledger.Tx (TxOutRef)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype TxInput = TxInput
  { txInputRef :: TxOutRef
  , txInputType :: TxInputType
  }

derive instance Eq TxInput

derive instance Ord TxInput

instance Show TxInput where
  show a = genericShow a

instance EncodeJson TxInput where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { txInputRef: E.value :: _ TxOutRef
        , txInputType: E.value :: _ TxInputType
        }
    )

instance DecodeJson TxInput where
  decodeJson = defer \_ -> D.decode $
    ( TxInput <$> D.record "TxInput"
        { txInputRef: D.value :: _ TxOutRef
        , txInputType: D.value :: _ TxInputType
        }
    )

derive instance Generic TxInput _

derive instance Newtype TxInput _

--------------------------------------------------------------------------------

_TxInput :: Iso' TxInput { txInputRef :: TxOutRef, txInputType :: TxInputType }
_TxInput = _Newtype

--------------------------------------------------------------------------------

data TxInputType
  = TxConsumeScriptAddress String String DatumHash
  | TxConsumePublicKeyAddress
  | TxConsumeSimpleScriptAddress

derive instance Eq TxInputType

derive instance Ord TxInputType

instance Show TxInputType where
  show a = genericShow a

instance EncodeJson TxInputType where
  encodeJson = defer \_ -> case _ of
    TxConsumeScriptAddress a b c -> E.encodeTagged "TxConsumeScriptAddress" (a /\ b /\ c) (E.tuple (E.value >/\< E.value >/\< E.value))
    TxConsumePublicKeyAddress -> encodeJson { tag: "TxConsumePublicKeyAddress", contents: jsonNull }
    TxConsumeSimpleScriptAddress -> encodeJson { tag: "TxConsumeSimpleScriptAddress", contents: jsonNull }

instance DecodeJson TxInputType where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "TxInputType"
    $ Map.fromFoldable
        [ "TxConsumeScriptAddress" /\ D.content (D.tuple $ TxConsumeScriptAddress </$\> D.value </*\> D.value </*\> D.value)
        , "TxConsumePublicKeyAddress" /\ pure TxConsumePublicKeyAddress
        , "TxConsumeSimpleScriptAddress" /\ pure TxConsumeSimpleScriptAddress
        ]

derive instance Generic TxInputType _

--------------------------------------------------------------------------------

_TxConsumeScriptAddress :: Prism' TxInputType { a :: String, b :: String, c :: DatumHash }
_TxConsumeScriptAddress = prism' (\{ a, b, c } -> (TxConsumeScriptAddress a b c)) case _ of
  (TxConsumeScriptAddress a b c) -> Just { a, b, c }
  _ -> Nothing

_TxConsumePublicKeyAddress :: Prism' TxInputType Unit
_TxConsumePublicKeyAddress = prism' (const TxConsumePublicKeyAddress) case _ of
  TxConsumePublicKeyAddress -> Just unit
  _ -> Nothing

_TxConsumeSimpleScriptAddress :: Prism' TxInputType Unit
_TxConsumeSimpleScriptAddress = prism' (const TxConsumeSimpleScriptAddress) case _ of
  TxConsumeSimpleScriptAddress -> Just unit
  _ -> Nothing
