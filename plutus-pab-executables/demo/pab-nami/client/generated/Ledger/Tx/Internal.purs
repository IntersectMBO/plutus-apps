-- File auto generated by purescript-bridge! --
module Ledger.Tx.Internal where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map (Map)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Plutus.V1.Ledger.Credential (Credential)
import Plutus.V1.Ledger.Crypto (PubKey, Signature)
import Plutus.V1.Ledger.DCert (DCert)
import Plutus.V1.Ledger.Interval (Interval)
import Plutus.V1.Ledger.Scripts (DatumHash)
import Plutus.V1.Ledger.Slot (Slot)
import Plutus.V1.Ledger.Tx (TxOut, TxOutRef)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype Certificate = Certificate
  { certificateDcert :: DCert
  , certificateRedeemer :: Maybe String
  }

derive instance Eq Certificate

instance Show Certificate where
  show a = genericShow a

instance EncodeJson Certificate where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { certificateDcert: E.value :: _ DCert
        , certificateRedeemer: (E.maybe E.value) :: _ (Maybe String)
        }
    )

instance DecodeJson Certificate where
  decodeJson = defer \_ -> D.decode $
    ( Certificate <$> D.record "Certificate"
        { certificateDcert: D.value :: _ DCert
        , certificateRedeemer: (D.maybe D.value) :: _ (Maybe String)
        }
    )

derive instance Generic Certificate _

derive instance Newtype Certificate _

--------------------------------------------------------------------------------

_Certificate :: Iso' Certificate { certificateDcert :: DCert, certificateRedeemer :: Maybe String }
_Certificate = _Newtype

--------------------------------------------------------------------------------

newtype Tx = Tx
  { txInputs :: Array TxInput
  , txCollateral :: Array TxInput
  , txOutputs :: Array TxOut
  , txMint :: Value
  , txFee :: Value
  , txValidRange :: Interval Slot
  , txMintingScripts :: Map String String
  , txWithdrawals :: Array Withdrawal
  , txCertificates :: Array Certificate
  , txSignatures :: Map PubKey Signature
  , txScripts :: Map String String
  , txData :: Map DatumHash String
  , txMetadata :: Maybe String
  }

derive instance Eq Tx

instance Show Tx where
  show a = genericShow a

instance EncodeJson Tx where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { txInputs: E.value :: _ (Array TxInput)
        , txCollateral: E.value :: _ (Array TxInput)
        , txOutputs: E.value :: _ (Array TxOut)
        , txMint: E.value :: _ Value
        , txFee: E.value :: _ Value
        , txValidRange: E.value :: _ (Interval Slot)
        , txMintingScripts: (E.dictionary E.value E.value) :: _ (Map String String)
        , txWithdrawals: E.value :: _ (Array Withdrawal)
        , txCertificates: E.value :: _ (Array Certificate)
        , txSignatures: (E.dictionary E.value E.value) :: _ (Map PubKey Signature)
        , txScripts: (E.dictionary E.value E.value) :: _ (Map String String)
        , txData: (E.dictionary E.value E.value) :: _ (Map DatumHash String)
        , txMetadata: (E.maybe E.value) :: _ (Maybe String)
        }
    )

instance DecodeJson Tx where
  decodeJson = defer \_ -> D.decode $
    ( Tx <$> D.record "Tx"
        { txInputs: D.value :: _ (Array TxInput)
        , txCollateral: D.value :: _ (Array TxInput)
        , txOutputs: D.value :: _ (Array TxOut)
        , txMint: D.value :: _ Value
        , txFee: D.value :: _ Value
        , txValidRange: D.value :: _ (Interval Slot)
        , txMintingScripts: (D.dictionary D.value D.value) :: _ (Map String String)
        , txWithdrawals: D.value :: _ (Array Withdrawal)
        , txCertificates: D.value :: _ (Array Certificate)
        , txSignatures: (D.dictionary D.value D.value) :: _ (Map PubKey Signature)
        , txScripts: (D.dictionary D.value D.value) :: _ (Map String String)
        , txData: (D.dictionary D.value D.value) :: _ (Map DatumHash String)
        , txMetadata: (D.maybe D.value) :: _ (Maybe String)
        }
    )

derive instance Generic Tx _

derive instance Newtype Tx _

--------------------------------------------------------------------------------

_Tx :: Iso' Tx { txInputs :: Array TxInput, txCollateral :: Array TxInput, txOutputs :: Array TxOut, txMint :: Value, txFee :: Value, txValidRange :: Interval Slot, txMintingScripts :: Map String String, txWithdrawals :: Array Withdrawal, txCertificates :: Array Certificate, txSignatures :: Map PubKey Signature, txScripts :: Map String String, txData :: Map DatumHash String, txMetadata :: Maybe String }
_Tx = _Newtype

--------------------------------------------------------------------------------

newtype TxInput = TxInput
  { txInputRef :: TxOutRef
  , txInputType :: TxInputType
  }

derive instance Eq TxInput

derive instance Ord TxInput

instance Show TxInput where
  show a = genericShow a

instance EncodeJson TxInput where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { txInputRef: E.value :: _ TxOutRef
        , txInputType: E.value :: _ TxInputType
        }
    )

instance DecodeJson TxInput where
  decodeJson = defer \_ -> D.decode $
    ( TxInput <$> D.record "TxInput"
        { txInputRef: D.value :: _ TxOutRef
        , txInputType: D.value :: _ TxInputType
        }
    )

derive instance Generic TxInput _

derive instance Newtype TxInput _

--------------------------------------------------------------------------------

_TxInput :: Iso' TxInput { txInputRef :: TxOutRef, txInputType :: TxInputType }
_TxInput = _Newtype

--------------------------------------------------------------------------------

data TxInputType
  = TxConsumeScriptAddress String String DatumHash
  | TxConsumePublicKeyAddress
  | TxConsumeSimpleScriptAddress

derive instance Eq TxInputType

derive instance Ord TxInputType

instance Show TxInputType where
  show a = genericShow a

instance EncodeJson TxInputType where
  encodeJson = defer \_ -> case _ of
    TxConsumeScriptAddress a b c -> E.encodeTagged "TxConsumeScriptAddress" (a /\ b /\ c) (E.tuple (E.value >/\< E.value >/\< E.value))
    TxConsumePublicKeyAddress -> encodeJson { tag: "TxConsumePublicKeyAddress", contents: jsonNull }
    TxConsumeSimpleScriptAddress -> encodeJson { tag: "TxConsumeSimpleScriptAddress", contents: jsonNull }

instance DecodeJson TxInputType where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "TxInputType"
    $ Map.fromFoldable
        [ "TxConsumeScriptAddress" /\ D.content (D.tuple $ TxConsumeScriptAddress </$\> D.value </*\> D.value </*\> D.value)
        , "TxConsumePublicKeyAddress" /\ pure TxConsumePublicKeyAddress
        , "TxConsumeSimpleScriptAddress" /\ pure TxConsumeSimpleScriptAddress
        ]

derive instance Generic TxInputType _

--------------------------------------------------------------------------------

_TxConsumeScriptAddress :: Prism' TxInputType { a :: String, b :: String, c :: DatumHash }
_TxConsumeScriptAddress = prism' (\{ a, b, c } -> (TxConsumeScriptAddress a b c)) case _ of
  (TxConsumeScriptAddress a b c) -> Just { a, b, c }
  _ -> Nothing

_TxConsumePublicKeyAddress :: Prism' TxInputType Unit
_TxConsumePublicKeyAddress = prism' (const TxConsumePublicKeyAddress) case _ of
  TxConsumePublicKeyAddress -> Just unit
  _ -> Nothing

_TxConsumeSimpleScriptAddress :: Prism' TxInputType Unit
_TxConsumeSimpleScriptAddress = prism' (const TxConsumeSimpleScriptAddress) case _ of
  TxConsumeSimpleScriptAddress -> Just unit
  _ -> Nothing

--------------------------------------------------------------------------------

newtype TxOutTx = TxOutTx
  { txOutTxTx :: Tx
  , txOutTxOut :: TxOut
  }

derive instance Eq TxOutTx

instance Show TxOutTx where
  show a = genericShow a

instance EncodeJson TxOutTx where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { txOutTxTx: E.value :: _ Tx
        , txOutTxOut: E.value :: _ TxOut
        }
    )

instance DecodeJson TxOutTx where
  decodeJson = defer \_ -> D.decode $
    ( TxOutTx <$> D.record "TxOutTx"
        { txOutTxTx: D.value :: _ Tx
        , txOutTxOut: D.value :: _ TxOut
        }
    )

derive instance Generic TxOutTx _

derive instance Newtype TxOutTx _

--------------------------------------------------------------------------------

_TxOutTx :: Iso' TxOutTx { txOutTxTx :: Tx, txOutTxOut :: TxOut }
_TxOutTx = _Newtype

--------------------------------------------------------------------------------

newtype Withdrawal = Withdrawal
  { withdrawalCredential :: Credential
  , withdrawalAmount :: BigInt
  , withdrawalRedeemer :: Maybe String
  }

derive instance Eq Withdrawal

instance Show Withdrawal where
  show a = genericShow a

instance EncodeJson Withdrawal where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { withdrawalCredential: E.value :: _ Credential
        , withdrawalAmount: E.value :: _ BigInt
        , withdrawalRedeemer: (E.maybe E.value) :: _ (Maybe String)
        }
    )

instance DecodeJson Withdrawal where
  decodeJson = defer \_ -> D.decode $
    ( Withdrawal <$> D.record "Withdrawal"
        { withdrawalCredential: D.value :: _ Credential
        , withdrawalAmount: D.value :: _ BigInt
        , withdrawalRedeemer: (D.maybe D.value) :: _ (Maybe String)
        }
    )

derive instance Generic Withdrawal _

derive instance Newtype Withdrawal _

--------------------------------------------------------------------------------

_Withdrawal :: Iso' Withdrawal { withdrawalCredential :: Credential, withdrawalAmount :: BigInt, withdrawalRedeemer :: Maybe String }
_Withdrawal = _Newtype
