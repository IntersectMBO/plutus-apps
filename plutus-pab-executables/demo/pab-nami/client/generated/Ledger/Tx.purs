-- File auto generated by purescript-bridge! --
module Ledger.Tx where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Either (Either)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.RawJson (RawJson)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Ledger.Tx.Types.Tx (Tx)
import Plutus.V1.Ledger.Address (Address)
import Plutus.V1.Ledger.Scripts (DatumHash, Validator)
import Plutus.V1.Ledger.Tx (TxOut)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

data CardanoTx
  = EmulatorTx { _emulatorTx :: Tx }
  | CardanoApiTx { _cardanoApiTx :: RawJson }
  | Both
      { _emulatorTx :: Tx
      , _cardanoApiTx :: RawJson
      }

derive instance Eq CardanoTx

instance Show CardanoTx where
  show a = genericShow a

instance EncodeJson CardanoTx where
  encodeJson = defer \_ -> case _ of
    EmulatorTx { _emulatorTx } -> encodeJson
      { tag: "EmulatorTx"
      , _emulatorTx: flip E.encode _emulatorTx E.value
      }
    CardanoApiTx { _cardanoApiTx } -> encodeJson
      { tag: "CardanoApiTx"
      , _cardanoApiTx: flip E.encode _cardanoApiTx E.value
      }
    Both { _emulatorTx, _cardanoApiTx } -> encodeJson
      { tag: "Both"
      , _emulatorTx: flip E.encode _emulatorTx E.value
      , _cardanoApiTx: flip E.encode _cardanoApiTx E.value
      }

instance DecodeJson CardanoTx where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "CardanoTx"
    $ Map.fromFoldable
        [ "EmulatorTx" /\ (EmulatorTx <$> D.object "EmulatorTx" { _emulatorTx: D.value :: _ Tx })
        , "CardanoApiTx" /\ (CardanoApiTx <$> D.object "CardanoApiTx" { _cardanoApiTx: D.value :: _ RawJson })
        , "Both" /\
            ( Both <$> D.object "Both"
                { _emulatorTx: D.value :: _ Tx
                , _cardanoApiTx: D.value :: _ RawJson
                }
            )
        ]

derive instance Generic CardanoTx _

--------------------------------------------------------------------------------

_EmulatorTx :: Prism' CardanoTx { _emulatorTx :: Tx }
_EmulatorTx = prism' EmulatorTx case _ of
  (EmulatorTx a) -> Just a
  _ -> Nothing

_CardanoApiTx :: Prism' CardanoTx { _cardanoApiTx :: RawJson }
_CardanoApiTx = prism' CardanoApiTx case _ of
  (CardanoApiTx a) -> Just a
  _ -> Nothing

_Both :: Prism' CardanoTx { _emulatorTx :: Tx, _cardanoApiTx :: RawJson }
_Both = prism' Both case _ of
  (Both a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

data ChainIndexTxOut
  = PublicKeyChainIndexTxOut
      { _ciTxOutAddress :: Address
      , _ciTxOutValue :: Value
      }
  | ScriptChainIndexTxOut
      { _ciTxOutAddress :: Address
      , _ciTxOutValidator :: Either String Validator
      , _ciTxOutDatum :: Either DatumHash String
      , _ciTxOutValue :: Value
      }

derive instance Eq ChainIndexTxOut

instance Show ChainIndexTxOut where
  show a = genericShow a

instance EncodeJson ChainIndexTxOut where
  encodeJson = defer \_ -> case _ of
    PublicKeyChainIndexTxOut { _ciTxOutAddress, _ciTxOutValue } -> encodeJson
      { tag: "PublicKeyChainIndexTxOut"
      , _ciTxOutAddress: flip E.encode _ciTxOutAddress E.value
      , _ciTxOutValue: flip E.encode _ciTxOutValue E.value
      }
    ScriptChainIndexTxOut { _ciTxOutAddress, _ciTxOutValidator, _ciTxOutDatum, _ciTxOutValue } -> encodeJson
      { tag: "ScriptChainIndexTxOut"
      , _ciTxOutAddress: flip E.encode _ciTxOutAddress E.value
      , _ciTxOutValidator: flip E.encode _ciTxOutValidator (E.either E.value E.value)
      , _ciTxOutDatum: flip E.encode _ciTxOutDatum (E.either E.value E.value)
      , _ciTxOutValue: flip E.encode _ciTxOutValue E.value
      }

instance DecodeJson ChainIndexTxOut where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "ChainIndexTxOut"
    $ Map.fromFoldable
        [ "PublicKeyChainIndexTxOut" /\
            ( PublicKeyChainIndexTxOut <$> D.object "PublicKeyChainIndexTxOut"
                { _ciTxOutAddress: D.value :: _ Address
                , _ciTxOutValue: D.value :: _ Value
                }
            )
        , "ScriptChainIndexTxOut" /\
            ( ScriptChainIndexTxOut <$> D.object "ScriptChainIndexTxOut"
                { _ciTxOutAddress: D.value :: _ Address
                , _ciTxOutValidator: (D.either D.value D.value) :: _ (Either String Validator)
                , _ciTxOutDatum: (D.either D.value D.value) :: _ (Either DatumHash String)
                , _ciTxOutValue: D.value :: _ Value
                }
            )
        ]

derive instance Generic ChainIndexTxOut _

--------------------------------------------------------------------------------

_PublicKeyChainIndexTxOut :: Prism' ChainIndexTxOut { _ciTxOutAddress :: Address, _ciTxOutValue :: Value }
_PublicKeyChainIndexTxOut = prism' PublicKeyChainIndexTxOut case _ of
  (PublicKeyChainIndexTxOut a) -> Just a
  _ -> Nothing

_ScriptChainIndexTxOut :: Prism' ChainIndexTxOut { _ciTxOutAddress :: Address, _ciTxOutValidator :: Either String Validator, _ciTxOutDatum :: Either DatumHash String, _ciTxOutValue :: Value }
_ScriptChainIndexTxOut = prism' ScriptChainIndexTxOut case _ of
  (ScriptChainIndexTxOut a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

newtype TxOutTx = TxOutTx
  { txOutTxTx :: Tx
  , txOutTxOut :: TxOut
  }

derive instance Eq TxOutTx

instance Show TxOutTx where
  show a = genericShow a

instance EncodeJson TxOutTx where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { txOutTxTx: E.value :: _ Tx
        , txOutTxOut: E.value :: _ TxOut
        }
    )

instance DecodeJson TxOutTx where
  decodeJson = defer \_ -> D.decode $
    ( TxOutTx <$> D.record "TxOutTx"
        { txOutTxTx: D.value :: _ Tx
        , txOutTxOut: D.value :: _ TxOut
        }
    )

derive instance Generic TxOutTx _

derive instance Newtype TxOutTx _

--------------------------------------------------------------------------------

_TxOutTx :: Iso' TxOutTx { txOutTxTx :: Tx, txOutTxOut :: TxOut }
_TxOutTx = _Newtype
