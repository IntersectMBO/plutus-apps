-- File auto generated by purescript-bridge! --
module Schema where

import Prelude
import Control.Lazy (defer)
import Data.Argonaut.Core (jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Eq (class Eq1)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple (Tuple)
import Data.Tuple.Nested ((/\))
import Plutus.V1.Ledger.Interval (Interval)
import Plutus.V1.Ledger.Time (POSIXTime)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

data FormSchema
  = FormSchemaUnit
  | FormSchemaBool
  | FormSchemaInt
  | FormSchemaInteger
  | FormSchemaString
  | FormSchemaHex
  | FormSchemaArray FormSchema
  | FormSchemaMaybe FormSchema
  | FormSchemaRadio (Array String)
  | FormSchemaTuple FormSchema FormSchema
  | FormSchemaObject (Array (Tuple String FormSchema))
  | FormSchemaValue
  | FormSchemaPOSIXTimeRange
  | FormSchemaUnsupported String

instance showFormSchema :: Show FormSchema where
  show a = genericShow a

derive instance eqFormSchema :: Eq FormSchema

instance encodeJsonFormSchema :: EncodeJson FormSchema where
  encodeJson =
    defer \_ -> case _ of
      FormSchemaUnit -> encodeJson { tag: "FormSchemaUnit", contents: jsonNull }
      FormSchemaBool -> encodeJson { tag: "FormSchemaBool", contents: jsonNull }
      FormSchemaInt -> encodeJson { tag: "FormSchemaInt", contents: jsonNull }
      FormSchemaInteger -> encodeJson { tag: "FormSchemaInteger", contents: jsonNull }
      FormSchemaString -> encodeJson { tag: "FormSchemaString", contents: jsonNull }
      FormSchemaHex -> encodeJson { tag: "FormSchemaHex", contents: jsonNull }
      FormSchemaArray a -> E.encodeTagged "FormSchemaArray" a E.value
      FormSchemaMaybe a -> E.encodeTagged "FormSchemaMaybe" a E.value
      FormSchemaRadio a -> E.encodeTagged "FormSchemaRadio" a E.value
      FormSchemaTuple a b -> E.encodeTagged "FormSchemaTuple" (a /\ b) (E.tuple (E.value >/\< E.value))
      FormSchemaObject a -> E.encodeTagged "FormSchemaObject" a E.value
      FormSchemaValue -> encodeJson { tag: "FormSchemaValue", contents: jsonNull }
      FormSchemaPOSIXTimeRange -> encodeJson { tag: "FormSchemaPOSIXTimeRange", contents: jsonNull }
      FormSchemaUnsupported a -> E.encodeTagged "FormSchemaUnsupported" a E.value

instance decodeJsonFormSchema :: DecodeJson FormSchema where
  decodeJson =
    defer \_ ->
      D.decode
        $ D.sumType "FormSchema"
        $ Map.fromFoldable
            [ "FormSchemaUnit" /\ pure FormSchemaUnit
            , "FormSchemaBool" /\ pure FormSchemaBool
            , "FormSchemaInt" /\ pure FormSchemaInt
            , "FormSchemaInteger" /\ pure FormSchemaInteger
            , "FormSchemaString" /\ pure FormSchemaString
            , "FormSchemaHex" /\ pure FormSchemaHex
            , "FormSchemaArray" /\ D.content (FormSchemaArray <$> D.value)
            , "FormSchemaMaybe" /\ D.content (FormSchemaMaybe <$> D.value)
            , "FormSchemaRadio" /\ D.content (FormSchemaRadio <$> D.value)
            , "FormSchemaTuple" /\ D.content (D.tuple $ FormSchemaTuple </$\> D.value </*\> D.value)
            , "FormSchemaObject" /\ D.content (FormSchemaObject <$> D.value)
            , "FormSchemaValue" /\ pure FormSchemaValue
            , "FormSchemaPOSIXTimeRange" /\ pure FormSchemaPOSIXTimeRange
            , "FormSchemaUnsupported" /\ D.content (FormSchemaUnsupported <$> D.value)
            ]

derive instance genericFormSchema :: Generic FormSchema _

--------------------------------------------------------------------------------
_FormSchemaUnit :: Prism' FormSchema Unit
_FormSchemaUnit =
  prism' (const FormSchemaUnit) case _ of
    FormSchemaUnit -> Just unit
    _ -> Nothing

_FormSchemaBool :: Prism' FormSchema Unit
_FormSchemaBool =
  prism' (const FormSchemaBool) case _ of
    FormSchemaBool -> Just unit
    _ -> Nothing

_FormSchemaInt :: Prism' FormSchema Unit
_FormSchemaInt =
  prism' (const FormSchemaInt) case _ of
    FormSchemaInt -> Just unit
    _ -> Nothing

_FormSchemaInteger :: Prism' FormSchema Unit
_FormSchemaInteger =
  prism' (const FormSchemaInteger) case _ of
    FormSchemaInteger -> Just unit
    _ -> Nothing

_FormSchemaString :: Prism' FormSchema Unit
_FormSchemaString =
  prism' (const FormSchemaString) case _ of
    FormSchemaString -> Just unit
    _ -> Nothing

_FormSchemaHex :: Prism' FormSchema Unit
_FormSchemaHex =
  prism' (const FormSchemaHex) case _ of
    FormSchemaHex -> Just unit
    _ -> Nothing

_FormSchemaArray :: Prism' FormSchema FormSchema
_FormSchemaArray =
  prism' FormSchemaArray case _ of
    (FormSchemaArray a) -> Just a
    _ -> Nothing

_FormSchemaMaybe :: Prism' FormSchema FormSchema
_FormSchemaMaybe =
  prism' FormSchemaMaybe case _ of
    (FormSchemaMaybe a) -> Just a
    _ -> Nothing

_FormSchemaRadio :: Prism' FormSchema (Array String)
_FormSchemaRadio =
  prism' FormSchemaRadio case _ of
    (FormSchemaRadio a) -> Just a
    _ -> Nothing

_FormSchemaTuple :: Prism' FormSchema { a :: FormSchema, b :: FormSchema }
_FormSchemaTuple =
  prism' (\{ a, b } -> (FormSchemaTuple a b)) case _ of
    (FormSchemaTuple a b) -> Just { a, b }
    _ -> Nothing

_FormSchemaObject :: Prism' FormSchema (Array (Tuple String FormSchema))
_FormSchemaObject =
  prism' FormSchemaObject case _ of
    (FormSchemaObject a) -> Just a
    _ -> Nothing

_FormSchemaValue :: Prism' FormSchema Unit
_FormSchemaValue =
  prism' (const FormSchemaValue) case _ of
    FormSchemaValue -> Just unit
    _ -> Nothing

_FormSchemaPOSIXTimeRange :: Prism' FormSchema Unit
_FormSchemaPOSIXTimeRange =
  prism' (const FormSchemaPOSIXTimeRange) case _ of
    FormSchemaPOSIXTimeRange -> Just unit
    _ -> Nothing

_FormSchemaUnsupported :: Prism' FormSchema String
_FormSchemaUnsupported =
  prism' FormSchemaUnsupported case _ of
    (FormSchemaUnsupported a) -> Just a
    _ -> Nothing

--------------------------------------------------------------------------------
data FormArgumentF a
  = FormUnitF
  | FormBoolF Boolean
  | FormIntF (Maybe Int)
  | FormIntegerF (Maybe BigInt)
  | FormStringF (Maybe String)
  | FormHexF (Maybe String)
  | FormRadioF (Array String) (Maybe String)
  | FormArrayF FormSchema (Array a)
  | FormMaybeF FormSchema (Maybe a)
  | FormTupleF a a
  | FormObjectF (Array (Tuple String a))
  | FormValueF Value
  | FormPOSIXTimeRangeF (Interval POSIXTime)
  | FormUnsupportedF String

derive instance functorFormArgumentF :: Functor FormArgumentF

derive instance eqFormArgumentF :: (Eq a) => Eq (FormArgumentF a)

derive instance eq1FormArgumentF :: Eq1 FormArgumentF

instance showFormArgumentF :: (Show a) => Show (FormArgumentF a) where
  show a = genericShow a

instance encodeJsonFormArgumentF :: (EncodeJson a) => EncodeJson (FormArgumentF a) where
  encodeJson =
    defer \_ -> case _ of
      FormUnitF -> encodeJson { tag: "FormUnitF", contents: jsonNull }
      FormBoolF a -> E.encodeTagged "FormBoolF" a E.value
      FormIntF a -> E.encodeTagged "FormIntF" a (E.maybe E.value)
      FormIntegerF a -> E.encodeTagged "FormIntegerF" a (E.maybe E.value)
      FormStringF a -> E.encodeTagged "FormStringF" a (E.maybe E.value)
      FormHexF a -> E.encodeTagged "FormHexF" a (E.maybe E.value)
      FormRadioF a b -> E.encodeTagged "FormRadioF" (a /\ b) (E.tuple (E.value >/\< (E.maybe E.value)))
      FormArrayF a b -> E.encodeTagged "FormArrayF" (a /\ b) (E.tuple (E.value >/\< E.value))
      FormMaybeF a b -> E.encodeTagged "FormMaybeF" (a /\ b) (E.tuple (E.value >/\< (E.maybe E.value)))
      FormTupleF a b -> E.encodeTagged "FormTupleF" (a /\ b) (E.tuple (E.value >/\< E.value))
      FormObjectF a -> E.encodeTagged "FormObjectF" a E.value
      FormValueF a -> E.encodeTagged "FormValueF" a E.value
      FormPOSIXTimeRangeF a -> E.encodeTagged "FormPOSIXTimeRangeF" a E.value
      FormUnsupportedF a -> E.encodeTagged "FormUnsupportedF" a E.value

instance decodeJsonFormArgumentF :: (DecodeJson a) => DecodeJson (FormArgumentF a) where
  decodeJson =
    defer \_ ->
      D.decode
        $ D.sumType "FormArgumentF"
        $ Map.fromFoldable
            [ "FormUnitF" /\ pure FormUnitF
            , "FormBoolF" /\ D.content (FormBoolF <$> D.value)
            , "FormIntF" /\ D.content (FormIntF <$> (D.maybe D.value))
            , "FormIntegerF" /\ D.content (FormIntegerF <$> (D.maybe D.value))
            , "FormStringF" /\ D.content (FormStringF <$> (D.maybe D.value))
            , "FormHexF" /\ D.content (FormHexF <$> (D.maybe D.value))
            , "FormRadioF" /\ D.content (D.tuple $ FormRadioF </$\> D.value </*\> (D.maybe D.value))
            , "FormArrayF" /\ D.content (D.tuple $ FormArrayF </$\> D.value </*\> D.value)
            , "FormMaybeF" /\ D.content (D.tuple $ FormMaybeF </$\> D.value </*\> (D.maybe D.value))
            , "FormTupleF" /\ D.content (D.tuple $ FormTupleF </$\> D.value </*\> D.value)
            , "FormObjectF" /\ D.content (FormObjectF <$> D.value)
            , "FormValueF" /\ D.content (FormValueF <$> D.value)
            , "FormPOSIXTimeRangeF" /\ D.content (FormPOSIXTimeRangeF <$> D.value)
            , "FormUnsupportedF" /\ D.content (FormUnsupportedF <$> D.value)
            ]

derive instance genericFormArgumentF :: Generic (FormArgumentF a) _

--------------------------------------------------------------------------------
_FormUnitF :: forall a. Prism' (FormArgumentF a) Unit
_FormUnitF =
  prism' (const FormUnitF) case _ of
    FormUnitF -> Just unit
    _ -> Nothing

_FormBoolF :: forall a. Prism' (FormArgumentF a) Boolean
_FormBoolF =
  prism' FormBoolF case _ of
    (FormBoolF a) -> Just a
    _ -> Nothing

_FormIntF :: forall a. Prism' (FormArgumentF a) (Maybe Int)
_FormIntF =
  prism' FormIntF case _ of
    (FormIntF a) -> Just a
    _ -> Nothing

_FormIntegerF :: forall a. Prism' (FormArgumentF a) (Maybe BigInt)
_FormIntegerF =
  prism' FormIntegerF case _ of
    (FormIntegerF a) -> Just a
    _ -> Nothing

_FormStringF :: forall a. Prism' (FormArgumentF a) (Maybe String)
_FormStringF =
  prism' FormStringF case _ of
    (FormStringF a) -> Just a
    _ -> Nothing

_FormHexF :: forall a. Prism' (FormArgumentF a) (Maybe String)
_FormHexF =
  prism' FormHexF case _ of
    (FormHexF a) -> Just a
    _ -> Nothing

_FormRadioF :: forall a. Prism' (FormArgumentF a) { a :: Array String, b :: Maybe String }
_FormRadioF =
  prism' (\{ a, b } -> (FormRadioF a b)) case _ of
    (FormRadioF a b) -> Just { a, b }
    _ -> Nothing

_FormArrayF :: forall a. Prism' (FormArgumentF a) { a :: FormSchema, b :: Array a }
_FormArrayF =
  prism' (\{ a, b } -> (FormArrayF a b)) case _ of
    (FormArrayF a b) -> Just { a, b }
    _ -> Nothing

_FormMaybeF :: forall a. Prism' (FormArgumentF a) { a :: FormSchema, b :: Maybe a }
_FormMaybeF =
  prism' (\{ a, b } -> (FormMaybeF a b)) case _ of
    (FormMaybeF a b) -> Just { a, b }
    _ -> Nothing

_FormTupleF :: forall a. Prism' (FormArgumentF a) { a :: a, b :: a }
_FormTupleF =
  prism' (\{ a, b } -> (FormTupleF a b)) case _ of
    (FormTupleF a b) -> Just { a, b }
    _ -> Nothing

_FormObjectF :: forall a. Prism' (FormArgumentF a) (Array (Tuple String a))
_FormObjectF =
  prism' FormObjectF case _ of
    (FormObjectF a) -> Just a
    _ -> Nothing

_FormValueF :: forall a. Prism' (FormArgumentF a) Value
_FormValueF =
  prism' FormValueF case _ of
    (FormValueF a) -> Just a
    _ -> Nothing

_FormPOSIXTimeRangeF :: forall a. Prism' (FormArgumentF a) (Interval POSIXTime)
_FormPOSIXTimeRangeF =
  prism' FormPOSIXTimeRangeF case _ of
    (FormPOSIXTimeRangeF a) -> Just a
    _ -> Nothing

_FormUnsupportedF :: forall a. Prism' (FormArgumentF a) String
_FormUnsupportedF =
  prism' FormUnsupportedF case _ of
    (FormUnsupportedF a) -> Just a
    _ -> Nothing
