-- File auto generated by purescript-bridge! --
module Schema where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Eq (class Eq1)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple (Tuple)
import Data.Tuple.Nested ((/\))
import Plutus.V1.Ledger.Interval (Interval)
import Plutus.V1.Ledger.Time (POSIXTime)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

data FormArgumentF a
  = FormUnitF
  | FormBoolF Boolean
  | FormIntF (Maybe Int)
  | FormIntegerF (Maybe BigInt)
  | FormStringF (Maybe String)
  | FormHexF (Maybe String)
  | FormRadioF (Array String) (Maybe String)
  | FormArrayF FormSchema (Array a)
  | FormMaybeF FormSchema (Maybe a)
  | FormTupleF a a
  | FormObjectF (Array (Tuple String a))
  | FormValueF Value
  | FormPOSIXTimeRangeF (Interval POSIXTime)
  | FormUnsupportedF String

derive instance Functor FormArgumentF

derive instance (Eq a) => Eq (FormArgumentF a)

derive instance Eq1 FormArgumentF

instance (Show a) => Show (FormArgumentF a) where
  show a = genericShow a

instance (EncodeJson a) => EncodeJson (FormArgumentF a) where
  encodeJson = defer \_ -> case _ of
    FormUnitF -> encodeJson { tag: "FormUnitF", contents: jsonNull }
    FormBoolF a -> E.encodeTagged "FormBoolF" a E.value
    FormIntF a -> E.encodeTagged "FormIntF" a (E.maybe E.value)
    FormIntegerF a -> E.encodeTagged "FormIntegerF" a (E.maybe E.value)
    FormStringF a -> E.encodeTagged "FormStringF" a (E.maybe E.value)
    FormHexF a -> E.encodeTagged "FormHexF" a (E.maybe E.value)
    FormRadioF a b -> E.encodeTagged "FormRadioF" (a /\ b) (E.tuple (E.value >/\< (E.maybe E.value)))
    FormArrayF a b -> E.encodeTagged "FormArrayF" (a /\ b) (E.tuple (E.value >/\< E.value))
    FormMaybeF a b -> E.encodeTagged "FormMaybeF" (a /\ b) (E.tuple (E.value >/\< (E.maybe E.value)))
    FormTupleF a b -> E.encodeTagged "FormTupleF" (a /\ b) (E.tuple (E.value >/\< E.value))
    FormObjectF a -> E.encodeTagged "FormObjectF" a E.value
    FormValueF a -> E.encodeTagged "FormValueF" a E.value
    FormPOSIXTimeRangeF a -> E.encodeTagged "FormPOSIXTimeRangeF" a E.value
    FormUnsupportedF a -> E.encodeTagged "FormUnsupportedF" a E.value

instance (DecodeJson a) => DecodeJson (FormArgumentF a) where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "FormArgumentF"
    $ Map.fromFoldable
        [ "FormUnitF" /\ pure FormUnitF
        , "FormBoolF" /\ D.content (FormBoolF <$> D.value)
        , "FormIntF" /\ D.content (FormIntF <$> (D.maybe D.value))
        , "FormIntegerF" /\ D.content (FormIntegerF <$> (D.maybe D.value))
        , "FormStringF" /\ D.content (FormStringF <$> (D.maybe D.value))
        , "FormHexF" /\ D.content (FormHexF <$> (D.maybe D.value))
        , "FormRadioF" /\ D.content (D.tuple $ FormRadioF </$\> D.value </*\> (D.maybe D.value))
        , "FormArrayF" /\ D.content (D.tuple $ FormArrayF </$\> D.value </*\> D.value)
        , "FormMaybeF" /\ D.content (D.tuple $ FormMaybeF </$\> D.value </*\> (D.maybe D.value))
        , "FormTupleF" /\ D.content (D.tuple $ FormTupleF </$\> D.value </*\> D.value)
        , "FormObjectF" /\ D.content (FormObjectF <$> D.value)
        , "FormValueF" /\ D.content (FormValueF <$> D.value)
        , "FormPOSIXTimeRangeF" /\ D.content (FormPOSIXTimeRangeF <$> D.value)
        , "FormUnsupportedF" /\ D.content (FormUnsupportedF <$> D.value)
        ]

derive instance Generic (FormArgumentF a) _

--------------------------------------------------------------------------------

_FormUnitF :: forall a. Prism' (FormArgumentF a) Unit
_FormUnitF = prism' (const FormUnitF) case _ of
  FormUnitF -> Just unit
  _ -> Nothing

_FormBoolF :: forall a. Prism' (FormArgumentF a) Boolean
_FormBoolF = prism' FormBoolF case _ of
  (FormBoolF a) -> Just a
  _ -> Nothing

_FormIntF :: forall a. Prism' (FormArgumentF a) (Maybe Int)
_FormIntF = prism' FormIntF case _ of
  (FormIntF a) -> Just a
  _ -> Nothing

_FormIntegerF :: forall a. Prism' (FormArgumentF a) (Maybe BigInt)
_FormIntegerF = prism' FormIntegerF case _ of
  (FormIntegerF a) -> Just a
  _ -> Nothing

_FormStringF :: forall a. Prism' (FormArgumentF a) (Maybe String)
_FormStringF = prism' FormStringF case _ of
  (FormStringF a) -> Just a
  _ -> Nothing

_FormHexF :: forall a. Prism' (FormArgumentF a) (Maybe String)
_FormHexF = prism' FormHexF case _ of
  (FormHexF a) -> Just a
  _ -> Nothing

_FormRadioF :: forall a. Prism' (FormArgumentF a) { a :: Array String, b :: Maybe String }
_FormRadioF = prism' (\{ a, b } -> (FormRadioF a b)) case _ of
  (FormRadioF a b) -> Just { a, b }
  _ -> Nothing

_FormArrayF :: forall a. Prism' (FormArgumentF a) { a :: FormSchema, b :: Array a }
_FormArrayF = prism' (\{ a, b } -> (FormArrayF a b)) case _ of
  (FormArrayF a b) -> Just { a, b }
  _ -> Nothing

_FormMaybeF :: forall a. Prism' (FormArgumentF a) { a :: FormSchema, b :: Maybe a }
_FormMaybeF = prism' (\{ a, b } -> (FormMaybeF a b)) case _ of
  (FormMaybeF a b) -> Just { a, b }
  _ -> Nothing

_FormTupleF :: forall a. Prism' (FormArgumentF a) { a :: a, b :: a }
_FormTupleF = prism' (\{ a, b } -> (FormTupleF a b)) case _ of
  (FormTupleF a b) -> Just { a, b }
  _ -> Nothing

_FormObjectF :: forall a. Prism' (FormArgumentF a) (Array (Tuple String a))
_FormObjectF = prism' FormObjectF case _ of
  (FormObjectF a) -> Just a
  _ -> Nothing

_FormValueF :: forall a. Prism' (FormArgumentF a) Value
_FormValueF = prism' FormValueF case _ of
  (FormValueF a) -> Just a
  _ -> Nothing

_FormPOSIXTimeRangeF :: forall a. Prism' (FormArgumentF a) (Interval POSIXTime)
_FormPOSIXTimeRangeF = prism' FormPOSIXTimeRangeF case _ of
  (FormPOSIXTimeRangeF a) -> Just a
  _ -> Nothing

_FormUnsupportedF :: forall a. Prism' (FormArgumentF a) String
_FormUnsupportedF = prism' FormUnsupportedF case _ of
  (FormUnsupportedF a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

data FormSchema
  = FormSchemaUnit
  | FormSchemaBool
  | FormSchemaInt
  | FormSchemaInteger
  | FormSchemaString
  | FormSchemaHex
  | FormSchemaArray FormSchema
  | FormSchemaMaybe FormSchema
  | FormSchemaRadio (Array String)
  | FormSchemaTuple FormSchema FormSchema
  | FormSchemaObject (Array (Tuple String FormSchema))
  | FormSchemaValue
  | FormSchemaPOSIXTimeRange
  | FormSchemaUnsupported String

instance Show FormSchema where
  show a = genericShow a

derive instance Eq FormSchema

instance EncodeJson FormSchema where
  encodeJson = defer \_ -> case _ of
    FormSchemaUnit -> encodeJson { tag: "FormSchemaUnit", contents: jsonNull }
    FormSchemaBool -> encodeJson { tag: "FormSchemaBool", contents: jsonNull }
    FormSchemaInt -> encodeJson { tag: "FormSchemaInt", contents: jsonNull }
    FormSchemaInteger -> encodeJson { tag: "FormSchemaInteger", contents: jsonNull }
    FormSchemaString -> encodeJson { tag: "FormSchemaString", contents: jsonNull }
    FormSchemaHex -> encodeJson { tag: "FormSchemaHex", contents: jsonNull }
    FormSchemaArray a -> E.encodeTagged "FormSchemaArray" a E.value
    FormSchemaMaybe a -> E.encodeTagged "FormSchemaMaybe" a E.value
    FormSchemaRadio a -> E.encodeTagged "FormSchemaRadio" a E.value
    FormSchemaTuple a b -> E.encodeTagged "FormSchemaTuple" (a /\ b) (E.tuple (E.value >/\< E.value))
    FormSchemaObject a -> E.encodeTagged "FormSchemaObject" a E.value
    FormSchemaValue -> encodeJson { tag: "FormSchemaValue", contents: jsonNull }
    FormSchemaPOSIXTimeRange -> encodeJson { tag: "FormSchemaPOSIXTimeRange", contents: jsonNull }
    FormSchemaUnsupported a -> E.encodeTagged "FormSchemaUnsupported" a E.value

instance DecodeJson FormSchema where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "FormSchema"
    $ Map.fromFoldable
        [ "FormSchemaUnit" /\ pure FormSchemaUnit
        , "FormSchemaBool" /\ pure FormSchemaBool
        , "FormSchemaInt" /\ pure FormSchemaInt
        , "FormSchemaInteger" /\ pure FormSchemaInteger
        , "FormSchemaString" /\ pure FormSchemaString
        , "FormSchemaHex" /\ pure FormSchemaHex
        , "FormSchemaArray" /\ D.content (FormSchemaArray <$> D.value)
        , "FormSchemaMaybe" /\ D.content (FormSchemaMaybe <$> D.value)
        , "FormSchemaRadio" /\ D.content (FormSchemaRadio <$> D.value)
        , "FormSchemaTuple" /\ D.content (D.tuple $ FormSchemaTuple </$\> D.value </*\> D.value)
        , "FormSchemaObject" /\ D.content (FormSchemaObject <$> D.value)
        , "FormSchemaValue" /\ pure FormSchemaValue
        , "FormSchemaPOSIXTimeRange" /\ pure FormSchemaPOSIXTimeRange
        , "FormSchemaUnsupported" /\ D.content (FormSchemaUnsupported <$> D.value)
        ]

derive instance Generic FormSchema _

--------------------------------------------------------------------------------

_FormSchemaUnit :: Prism' FormSchema Unit
_FormSchemaUnit = prism' (const FormSchemaUnit) case _ of
  FormSchemaUnit -> Just unit
  _ -> Nothing

_FormSchemaBool :: Prism' FormSchema Unit
_FormSchemaBool = prism' (const FormSchemaBool) case _ of
  FormSchemaBool -> Just unit
  _ -> Nothing

_FormSchemaInt :: Prism' FormSchema Unit
_FormSchemaInt = prism' (const FormSchemaInt) case _ of
  FormSchemaInt -> Just unit
  _ -> Nothing

_FormSchemaInteger :: Prism' FormSchema Unit
_FormSchemaInteger = prism' (const FormSchemaInteger) case _ of
  FormSchemaInteger -> Just unit
  _ -> Nothing

_FormSchemaString :: Prism' FormSchema Unit
_FormSchemaString = prism' (const FormSchemaString) case _ of
  FormSchemaString -> Just unit
  _ -> Nothing

_FormSchemaHex :: Prism' FormSchema Unit
_FormSchemaHex = prism' (const FormSchemaHex) case _ of
  FormSchemaHex -> Just unit
  _ -> Nothing

_FormSchemaArray :: Prism' FormSchema FormSchema
_FormSchemaArray = prism' FormSchemaArray case _ of
  (FormSchemaArray a) -> Just a
  _ -> Nothing

_FormSchemaMaybe :: Prism' FormSchema FormSchema
_FormSchemaMaybe = prism' FormSchemaMaybe case _ of
  (FormSchemaMaybe a) -> Just a
  _ -> Nothing

_FormSchemaRadio :: Prism' FormSchema (Array String)
_FormSchemaRadio = prism' FormSchemaRadio case _ of
  (FormSchemaRadio a) -> Just a
  _ -> Nothing

_FormSchemaTuple :: Prism' FormSchema { a :: FormSchema, b :: FormSchema }
_FormSchemaTuple = prism' (\{ a, b } -> (FormSchemaTuple a b)) case _ of
  (FormSchemaTuple a b) -> Just { a, b }
  _ -> Nothing

_FormSchemaObject :: Prism' FormSchema (Array (Tuple String FormSchema))
_FormSchemaObject = prism' FormSchemaObject case _ of
  (FormSchemaObject a) -> Just a
  _ -> Nothing

_FormSchemaValue :: Prism' FormSchema Unit
_FormSchemaValue = prism' (const FormSchemaValue) case _ of
  FormSchemaValue -> Just unit
  _ -> Nothing

_FormSchemaPOSIXTimeRange :: Prism' FormSchema Unit
_FormSchemaPOSIXTimeRange = prism' (const FormSchemaPOSIXTimeRange) case _ of
  FormSchemaPOSIXTimeRange -> Just unit
  _ -> Nothing

_FormSchemaUnsupported :: Prism' FormSchema String
_FormSchemaUnsupported = prism' FormSchemaUnsupported case _ of
  (FormSchemaUnsupported a) -> Just a
  _ -> Nothing
