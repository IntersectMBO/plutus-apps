-- File auto generated by purescript-bridge! --
module Plutus.V1.Ledger.Tx where

import Prelude
import Control.Lazy (defer)
import Data.Argonaut.Core (jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Bounded.Generic (genericBottom, genericTop)
import Data.Enum (class Enum)
import Data.Enum.Generic (genericPred, genericSucc)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map (Map)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Set (Set)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Plutus.V1.Ledger.Address (Address)
import Plutus.V1.Ledger.Crypto (PubKey, Signature)
import Plutus.V1.Ledger.Interval (Interval)
import Plutus.V1.Ledger.Scripts (DatumHash, MintingPolicy, Validator)
import Plutus.V1.Ledger.Slot (Slot)
import Plutus.V1.Ledger.TxId (TxId)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype Tx
  = Tx
  { txInputs :: Set TxIn
  , txCollateral :: Set TxIn
  , txOutputs :: Array TxOut
  , txMint :: Value
  , txFee :: Value
  , txValidRange :: Interval Slot
  , txMintScripts :: Set MintingPolicy
  , txSignatures :: Map PubKey Signature
  , txRedeemers :: Map RedeemerPtr String
  , txData :: Map DatumHash String
  }

derive instance eqTx :: Eq Tx

instance showTx :: Show Tx where
  show a = genericShow a

instance encodeJsonTx :: EncodeJson Tx where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { txInputs: E.value :: _ (Set TxIn)
              , txCollateral: E.value :: _ (Set TxIn)
              , txOutputs: E.value :: _ (Array TxOut)
              , txMint: E.value :: _ Value
              , txFee: E.value :: _ Value
              , txValidRange: E.value :: _ (Interval Slot)
              , txMintScripts: E.value :: _ (Set MintingPolicy)
              , txSignatures: (E.dictionary E.value E.value) :: _ (Map PubKey Signature)
              , txRedeemers: (E.dictionary E.value E.value) :: _ (Map RedeemerPtr String)
              , txData: (E.dictionary E.value E.value) :: _ (Map DatumHash String)
              }
          )

instance decodeJsonTx :: DecodeJson Tx where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( Tx
              <$> D.record "Tx"
                  { txInputs: D.value :: _ (Set TxIn)
                  , txCollateral: D.value :: _ (Set TxIn)
                  , txOutputs: D.value :: _ (Array TxOut)
                  , txMint: D.value :: _ Value
                  , txFee: D.value :: _ Value
                  , txValidRange: D.value :: _ (Interval Slot)
                  , txMintScripts: D.value :: _ (Set MintingPolicy)
                  , txSignatures: (D.dictionary D.value D.value) :: _ (Map PubKey Signature)
                  , txRedeemers: (D.dictionary D.value D.value) :: _ (Map RedeemerPtr String)
                  , txData: (D.dictionary D.value D.value) :: _ (Map DatumHash String)
                  }
          )

derive instance genericTx :: Generic Tx _

derive instance newtypeTx :: Newtype Tx _

--------------------------------------------------------------------------------
_Tx :: Iso' Tx { txInputs :: Set TxIn, txCollateral :: Set TxIn, txOutputs :: Array TxOut, txMint :: Value, txFee :: Value, txValidRange :: Interval Slot, txMintScripts :: Set MintingPolicy, txSignatures :: Map PubKey Signature, txRedeemers :: Map RedeemerPtr String, txData :: Map DatumHash String }
_Tx = _Newtype

--------------------------------------------------------------------------------
newtype TxIn
  = TxIn
  { txInRef :: TxOutRef
  , txInType :: Maybe TxInType
  }

derive instance eqTxIn :: Eq TxIn

derive instance ordTxIn :: Ord TxIn

instance showTxIn :: Show TxIn where
  show a = genericShow a

instance encodeJsonTxIn :: EncodeJson TxIn where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { txInRef: E.value :: _ TxOutRef
              , txInType: (E.maybe E.value) :: _ (Maybe TxInType)
              }
          )

instance decodeJsonTxIn :: DecodeJson TxIn where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( TxIn
              <$> D.record "TxIn"
                  { txInRef: D.value :: _ TxOutRef
                  , txInType: (D.maybe D.value) :: _ (Maybe TxInType)
                  }
          )

derive instance genericTxIn :: Generic TxIn _

derive instance newtypeTxIn :: Newtype TxIn _

--------------------------------------------------------------------------------
_TxIn :: Iso' TxIn { txInRef :: TxOutRef, txInType :: Maybe TxInType }
_TxIn = _Newtype

--------------------------------------------------------------------------------
newtype TxOut
  = TxOut
  { txOutAddress :: Address
  , txOutValue :: Value
  , txOutDatumHash :: Maybe DatumHash
  }

derive instance eqTxOut :: Eq TxOut

instance showTxOut :: Show TxOut where
  show a = genericShow a

instance encodeJsonTxOut :: EncodeJson TxOut where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { txOutAddress: E.value :: _ Address
              , txOutValue: E.value :: _ Value
              , txOutDatumHash: (E.maybe E.value) :: _ (Maybe DatumHash)
              }
          )

instance decodeJsonTxOut :: DecodeJson TxOut where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( TxOut
              <$> D.record "TxOut"
                  { txOutAddress: D.value :: _ Address
                  , txOutValue: D.value :: _ Value
                  , txOutDatumHash: (D.maybe D.value) :: _ (Maybe DatumHash)
                  }
          )

derive instance genericTxOut :: Generic TxOut _

derive instance newtypeTxOut :: Newtype TxOut _

--------------------------------------------------------------------------------
_TxOut :: Iso' TxOut { txOutAddress :: Address, txOutValue :: Value, txOutDatumHash :: Maybe DatumHash }
_TxOut = _Newtype

--------------------------------------------------------------------------------
newtype TxOutTx
  = TxOutTx
  { txOutTxTx :: Tx
  , txOutTxOut :: TxOut
  }

derive instance eqTxOutTx :: Eq TxOutTx

instance showTxOutTx :: Show TxOutTx where
  show a = genericShow a

instance encodeJsonTxOutTx :: EncodeJson TxOutTx where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { txOutTxTx: E.value :: _ Tx
              , txOutTxOut: E.value :: _ TxOut
              }
          )

instance decodeJsonTxOutTx :: DecodeJson TxOutTx where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( TxOutTx
              <$> D.record "TxOutTx"
                  { txOutTxTx: D.value :: _ Tx
                  , txOutTxOut: D.value :: _ TxOut
                  }
          )

derive instance genericTxOutTx :: Generic TxOutTx _

derive instance newtypeTxOutTx :: Newtype TxOutTx _

--------------------------------------------------------------------------------
_TxOutTx :: Iso' TxOutTx { txOutTxTx :: Tx, txOutTxOut :: TxOut }
_TxOutTx = _Newtype

--------------------------------------------------------------------------------
newtype TxOutRef
  = TxOutRef
  { txOutRefId :: TxId
  , txOutRefIdx :: BigInt
  }

derive instance eqTxOutRef :: Eq TxOutRef

derive instance ordTxOutRef :: Ord TxOutRef

instance showTxOutRef :: Show TxOutRef where
  show a = genericShow a

instance encodeJsonTxOutRef :: EncodeJson TxOutRef where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { txOutRefId: E.value :: _ TxId
              , txOutRefIdx: E.value :: _ BigInt
              }
          )

instance decodeJsonTxOutRef :: DecodeJson TxOutRef where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( TxOutRef
              <$> D.record "TxOutRef"
                  { txOutRefId: D.value :: _ TxId
                  , txOutRefIdx: D.value :: _ BigInt
                  }
          )

derive instance genericTxOutRef :: Generic TxOutRef _

derive instance newtypeTxOutRef :: Newtype TxOutRef _

--------------------------------------------------------------------------------
_TxOutRef :: Iso' TxOutRef { txOutRefId :: TxId, txOutRefIdx :: BigInt }
_TxOutRef = _Newtype

--------------------------------------------------------------------------------
data RedeemerPtr
  = RedeemerPtr ScriptTag BigInt

instance showRedeemerPtr :: Show RedeemerPtr where
  show a = genericShow a

derive instance eqRedeemerPtr :: Eq RedeemerPtr

derive instance ordRedeemerPtr :: Ord RedeemerPtr

instance encodeJsonRedeemerPtr :: EncodeJson RedeemerPtr where
  encodeJson = defer \_ -> E.encode $ (case _ of RedeemerPtr a b -> (a /\ b)) >$< (E.tuple (E.value >/\< E.value))

instance decodeJsonRedeemerPtr :: DecodeJson RedeemerPtr where
  decodeJson = defer \_ -> D.decode $ (D.tuple $ RedeemerPtr </$\> D.value </*\> D.value)

derive instance genericRedeemerPtr :: Generic RedeemerPtr _

--------------------------------------------------------------------------------
_RedeemerPtr :: Iso' RedeemerPtr { a :: ScriptTag, b :: BigInt }
_RedeemerPtr = iso (\(RedeemerPtr a b) -> { a, b }) (\{ a, b } -> (RedeemerPtr a b))

--------------------------------------------------------------------------------
data ScriptTag
  = Spend
  | Mint
  | Cert
  | Reward

instance showScriptTag :: Show ScriptTag where
  show a = genericShow a

derive instance eqScriptTag :: Eq ScriptTag

derive instance ordScriptTag :: Ord ScriptTag

instance encodeJsonScriptTag :: EncodeJson ScriptTag where
  encodeJson = defer \_ -> E.encode E.enum

instance decodeJsonScriptTag :: DecodeJson ScriptTag where
  decodeJson = defer \_ -> D.decode D.enum

derive instance genericScriptTag :: Generic ScriptTag _

instance enumScriptTag :: Enum ScriptTag where
  succ = genericSucc
  pred = genericPred

instance boundedScriptTag :: Bounded ScriptTag where
  bottom = genericBottom
  top = genericTop

--------------------------------------------------------------------------------
_Spend :: Prism' ScriptTag Unit
_Spend =
  prism' (const Spend) case _ of
    Spend -> Just unit
    _ -> Nothing

_Mint :: Prism' ScriptTag Unit
_Mint =
  prism' (const Mint) case _ of
    Mint -> Just unit
    _ -> Nothing

_Cert :: Prism' ScriptTag Unit
_Cert =
  prism' (const Cert) case _ of
    Cert -> Just unit
    _ -> Nothing

_Reward :: Prism' ScriptTag Unit
_Reward =
  prism' (const Reward) case _ of
    Reward -> Just unit
    _ -> Nothing

--------------------------------------------------------------------------------
data TxInType
  = ConsumeScriptAddress Validator String String
  | ConsumePublicKeyAddress
  | ConsumeSimpleScriptAddress

instance showTxInType :: Show TxInType where
  show a = genericShow a

derive instance eqTxInType :: Eq TxInType

derive instance ordTxInType :: Ord TxInType

instance encodeJsonTxInType :: EncodeJson TxInType where
  encodeJson =
    defer \_ -> case _ of
      ConsumeScriptAddress a b c -> E.encodeTagged "ConsumeScriptAddress" (a /\ b /\ c) (E.tuple (E.value >/\< E.value >/\< E.value))
      ConsumePublicKeyAddress -> encodeJson { tag: "ConsumePublicKeyAddress", contents: jsonNull }
      ConsumeSimpleScriptAddress -> encodeJson { tag: "ConsumeSimpleScriptAddress", contents: jsonNull }

instance decodeJsonTxInType :: DecodeJson TxInType where
  decodeJson =
    defer \_ ->
      D.decode
        $ D.sumType "TxInType"
        $ Map.fromFoldable
            [ "ConsumeScriptAddress" /\ D.content (D.tuple $ ConsumeScriptAddress </$\> D.value </*\> D.value </*\> D.value)
            , "ConsumePublicKeyAddress" /\ pure ConsumePublicKeyAddress
            , "ConsumeSimpleScriptAddress" /\ pure ConsumeSimpleScriptAddress
            ]

derive instance genericTxInType :: Generic TxInType _

--------------------------------------------------------------------------------
_ConsumeScriptAddress :: Prism' TxInType { a :: Validator, b :: String, c :: String }
_ConsumeScriptAddress =
  prism' (\{ a, b, c } -> (ConsumeScriptAddress a b c)) case _ of
    (ConsumeScriptAddress a b c) -> Just { a, b, c }
    _ -> Nothing

_ConsumePublicKeyAddress :: Prism' TxInType Unit
_ConsumePublicKeyAddress =
  prism' (const ConsumePublicKeyAddress) case _ of
    ConsumePublicKeyAddress -> Just unit
    _ -> Nothing

_ConsumeSimpleScriptAddress :: Prism' TxInType Unit
_ConsumeSimpleScriptAddress =
  prism' (const ConsumeSimpleScriptAddress) case _ of
    ConsumeSimpleScriptAddress -> Just unit
    _ -> Nothing
