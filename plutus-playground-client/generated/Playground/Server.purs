-- File auto generated by servant-purescript! --
module Playground.Server where

import Prelude
import Affjax (defaultRequest, request)
import Affjax.RequestHeader (RequestHeader(..))
import Auth (AuthStatus)
import Control.Monad.Error.Class (class MonadError, throwError)
import Control.Monad.Reader.Class (asks, class MonadAsk)
import Data.Argonaut.Decode (decodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Array (fromFoldable, null)
import Data.Either (Either(..))
import Data.HTTP.Method (Method(..))
import Data.Maybe (Maybe(..))
import Data.Newtype (unwrap)
import Data.String (joinWith)
import Effect.Aff.Class (class MonadAff, liftAff)
import Gist (Gist, GistId, NewGist)
import Language.Haskell.Interpreter (InterpreterError, InterpreterResult, SourceCode)
import Playground.Types (CompilationResult, Evaluation, EvaluationResult, PlaygroundError)
import Servant.PureScript (AjaxError, ErrorDescription(..), class ToURLPiece, toURLPiece)
import Affjax.RequestBody (json) as Request
import Affjax.ResponseFormat (json) as Response
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E

foreign import encodeURIComponent :: String -> String

type SPSettings_
  = { baseURL :: String
    }

class HasSPSettings a where
  spSettings :: a -> SPSettings_

postContract ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  SourceCode ->
  m (Either InterpreterError (InterpreterResult CompilationResult))
postContract reqBody = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left POST
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "contract"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        , content =
          Just
            $ Request.json
            $ flip E.encode reqBody
            $ E.value
        }
  let
    decoder = (D.either D.value D.value)
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

postEvaluate ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  Evaluation ->
  m (Either PlaygroundError EvaluationResult)
postEvaluate reqBody = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left POST
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "evaluate"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        , content =
          Just
            $ Request.json
            $ flip E.encode reqBody
            $ E.value
        }
  let
    decoder = (D.either D.value D.value)
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getHealth ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m Unit
getHealth = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left GET
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "health"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        }
  let
    decoder = D.unit
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getOauthStatus ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m AuthStatus
getOauthStatus = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left GET
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "oauth"
        <> "/"
        <> "status"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        }
  let
    decoder = D.value
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getOauthGithub ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m Unit
getOauthGithub = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left GET
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "oauth"
        <> "/"
        <> "github"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        }
  let
    decoder = D.unit
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getGists ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m (Array Gist)
getGists = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left GET
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "gists"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        }
  let
    decoder = D.value
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

postGists ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  NewGist ->
  m Gist
postGists reqBody = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left POST
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "gists"
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        , content =
          Just
            $ Request.json
            $ flip E.encode reqBody
            $ E.value
        }
  let
    decoder = D.value
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getGistsByGistId ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  GistId ->
  m Gist
getGistsByGistId gistId = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left GET
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "gists"
        <> "/"
        <> encodeURIComponent (toURLPiece gistId)
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        }
  let
    decoder = D.value
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

postGistsByGistId ::
  forall env m.
  HasSPSettings env =>
  MonadAsk env m =>
  MonadError AjaxError m =>
  MonadAff m =>
  NewGist ->
  GistId ->
  m Gist
postGistsByGistId reqBody gistId = do
  spSettings <- asks spSettings
  let
    baseURL = spSettings.baseURL
  let
    httpMethod = Left POST
  let
    encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
    encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
    queryArgs :: Array String
    queryArgs = []
  let
    queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
    reqURL =
      baseURL
        <> "gists"
        <> "/"
        <> encodeURIComponent (toURLPiece gistId)
        <> queryString
  let
    reqHeaders = []
  let
    affReq =
      defaultRequest
        { method = httpMethod
        , url = reqURL
        , headers = defaultRequest.headers <> reqHeaders
        , responseFormat = Response.json
        , content =
          Just
            $ Request.json
            $ flip E.encode reqBody
            $ E.value
        }
  let
    decoder = D.value
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299)
    $ throwError
    $ { request: affReq, description: UnexpectedHTTPStatus response }
  case D.decode decoder response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body
