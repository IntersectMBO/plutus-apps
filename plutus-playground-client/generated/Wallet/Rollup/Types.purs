-- File auto generated by purescript-bridge! --
module Wallet.Rollup.Types where

import Prelude
import Control.Lazy (defer)
import Data.Argonaut.Core (jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.BigInt.Argonaut (BigInt)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Map (Map)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Ledger.Address (PaymentPubKeyHash)
import Plutus.V1.Ledger.Tx (Tx, TxIn, TxOut)
import Plutus.V1.Ledger.TxId (TxId)
import Plutus.V1.Ledger.Value (Value)
import Type.Proxy (Proxy(Proxy))
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype SequenceId
  = SequenceId
  { slotIndex :: Int
  , txIndex :: Int
  }

derive instance eqSequenceId :: Eq SequenceId

derive instance ordSequenceId :: Ord SequenceId

instance showSequenceId :: Show SequenceId where
  show a = genericShow a

instance encodeJsonSequenceId :: EncodeJson SequenceId where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { slotIndex: E.value :: _ Int
              , txIndex: E.value :: _ Int
              }
          )

instance decodeJsonSequenceId :: DecodeJson SequenceId where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( SequenceId
              <$> D.record "SequenceId"
                  { slotIndex: D.value :: _ Int
                  , txIndex: D.value :: _ Int
                  }
          )

derive instance genericSequenceId :: Generic SequenceId _

derive instance newtypeSequenceId :: Newtype SequenceId _

--------------------------------------------------------------------------------
_SequenceId :: Iso' SequenceId { slotIndex :: Int, txIndex :: Int }
_SequenceId = _Newtype

--------------------------------------------------------------------------------
newtype AnnotatedTx
  = AnnotatedTx
  { sequenceId :: SequenceId
  , txId :: TxId
  , tx :: Tx
  , dereferencedInputs :: Array DereferencedInput
  , balances :: Map BeneficialOwner Value
  , valid :: Boolean
  }

derive instance eqAnnotatedTx :: Eq AnnotatedTx

instance showAnnotatedTx :: Show AnnotatedTx where
  show a = genericShow a

instance encodeJsonAnnotatedTx :: EncodeJson AnnotatedTx where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { sequenceId: E.value :: _ SequenceId
              , txId: E.value :: _ TxId
              , tx: E.value :: _ Tx
              , dereferencedInputs: E.value :: _ (Array DereferencedInput)
              , balances: (E.dictionary E.value E.value) :: _ (Map BeneficialOwner Value)
              , valid: E.value :: _ Boolean
              }
          )

instance decodeJsonAnnotatedTx :: DecodeJson AnnotatedTx where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( AnnotatedTx
              <$> D.record "AnnotatedTx"
                  { sequenceId: D.value :: _ SequenceId
                  , txId: D.value :: _ TxId
                  , tx: D.value :: _ Tx
                  , dereferencedInputs: D.value :: _ (Array DereferencedInput)
                  , balances: (D.dictionary D.value D.value) :: _ (Map BeneficialOwner Value)
                  , valid: D.value :: _ Boolean
                  }
          )

derive instance genericAnnotatedTx :: Generic AnnotatedTx _

derive instance newtypeAnnotatedTx :: Newtype AnnotatedTx _

--------------------------------------------------------------------------------
_AnnotatedTx :: Iso' AnnotatedTx { sequenceId :: SequenceId, txId :: TxId, tx :: Tx, dereferencedInputs :: Array DereferencedInput, balances :: Map BeneficialOwner Value, valid :: Boolean }
_AnnotatedTx = _Newtype

--------------------------------------------------------------------------------
data DereferencedInput
  = DereferencedInput
    { originalInput :: TxIn
    , refersTo :: TxOut
    }
  | InputNotFound TxKey

derive instance eqDereferencedInput :: Eq DereferencedInput

instance showDereferencedInput :: Show DereferencedInput where
  show a = genericShow a

instance encodeJsonDereferencedInput :: EncodeJson DereferencedInput where
  encodeJson =
    defer \_ -> case _ of
      DereferencedInput { originalInput, refersTo } ->
        encodeJson
          { tag: "DereferencedInput"
          , originalInput: flip E.encode originalInput E.value
          , refersTo: flip E.encode refersTo E.value
          }
      InputNotFound a -> E.encodeTagged "InputNotFound" a E.value

instance decodeJsonDereferencedInput :: DecodeJson DereferencedInput where
  decodeJson =
    defer \_ ->
      D.decode
        $ D.sumType "DereferencedInput"
        $ Map.fromFoldable
            [ "DereferencedInput"
                /\ ( DereferencedInput
                      <$> D.object "DereferencedInput"
                          { originalInput: D.value :: _ TxIn
                          , refersTo: D.value :: _ TxOut
                          }
                  )
            , "InputNotFound" /\ D.content (InputNotFound <$> D.value)
            ]

derive instance genericDereferencedInput :: Generic DereferencedInput _

--------------------------------------------------------------------------------
_DereferencedInput :: Prism' DereferencedInput { originalInput :: TxIn, refersTo :: TxOut }
_DereferencedInput =
  prism' DereferencedInput case _ of
    (DereferencedInput a) -> Just a
    _ -> Nothing

_InputNotFound :: Prism' DereferencedInput TxKey
_InputNotFound =
  prism' InputNotFound case _ of
    (InputNotFound a) -> Just a
    _ -> Nothing

--------------------------------------------------------------------------------
data BeneficialOwner
  = OwnedByPaymentPubKey PaymentPubKeyHash
  | OwnedByScript String

derive instance eqBeneficialOwner :: Eq BeneficialOwner

derive instance ordBeneficialOwner :: Ord BeneficialOwner

instance showBeneficialOwner :: Show BeneficialOwner where
  show a = genericShow a

instance encodeJsonBeneficialOwner :: EncodeJson BeneficialOwner where
  encodeJson =
    defer \_ -> case _ of
      OwnedByPaymentPubKey a -> E.encodeTagged "OwnedByPaymentPubKey" a E.value
      OwnedByScript a -> E.encodeTagged "OwnedByScript" a E.value

instance decodeJsonBeneficialOwner :: DecodeJson BeneficialOwner where
  decodeJson =
    defer \_ ->
      D.decode
        $ D.sumType "BeneficialOwner"
        $ Map.fromFoldable
            [ "OwnedByPaymentPubKey" /\ D.content (OwnedByPaymentPubKey <$> D.value)
            , "OwnedByScript" /\ D.content (OwnedByScript <$> D.value)
            ]

derive instance genericBeneficialOwner :: Generic BeneficialOwner _

--------------------------------------------------------------------------------
_OwnedByPaymentPubKey :: Prism' BeneficialOwner PaymentPubKeyHash
_OwnedByPaymentPubKey =
  prism' OwnedByPaymentPubKey case _ of
    (OwnedByPaymentPubKey a) -> Just a
    _ -> Nothing

_OwnedByScript :: Prism' BeneficialOwner String
_OwnedByScript =
  prism' OwnedByScript case _ of
    (OwnedByScript a) -> Just a
    _ -> Nothing

--------------------------------------------------------------------------------
newtype TxKey
  = TxKey
  { _txKeyTxId :: TxId
  , _txKeyTxOutRefIdx :: BigInt
  }

derive instance eqTxKey :: Eq TxKey

instance showTxKey :: Show TxKey where
  show a = genericShow a

instance encodeJsonTxKey :: EncodeJson TxKey where
  encodeJson =
    defer \_ ->
      E.encode $ unwrap
        >$< ( E.record
              { _txKeyTxId: E.value :: _ TxId
              , _txKeyTxOutRefIdx: E.value :: _ BigInt
              }
          )

instance decodeJsonTxKey :: DecodeJson TxKey where
  decodeJson =
    defer \_ ->
      D.decode
        $ ( TxKey
              <$> D.record "TxKey"
                  { _txKeyTxId: D.value :: _ TxId
                  , _txKeyTxOutRefIdx: D.value :: _ BigInt
                  }
          )

derive instance genericTxKey :: Generic TxKey _

derive instance newtypeTxKey :: Newtype TxKey _

--------------------------------------------------------------------------------
_TxKey :: Iso' TxKey { _txKeyTxId :: TxId, _txKeyTxOutRefIdx :: BigInt }
_TxKey = _Newtype

txKeyTxId :: Lens' TxKey TxId
txKeyTxId = _Newtype <<< prop (Proxy :: _ "_txKeyTxId")

txKeyTxOutRefIdx :: Lens' TxKey BigInt
txKeyTxOutRefIdx = _Newtype <<< prop (Proxy :: _ "_txKeyTxOutRefIdx")
