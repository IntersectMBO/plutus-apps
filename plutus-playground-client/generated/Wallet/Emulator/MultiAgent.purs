-- File auto generated by purescript-bridge! --
module Wallet.Emulator.MultiAgent where

import Prelude

import Control.Lazy (defer)
import Data.Argonaut (encodeJson, jsonNull)
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<))
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple.Nested ((/\))
import Plutus.ChainIndex.ChainIndexLog (ChainIndexLog)
import Plutus.Trace.Emulator.Types (ContractInstanceLog, UserThreadMsg)
import Plutus.Trace.Scheduler (SchedulerLog)
import Plutus.V1.Ledger.Slot (Slot)
import Type.Proxy (Proxy(Proxy))
import Wallet.Emulator.Chain (ChainEvent)
import Wallet.Emulator.NodeClient (NodeClientEvent)
import Wallet.Emulator.Wallet (Wallet, WalletEvent)
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

data EmulatorEvent'
  = ChainEvent ChainEvent
  | ClientEvent Wallet NodeClientEvent
  | WalletEvent Wallet WalletEvent
  | ChainIndexEvent Wallet ChainIndexLog
  | SchedulerEvent SchedulerLog
  | InstanceEvent ContractInstanceLog
  | UserThreadEvent UserThreadMsg

instance Show EmulatorEvent' where
  show a = genericShow a

instance EncodeJson EmulatorEvent' where
  encodeJson = defer \_ -> case _ of
    ChainEvent a -> E.encodeTagged "ChainEvent" a E.value
    ClientEvent a b -> E.encodeTagged "ClientEvent" (a /\ b) (E.tuple (E.value >/\< E.value))
    WalletEvent a b -> E.encodeTagged "WalletEvent" (a /\ b) (E.tuple (E.value >/\< E.value))
    ChainIndexEvent a b -> E.encodeTagged "ChainIndexEvent" (a /\ b) (E.tuple (E.value >/\< E.value))
    SchedulerEvent a -> E.encodeTagged "SchedulerEvent" a E.value
    InstanceEvent a -> E.encodeTagged "InstanceEvent" a E.value
    UserThreadEvent a -> E.encodeTagged "UserThreadEvent" a E.value

instance DecodeJson EmulatorEvent' where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "EmulatorEvent'"
    $ Map.fromFoldable
        [ "ChainEvent" /\ D.content (ChainEvent <$> D.value)
        , "ClientEvent" /\ D.content (D.tuple $ ClientEvent </$\> D.value </*\> D.value)
        , "WalletEvent" /\ D.content (D.tuple $ WalletEvent </$\> D.value </*\> D.value)
        , "ChainIndexEvent" /\ D.content (D.tuple $ ChainIndexEvent </$\> D.value </*\> D.value)
        , "SchedulerEvent" /\ D.content (SchedulerEvent <$> D.value)
        , "InstanceEvent" /\ D.content (InstanceEvent <$> D.value)
        , "UserThreadEvent" /\ D.content (UserThreadEvent <$> D.value)
        ]

derive instance Generic EmulatorEvent' _

--------------------------------------------------------------------------------

_ChainEvent :: Prism' EmulatorEvent' ChainEvent
_ChainEvent = prism' ChainEvent case _ of
  (ChainEvent a) -> Just a
  _ -> Nothing

_ClientEvent :: Prism' EmulatorEvent' { a :: Wallet, b :: NodeClientEvent }
_ClientEvent = prism' (\{ a, b } -> (ClientEvent a b)) case _ of
  (ClientEvent a b) -> Just { a, b }
  _ -> Nothing

_WalletEvent :: Prism' EmulatorEvent' { a :: Wallet, b :: WalletEvent }
_WalletEvent = prism' (\{ a, b } -> (WalletEvent a b)) case _ of
  (WalletEvent a b) -> Just { a, b }
  _ -> Nothing

_ChainIndexEvent :: Prism' EmulatorEvent' { a :: Wallet, b :: ChainIndexLog }
_ChainIndexEvent = prism' (\{ a, b } -> (ChainIndexEvent a b)) case _ of
  (ChainIndexEvent a b) -> Just { a, b }
  _ -> Nothing

_SchedulerEvent :: Prism' EmulatorEvent' SchedulerLog
_SchedulerEvent = prism' SchedulerEvent case _ of
  (SchedulerEvent a) -> Just a
  _ -> Nothing

_InstanceEvent :: Prism' EmulatorEvent' ContractInstanceLog
_InstanceEvent = prism' InstanceEvent case _ of
  (InstanceEvent a) -> Just a
  _ -> Nothing

_UserThreadEvent :: Prism' EmulatorEvent' UserThreadMsg
_UserThreadEvent = prism' UserThreadEvent case _ of
  (UserThreadEvent a) -> Just a
  _ -> Nothing

--------------------------------------------------------------------------------

newtype EmulatorTimeEvent a = EmulatorTimeEvent
  { _eteEmulatorTime :: Slot
  , _eteEvent :: a
  }

instance (Show a) => Show (EmulatorTimeEvent a) where
  show a = genericShow a

instance (EncodeJson a) => EncodeJson (EmulatorTimeEvent a) where
  encodeJson = defer \_ -> E.encode $ unwrap >$<
    ( E.record
        { _eteEmulatorTime: E.value :: _ Slot
        , _eteEvent: E.value :: _ a
        }
    )

instance (DecodeJson a) => DecodeJson (EmulatorTimeEvent a) where
  decodeJson = defer \_ -> D.decode $
    ( EmulatorTimeEvent <$> D.record "EmulatorTimeEvent"
        { _eteEmulatorTime: D.value :: _ Slot
        , _eteEvent: D.value :: _ a
        }
    )

derive instance Generic (EmulatorTimeEvent a) _

derive instance Newtype (EmulatorTimeEvent a) _

--------------------------------------------------------------------------------

_EmulatorTimeEvent :: forall a. Iso' (EmulatorTimeEvent a) { _eteEmulatorTime :: Slot, _eteEvent :: a }
_EmulatorTimeEvent = _Newtype

eteEmulatorTime :: forall a. Lens' (EmulatorTimeEvent a) Slot
eteEmulatorTime = _Newtype <<< prop (Proxy :: _ "_eteEmulatorTime")

eteEvent :: forall a. Lens' (EmulatorTimeEvent a) a
eteEvent = _Newtype <<< prop (Proxy :: _ "_eteEvent")
