{-# LANGUAGE AllowAmbiguousTypes        #-}
{-# LANGUAGE ConstraintKinds            #-}
{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveDataTypeable         #-}
{-# LANGUAGE DerivingVia                #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GADTs                      #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NumericUnderscores         #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE PolyKinds                  #-}
{-# LANGUAGE QuantifiedConstraints      #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE RecordWildCards            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TupleSections              #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeFamilies               #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# OPTIONS_GHC -Wno-redundant-constraints -fno-warn-name-shadowing #-}

module Plutus.Contract.Test.ContractModel.DoubleSatisfaction
    ( checkDoubleSatisfaction
    , checkDoubleSatisfactionWithOptions
    ) where

import PlutusTx qualified
import PlutusTx.Builtins hiding (error)

import Cardano.Api qualified as C
import Cardano.Api.Shelley qualified as C
import Control.Lens
import Control.Monad.Cont
import Control.Monad.Freer (Eff, run)
import Control.Monad.Freer.Extras.Log (LogMessage, logMessageContent)
import Control.Monad.State qualified as State
import Data.Map qualified as Map
import Data.Maybe

import Data.Either.Combinators (leftToMaybe)

import Ledger qualified as P
import Ledger.Ada qualified as Ada
import Ledger.CardanoWallet qualified as CW
import Ledger.Crypto
import Ledger.Generators
import Ledger.Index as Index
import Ledger.Scripts
import Ledger.Slot
import Ledger.Tx hiding (mint)
import Ledger.Tx.CardanoAPI (adaToCardanoValue, fromCardanoTxOutToPV1TxInfoTxOut, toCardanoAddressInEra,
                             toCardanoTxOutDatumInTx, toCardanoTxOutDatumInline)
import Ledger.Validation qualified as Validation
import Plutus.Contract.Test hiding (not)
import Plutus.Contract.Test.ContractModel.Internal
import Plutus.Trace.Emulator as Trace (EmulatorTrace, activateContract, callEndpoint, runEmulatorStream)
import Plutus.V1.Ledger.Address
import Streaming qualified as S

import Test.QuickCheck hiding (ShrinkState, checkCoverage, getSize, (.&&.), (.||.))
import Test.QuickCheck.Monadic (monadic)
import Test.QuickCheck.Monadic qualified as QC
import Test.QuickCheck.StateModel hiding (Action, Actions (..), actionName, arbitraryAction, initialState, monitoring,
                                   nextState, pattern Actions, perform, precondition, shrinkAction, stateAfter)
import Test.QuickCheck.StateModel qualified as StateModel

import Wallet.Emulator.Chain hiding (_currentSlot, currentSlot)
import Wallet.Emulator.MultiAgent (EmulatorEvent, EmulatorEvent' (ChainEvent), eteEvent)
import Wallet.Emulator.Stream (EmulatorConfig (_params), EmulatorErr)

import Data.Either (fromRight)
import Prettyprinter

-- Double satisfaction magic

-- | A transaction packed up with enough of the chain state to be able to run validation. This is
--   used both for legitimate transactions and for the transactions manufactured by the double
--   satisfaction test.
data WrappedTx = WrappedTx
  { _dsTxId      :: TxId
  , _dsTx        :: Tx
  , _dsUtxoIndex :: UtxoIndex
  , _dsSlot      :: Slot
  , _dsParams    :: P.Params
  } deriving Show
makeLenses ''WrappedTx

-- | Perform a light-weight check to find egregious double satisfaction
-- vulnerabilities in contracts.
--
-- A counterexample to this property consists of three transactions.
-- * The first transaction is a valid transaction from the trace generated by the contract model.
-- * The second transaction, generated by redirecting
--   a non-datum pubkey output from a non-signer to a signer in the first transaction,
--   fails to validate. This demonstrates that funds can't simply be stolen.
-- * The third transaction goes through and manages to steal funds by altering the first transaction.
--   It is generated by adding another script input (with the same value as the non-signer non-stealable
--   pubkey output) and adding a datum to the non-signer non-stealable pubkey output, and giving the
--   extra value from the new script input to a signer.
checkDoubleSatisfaction :: forall m. ContractModel m
                        => Actions m
                        -> Property
checkDoubleSatisfaction = checkDoubleSatisfactionWithOptions defaultCheckOptionsContractModel
                                                             defaultCoverageOptions

-- | Perform a light-weight check to find egregious double satisfaction
-- vulnerabilities in contracts, with options.
checkDoubleSatisfactionWithOptions :: forall m. ContractModel m
                                   => CheckOptions
                                   -> CoverageOptions
                                   -> Actions m
                                   -> Property
checkDoubleSatisfactionWithOptions opts covopts acts =
  property . monadic (flip State.evalState mempty)
           $ finalChecks opts covopts (finalPredicate finalState (const (pure True))) $ do
   QC.run initiateWallets
   env <- snd <$> runActionsInState StateModel.initialState (toStateModelActions acts)
   ContractMonadState tr _ _ <- QC.run State.get
   let innerAction :: EmulatorTrace AssetMap
       innerAction = State.execStateT (runEmulatorAction tr IMNil) Map.empty

       action = do
         -- see note [The Env contract]
         env <- innerAction
         hdl <- activateContract w1 (getEnvContract @()) envContractInstanceTag
         void $ callEndpoint @"register-token-env" hdl env

       stream :: forall effs. S.Stream (S.Of (LogMessage EmulatorEvent)) (Eff effs) (Either EmulatorErr ())
       stream = fst <$> runEmulatorStream (opts ^. emulatorConfig) action

       (errorResult, events) = S.streamFold (,[]) run (\ (msg S.:> es) -> (fst es, (msg ^. logMessageContent) : snd es)) stream

       chainEvents :: [ChainEvent]
       chainEvents = [ ce | ChainEvent ce <- view eteEvent <$> events ]

   case errorResult of
     Left err -> do
       QC.monitor $ counterexample (show err)
       QC.assert False
     _ -> return ()

   QC.monitor $ tabulate "Number of ChainEvents" (bucket 10 $ length chainEvents)
   QC.monitor $ tabulate "ChainEvent type" (map chainEventType chainEvents)
   case getDSCounterexamples (_params $ _emulatorConfig opts) chainEvents of
    (cands, potentialCEs, []) -> do
      QC.monitor $ tabulate "Validating candidate counterexamples?" [ show $ validateWrappedTx c
                                                                    | c <- cands ]
      QC.monitor $ tabulate "Number of candidates to build counterexamples" (bucket 10 $ length cands)
      QC.monitor $ tabulate "Number of candidate counterexamples" (bucket 10 $ length potentialCEs)
      QC.monitor $ tabulate "Validate counterexample result"
        [ show (validateWrappedTx c0) ++ ", " ++
          show (validateWrappedTx c1)
        | DoubleSatisfactionCounterexample _ c0 c1 _ _ _ <- potentialCEs ]
      QC.monitor $ tabulate "Reasons the steal candidate (that shouldn't work) is rejected"
        [ head . words . show $ r
        | DoubleSatisfactionCounterexample _ c0 c1 _ _ _ <- potentialCEs
        , Prelude.not $ validateWrappedTx c0
        , Just r <- [validateWrappedTx' c1] ]
      QC.monitor $ tabulate "Reasons it doesn't work"
        [ head . words . show $ r
        | DoubleSatisfactionCounterexample _ c0 c1 _ _ _ <- potentialCEs
        , Prelude.not $ validateWrappedTx c0
        , Just r <- [validateWrappedTx' c1] ]
    (_, _, counterexamples)  -> do
      sequence_ [ do QC.monitor $ counterexample (showPretty c)
                | c <- counterexamples ]
      QC.assert False
   return env
    where
      chainEventType (TxnValidate _ constr _) = "TxnValidate "
        ++ (head . words . show $ constr)
      chainEventType ce = head . words . show $ ce

      finalState = StateModel.stateAfter (toStateModelActions acts)

-- | Given a list of chain events, computes a triple of
--    * the list of transactions that were considered for double satisfaction vulnerabilities
--    * the list of candidate counterexamples, i.e. transactions where there were funds that could
--      potentially be stolen
--    * the list of actual counterexamples, i.e. if this is non-empty a vulnerability has been
--      discovered.
getDSCounterexamples :: P.Params -> [ChainEvent] -> ( [WrappedTx]
                                        , [DoubleSatisfactionCounterexample]
                                        , [DoubleSatisfactionCounterexample]
                                        )
getDSCounterexamples params = go 0 mempty
  where
    go _ _ [] = ([], [], [])
    go slot idx (e:es) = case e of
      SlotAdd slot' -> go slot' idx es
      TxnValidate _ txn _ ->
          let
              cUtxoIndex = either (error . show) id $ Validation.fromPlutusIndex idx
              e' = Validation.validateCardanoTx params slot cUtxoIndex txn
              idx' = case e' of
                  Left (Index.Phase1, _) -> idx
                  Left (Index.Phase2, _) -> Index.insertCollateral txn idx
                  Right _                -> Index.insert txn idx
              cands = doubleSatisfactionCandidates params slot idx e
              potentialCEs = doubleSatisfactionCounterexamples =<< cands
              actualCEs = checkForDoubleSatisfactionVulnerability params slot idx e
              (candsRest, potentialRest, counterexamplesRest) = go slot idx' es
          in (cands ++ candsRest, potentialCEs ++ potentialRest, actualCEs ++ counterexamplesRest)
      -- NOTE: We are not including spent collateral inputs here, but that's fine because
      -- the transactions we mutate are never mutated to include these unspent inputs. We only
      -- need to keep track of what UTxOs exist for the validator to validate the transactions
      -- that are created by adding UTxOs from thin air to existing, already validating,
      -- transactions. In the future if you want to do something more interesting to the mutators
      -- you may need to be more careful here (or, you know, rewrite all this code from scratch).
      _ -> go slot idx es

-- | Take a chain event and wrap it up as a `WrappedTx` if it was a transaction
--   validation event.
doubleSatisfactionCandidates :: P.Params -> Slot -> UtxoIndex -> ChainEvent -> [WrappedTx]
doubleSatisfactionCandidates params slot idx event = case event of
  TxnValidate txid (EmulatorTx tx) _ -> [WrappedTx txid tx idx slot params]
  _                                  -> []

-- | Run validation for a `WrappedTx`. Returns @Nothing@ if successful and @Just err@ if validation
--   failed with error @err@.
validateWrappedTx' :: WrappedTx -> Maybe ValidationErrorInPhase
validateWrappedTx' WrappedTx{..} =
  let
    cUtxoIndex = either (error . show) id $ Validation.fromPlutusIndex _dsUtxoIndex
    signedTx = Validation.fromPlutusTxSigned _dsParams cUtxoIndex _dsTx CW.knownPaymentKeys
    e' = Validation.validateCardanoTx _dsParams _dsSlot cUtxoIndex signedTx
  in leftToMaybe e'

-- | Run validation for a `WrappedTx`. Returns @True@ if successful.
validateWrappedTx :: WrappedTx -> Bool
validateWrappedTx = isNothing . validateWrappedTx'

-- | Actual counterexamples showing a double satisfaction vulnerability for the given chain event.
checkForDoubleSatisfactionVulnerability ::
    P.Params ->
    Slot ->
    UtxoIndex ->
    ChainEvent ->
    [DoubleSatisfactionCounterexample]
checkForDoubleSatisfactionVulnerability params slot idx = filter isVulnerable
                                                 . doubleSatisfactionCounterexamples
                                                 <=< doubleSatisfactionCandidates params slot idx

-- | This is an actual counterexample if the first transaction passes validation, the second fails,
--   and the third passes.
data DoubleSatisfactionCounterexample = DoubleSatisfactionCounterexample
  { dsceOriginalTransaction :: WrappedTx
      -- ^ The original transaction goes through.
  , dsceTargetMattersProof  :: WrappedTx
      -- ^ If this fails to validate, it's worth checking for a double satisfaction vulnerability.
      --   Generated by redirecting a non-datum pubkey output from a non-signer to a signer.
  , dsceValueStolenProof    :: WrappedTx
      -- ^ If this candidate validates there is a double satisfaction vulnerability. Generated by adding
      --   another script input (with the same value as the non-signer non-stealable pubkey output)
      --   and adding a datum to the non-signer non-stealable pubkey output, and giving the
      --   extra value from the new script input to a signer.
      --
      --   The scenario is that the other script is using a unique datum to identify the payment to
      --   the non-signer pubkey as coming from that other script.
  , dsceStolenUTxO          :: TxOut
  , dsceStealerWallet       :: Wallet
  , dsceDatumUTxO           :: TxOut
  } deriving Show

showPretty :: DoubleSatisfactionCounterexample -> String
showPretty cand = show . vcat $
  [ "=====Double Satisfaction Counterexample!====="
  , "The following transaction goes through:"
  , ""
  , pretty $ cand ^. to dsceOriginalTransaction . dsTx
  , ""
  , "Whereas the following transaction fails:"
  , ""
  , pretty $ cand ^. to dsceTargetMattersProof . dsTx
  , ""
  , "Showing that we can't simply re-direct UTxO"
  , ""
  , pretty $ dsceStolenUTxO cand
  , ""
  , "to wallet " <> pretty (dsceStealerWallet cand) <> ". However, the following transaction goes through:"
  , ""
  , pretty $ cand ^. to dsceValueStolenProof . dsTx
  , ""
  , "which demonstrates that when another script uses a datum on the following UTxO"
  , ""
  , pretty $ dsceDatumUTxO cand
  , ""
  , "(that isn't visible in the pretty printer), to uniquely identify the payment, "
    <> "we can redirect the UTxO to wallet " <> pretty (dsceStealerWallet cand) <> "."
  , ""
  , "For reference the UTxOs indices above correspond to:"
  ] ++
  [ vcat [ pretty (ref ^. inRef)
         , pretty . fromJust $ Map.lookup (ref ^. inRef)
                         (cand ^. to dsceValueStolenProof . dsUtxoIndex . to getIndex)
         ]
  | let tx0 = cand ^. to dsceTargetMattersProof . dsTx
        tx1 = cand ^. to dsceValueStolenProof . dsTx
        tx2 = cand ^. to dsceOriginalTransaction . dsTx
  , ref <- tx0 ^. inputs
          <> tx1 ^. inputs
          <> tx2 ^. inputs
          <> tx0 ^. collateralInputs
          <> tx1 ^. collateralInputs
          <> tx2 ^. collateralInputs
  ]

isVulnerable :: DoubleSatisfactionCounterexample -> Bool
isVulnerable (DoubleSatisfactionCounterexample orig pre post _ _ _) =
  validateWrappedTx orig &&
  Prelude.not (validateWrappedTx pre) &&
  validateWrappedTx post

-- TODO: change this to be the actual validator that only accepts wallet payments with
-- a specific datum attached. Even though this doesn't technically matter.
--
-- This is not super important, but we want to leave no room for misunderstanding...
alwaysOkValidator :: Versioned Validator
alwaysOkValidator = Versioned (mkValidatorScript $$(PlutusTx.compile [|| (\_ _ _ -> ()) ||])) PlutusV1

doubleSatisfactionCounterexamples :: WrappedTx -> [DoubleSatisfactionCounterexample]
doubleSatisfactionCounterexamples dsc = do
   -- For each output in the candidate tx
   (idx, out) <- zip [0..] (dsc ^. dsTx . outputs)
   -- Is it a pubkeyout?
   guard $ isPubKeyOut $ fromCardanoTxOutToPV1TxInfoTxOut $ P.getTxOut out
   -- Whose key is not in the signatories?
   key <- maybeToList . txOutPubKey $ out
   let signatories = dsc ^. dsTx . signatures . to Map.keys
   guard $ key `notElem` map pubKeyHash signatories
   guard $ length signatories == 1
   -- Then stealerKey can try to steal it
   stealerKey <- signatories
   (stealerWallet, stealerPrivKey) <-
      filter (\(w, _) -> P.unPaymentPubKeyHash (mockWalletPaymentPubKeyHash w) == pubKeyHash stealerKey)
             (zip knownWallets (P.unPaymentPrivateKey <$> knownPaymentPrivateKeys))
   let stealerAddr = pubKeyHashAddress . pubKeyHash $ stealerKey
       stealerCardanoAddress =  fromRight (error "invalid address") (toCardanoAddressInEra P.testnet stealerAddr)
       scriptCardanoAddress = fromRight (error "invalid address")
          (toCardanoAddressInEra P.testnet $ P.scriptValidatorHashAddress (validatorHash alwaysOkValidator) Nothing)
   -- The output going to the original recipient but with a datum
       datum         = Datum . mkB $ "<this is a unique string>"
       datumEmpty    = Datum . mkB $ ""
       redeemerEmpty = Redeemer . mkB $ ""
       withDatumOut = out & outDatumHash .~ toCardanoTxOutDatumInTx datum
       -- Creating TxOut is ugly at the moment because we don't use Cardano addresses, values and datum in the
       -- emulator yet
       newFakeTxScriptOut = TxOut $ C.TxOut
                                  scriptCardanoAddress
                                  (C.TxOutValue C.MultiAssetInBabbageEra $ adaToCardanoValue $ Ada.fromValue $ txOutValue out)
                                  (toCardanoTxOutDatumInline datumEmpty)
                                  C.ReferenceScriptNone
       newFakeTxOutRef = TxOutRef { txOutRefId  = TxId "very sha 256 hash I promise"
                                  , txOutRefIdx = 1
                                  }
       l = dsTx . outputs . ix idx
   let targetMatters0 = dsc & l . outAddress .~ stealerCardanoAddress
       tx             = addSignature' stealerPrivKey (targetMatters0 ^. dsTx & signatures .~ mempty)
       targetMatters1 = targetMatters0 & dsTxId .~ txId tx
                                       & dsTx   .~ tx
       valueStolen0 = dsc & l . outAddress .~ stealerCardanoAddress
                          & dsTx . outputs %~ (withDatumOut:)
                          & dsTx  %~ addScriptTxInput newFakeTxOutRef alwaysOkValidator redeemerEmpty (Just datumEmpty)
                          & dsUtxoIndex %~
                             (\ (UtxoIndex m) -> UtxoIndex $ Map.insert newFakeTxOutRef
                                                                        newFakeTxScriptOut m)
                          & dsTx . datumWitnesses . at (datumHash datum) ?~ datum
                          & dsTx . datumWitnesses . at (datumHash datumEmpty) ?~ datumEmpty
   let tx           = addSignature' stealerPrivKey (valueStolen0 ^. dsTx & signatures .~ mempty)
       valueStolen1 = valueStolen0 & dsTxId .~ txId tx
                                   & dsTx   .~ tx
   pure $ DoubleSatisfactionCounterexample
      { dsceOriginalTransaction = dsc
      , dsceTargetMattersProof  = targetMatters1
      , dsceValueStolenProof    = valueStolen1
      , dsceStolenUTxO          = out
      , dsceDatumUTxO           = withDatumOut
      , dsceStealerWallet       = stealerWallet
      }

toCardanoUtxoIndex :: UtxoIndex -> Validation.UTxO P.EmulatorEra
toCardanoUtxoIndex idx = either (error . show) id $ Validation.fromPlutusIndex idx
